<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Arrays :: Understanding ECMAScript 6</title>
	<link rel="stylesheet" href="font.css">
</head>

<body>
	<nav>
		<a href="09_classes.html" title="previous chapter">◀</a>
		<a href="./index.html" title="cover">◆</a>
		<a href="11_promises.html" title="next chapter">▶</a>
	</nav>
	<header id="header" class="">
		<h1>
			<div class="head-num">Глава 10</div>Подобрени възможности за Arrays</h1>
		<p><em>Array</em> е основен JavaScript обект. Но докато другите аспекти на JavaScript са еволюирали в течение на времето, <em>arrays</em>
			си остават същите, докато ECMAScript 5 не въвежда няколко метода за да ги направи по-лесни за употреба. ECMAScript 6 продължава
			да подобрява <em>arrays</em> чрез добавяне на много по-голяма функционалност, като нови методи за създаване, няколко полезни
			метода за удобство, както и способноста да се направят
			<em>typed arrays</em>.</p>
	</header>
	<!-- /header -->
	<article>
		<h3>Създаване на arrays</h3>
		<p>Преди ECMAScript 6, имаше два основни начина за създаване на <em>array</em> с
			<em>Array</em> конструктор и <em>array</em> синтаксис. И двата подхода изискват индивидуален списък с елементите на <em>array</em> и които
			иначе са доста ограничени. Опциите за превръщане на масиво подобен обект (обект с цифрови индекси и
			<em>length</em> свойство) в <em>array</em> също са доста ограничени и често изискват допълнителен код. За да направи нещата по-лесни,
			ECMAScript 6 добавя два нови метода за създаване на <em>array</em>:
			<em>Array.of()</em> и
			<em>Array.from()</em>.</p>
		<h3>Метода Array.of()</h3>
		<p>Една от причините, поради които ECMAScript 6 добавя нови методи за създаване е да помогне на програмистите да избягват
			приумицата за създаване на <em>array</em> с
			<em>Array</em> конструктора. Конструктора
			<em>new Array()</em> всъщност се държи по различен начин в зависимост от вида и броя на аргументите, подадени към него. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> items = <span class="code">new</span> Array(1, 2);        // length is 2
console.log(items.length);          // 2
console.log(items[0]);              // 1
console.log(items[1]);              // 2

items = <span class="code">new Array</span>(2);
console.log(items.length);          // 2
console.log(items[0]);              // undefined
console.log(items[1]);              // undefined

items = <span class="code">new Array</span>(3, "2");
console.log(items.length);          // 2
console.log(items[0]);              // 3
console.log(items[1]);              // "2"

items = <span class="code">new Array</span>("2");
console.log(items.length);          // 1
console.log(items[0]);              // "2"
			</pre>
			</dd>
		</dl>
		<p>Когато на
			<em>Array</em> конструктора е подадена една единствена цифрова стойност,
			<em>length</em> свойството на <em>array</em> се определя с тази стойност. Ако се подаде една единствена не-цифрова стойност, тогава
			тази стойност става един единствен елемент в <em>array</em>. Ако са подадени няколко стойности (цифрови или не), тогава тези стойности
			стават елементи на <em>array</em>. Това поведение е едновременно объркващо и рисковано, тъй като не винаги можем да бъдем наясно
			с типа на данните, които се подават.</p>
		<p>ECMAScript 6 въвежда
			<em>Array.of()</em> за да реши този проблем. Метода
			<em>Array.of()</em> работи по начин, подобен на
			<em>Array</em> конструктора. Единствената разлика е премахването на специалния случай по отношение на единичната цифрова стойност.
			Метода на
			<em>Array.of()</em> винаги създава <em>array</em>, съдържащ неговите аргументи, независимо от броя или типа на аргументите. Ето няколко
			примера:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> items = <span class="code">Array</span>.of(1, 2);         // length is 2
console.log(items.length);          // 2
console.log(items[0]);              // 1
console.log(items[1]);              // 2

items = <span class="code">Array</span>.of(2);
console.log(items.length);          // 1
console.log(items[0]);              // 2

items = <span class="code">Array</span>.of("2");
console.log(items.length);          // 1
console.log(items[0]);              // "2"
			</pre>
			</dd>
		</dl>
		<p>За да създадете <em>array</em> с
			<em>Array.of()</em> метода, просто му подавате стойностите, които искате във вашия <em>array</em>. Първият пример тук създава <em>array</em>,
			съдържащ две числа, втория <em>array</em> съдържа едно число, а последния <em>array</em> съдържа един
			<em>string</em>. Това е подобно на използването на <em>array</em> литерал, което означава, че можем да използваме <em>array</em> литерал вместо
			<em>Array.of()</em> за локални <em>arrays</em> през по-голямата част от времето. Но ако някога ви се наложи да подадете
			<em>Array</em> конструктор във функция, тогава може би е по-добре да подадете
			<em>Array.of()</em> за да се осигури последователно поведение. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> createArray(arrayCreator, value) {
    <span class="code">return</span> arrayCreator(value);
}

<span class="code">let</span> items = createArray(<span class="code">Array</span>.of, value);
			</pre>
			</dd>
		</dl>
		<p>В този код, функцията
			<em>createArray()</em> приема
			<em>arrayCreator</em> функиця и стойност, за вмъкване в <em>array</em>. След това можем да подадем
			<em>Array.of</em>, като първи аргумент на
			<em>createArray()</em> за създаване на нов <em>array</em>. Би било опасно, директно подаване на
			<em>Array</em>, ако не може да се гарантира, че
			<em>value</em> няма да бъде номер.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Метода
					<em>Array.of()</em> не използва
					<em>Symbol.species</em> свойство (обсъдено в
					<a href="09_classes.html">Глава 9</a>) за да определи типа на върнатата стойност. Вместо това използва текущ конструктор (
					<em>this</em> вътре в
					<em>of()</em> метода) за да определи правилния тип данни, които да върне.</strong>
			</dd>
		</dl>
		<h3>Метода Array.from()</h3>
		<p>Превръщането на <em>non-array</em> обекти в действителни <em>arrays</em> винаги е било тромаво в JavaScript. Например, ако имате
			<em>arguments</em> обект (който е масиво-подобен) и искате да го използвате, като <em>array</em>, тогава първо трябва да го преобразувате.
			За да се превърне масиво-подобен обект в <em>array</em> в ECMAScript 5 ще напишете функция, като тази:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> makeArray(arrayLike) {
    <span class="code">var</span> result = [];

    <span class="code">for</span>(<span class="code">var</span> i = 0, len = arrayLike.length; i < len; i++) {
        result.push(arrayLike[i]);
    }

    <span class="code">return</span> result;
}

<span class="code">function</span> doSomething() {
    <span class="code">var</span> args = makeArray(arguments);

    // use args
}
			</pre>
			</dd>
		</dl>
		<p>Този подход създава
			<em>result</em> <em>array</em> и копира всеки елемент от
			<em>arguments</em> в новия <em>array</em>. Макар, че работи това е една прилична сума от код, за да се изпълни една сравнително проста
			операция. Програмистите, скоро открили начин, с който да се съкрати количеството код с помощта на метода <em>slice()</em>, използван върху масиво-подобни обекти:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> makeArray(arrayLike) {
    <span class="code">return Array</span>.prototype.slice.call(arrayLike);
}

<span class="code">function</span> doSomething() {
    <span class="code">var</span> args = makeArray(arguments);

    // use args
}
			</pre>
			</dd>
		</dl>
		<p>Този код е функционално еквивалентен на предишния пример и работи, защото определя
			<em>this</em> стойността за
			<em>slice()</em> към масиво-подобен обект. Тъй като на
			<em>slice()</em> му трябват само цифрови индекси и
			<em>length</em> свойство за да функционира правилно, всеки масиво-подобен обект ще работи.</p>
		<p>Въпреки, че това изисква по-малко писане, никак не е ясно, че
			<em>Array.prototype.slice.call()</em> означава “превръщане в <em>array</em>.” За щастие ECMAScript 6 добавя метода
			<em>Array.from()</em>, като по разбираем начин за преобразуване на обекти в <em>array</em>.</p>
		<p> Можем да подадем
			<em>iterable</em> или масиво-подобен обект, като първи аргумент и
			<em>Array.from()</em> ще върне <em>array</em>. Ето един прост пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> doSomething() {
    <span class="code">var</span> args = <span class="code">Array</span>.from(arguments);

    // use args
}
			</pre>
			</dd>
		</dl>
		<p>Извикването на
			<em>Array.from()</em> създава нов <em>array</em> на базата на елементите в
			<em>arguments</em>. Така че,
			<em>args</em> е инстанция на
			<em>Array</em>, който съдържа същите стойности в същите позиции, както
			<em>arguments</em>.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>
					<em>Array.from()</em> също използва
					<em>this</em> за да определи типа на <em>array</em>, който трябва да върне.</strong>
			</dd>
		</dl>
		<h3>Mapping Conversion</h3>
		<p>Ако искате да отидете една крачка напред, можете да предоставите на
			<em>Array.from()</em> преобразуваща функция, като втори аргумент. Тази функция работи въху всяка стойност от масиво-подобния
			обект и я преобразува в някаква окончателната форма преди съхранение на резултата в съответния индекс на крайния <em>array</em>.
			Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> translate() {
    <span class="code">return Array</span>.from(arguments, (value) => value + 1);
}

<span class="code">let</span> numbers = translate(1, 2, 3);

console.log(numbers);               // 2,3,4
			</pre>
			</dd>
		</dl>
		<p>Тука,
			<em>Array.from()</em> подава
			<em>(value) => value + 1</em>, като преобразуваща функция, която добавя едно към всеки елемент в <em>array</em> преди съхранение на
			елементите. Ако преобразуващата функция е върху даден обект, можете по желание да подадете трети аргумент на
			<em>Array.from()</em>, който представлява стойността на
			<em>this</em> за преобразуващата функция:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> helper = {
    diff: 1,

    add(value) {
        <span class="code">return</span> value + <span class="code">this</span>.diff;
    }
};

<span class="code">function</span> translate() {
    <span class="code">return Array</span>.from(arguments, helper.add, helper);
}

<span class="code">let</span> numbers = translate(1, 2, 3);

console.log(numbers);               // 2,3,4
			</pre>
			</dd>
		</dl>
		<p>Този пример използва
			<em>helper.add()</em> метод, като преобразуваща функция за преобразуването. Тъй като,
			<em>helper.add()</em> използва
			<em>this.diff</em> свойството, трябва да се предостави трети аргумент за
			<em>Array.from()</em> за определяне на стойността на
			<em>this</em>. Благодарение на третия аргумент,
			<em>Array.from()</em> може лесно да се справя с преобразуване на данни без да е необходимо да се използва
			<em>bind()</em> или уточняване на стойността на
			<em>this</em> по някакъв друг начин.</p>
		<h3>Използване на Iterables</h3>
		<p>Метода
			<em>Array.from()</em> работи, както с масиво-подобни обекти така и с
			<em>iterables</em>. Това означава, че метода може да превърне всеки обект с
			<em>Symbol.iterator</em> свойство в <em>array</em>. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> numbers = {
    *[Symbol.iterator]() {
        <span class="code">yield</span> 1;
        <span class="code">yield</span> 2;
        <span class="code">yield</span> 3;
    }
};

<span class="code">let</span> numbers2 = <span class="code">Array</span>.from(numbers, (value) => value + 1);

console.log(numbers2);              // 2,3,4
	    	</pre>
			</dd>
		</dl>
		<p>В този код,
			<em>numbers</em> обекта е
			<em>iterable</em>, така че може да се подаде директно към
			<em>Array.from()</em>, за преобразуване на неговите стойности в <em>array</em>. Преобразуващата функция добавя едно към всеки брой,
			така полученият <em>array</em> съдържа 2, 3 и 4, вместо 1, 2 и 3.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Ако един обект е едновременно масиво-подобен и
					<em>iterable, Array.from()</em> използва итератор за определяне на стойностите за преобразуване. </strong>
			</dd>
		</dl>
		<h3>Нови методи за всички <em>arrays</em></h3>
		<p>Продължавайки тенденцията от ECMAScript 5, ECMAScript 6 добавя няколко нови методи за <em>array</em>. Методите
			<em>find()</em> и
			<em>findIndex()</em> са предназначени за подпомагане на програмистите използващи <em>array</em> с някакви стойности, а
			<em>fill()</em> и
			<em>copyWithin()</em> са до голяма степен вдъхновени от използването за случаи с
			<em>typed arrays</em>, форма на <em>array</em> въведена в ECMAScript 6, която използва само цифри.</p>
		<h3>Методите find() и findIndex()</h3>
		<p>Преди ECMAScript 5, търсенето през <em>array</em> е било тромаво, защото не е имало вградени методи затова. ECMAScript 5 добавя
			<em>indexOf()</em> и
			<em>lastIndexOf()</em>, които най-накрая позволяват на програмистите да търсят конкретни стойности вътре в <em>array</em>. Като голямо
			подобрение, тези два метода са все още доста ограничени, защото можете да търсите само една стойност в даден момент. Например,
			ако искате да намерите първото четно число в поредица от числа, ще трябва да напишете свой собствен код за да го направите.
			ECMAScript 6 решава този проблем, чрез въвеждане на два нови метода:
			<em>find()</em> и
			<em>findIndex()</em>.</p>
		<p>Методите
			<em>find()</em> и
			<em>findIndex()</em> приемат два аргумента, функция за обратно извикване и не задължителната стойност за използване
			<em>this</em> вътре във функцията за обратно извикване. На функцията за обратно извикване е подаден елемент от <em>array</em>, индекса
			на този елемент в <em>array</em> и самия <em>array</em>, същите аргументи, като за
			<em>map()</em> и
			<em>forEach()</em>. Обратното извикване трябва да върне
			<em>true</em>, ако дадената стойност съвпада с някои критерии, които сте задали. И двата,
			<em>find()</em> и
			<em>findIndex()</em> спират търсенето в <em>array</em> при първото връщане на
			<em>true</em> от функцията за обратно извикване</p>
		<p>Единствената разлика между тези методи е, че
			<em>find()</em> връща стойността, докато
			<em>findIndex()</em> връща индекса, на който е установена стойността. Ето един пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> numbers = [25, 30, 35, 40, 45];

console.log(numbers.find(n => n > 33));         // 35
console.log(numbers.findIndex(n => n > 33));    // 2
	    	</pre>
			</dd>
		</dl>
		<p>Този код използва,
			<em>find()</em> и
			<em>findIndex()</em> за намиране на първата стойност в
			<em>numbers</em>, която е по-голяма от 33. Извикването на
			<em>find()</em> връща 35, докато
			<em>findIndex()</em> връща 2, местоположението на 35 в
			<em>numbers</em>.</p>
		<p>И двата,
			<em>find()</em> и
			<em>findIndex()</em> са полезни за намиране на елемент в <em>array</em>, който съвпада с условието, а не със стойността. Ако искате
			само да намерите стойност, тогава
			<em>indexOf()</em> и
			<em>lastIndexOf()</em> са по-добър избор.</p>
		<h3>Метода fill()</h3>
		<p>Метода
			<em>fill()</em> запълва един или повече елементи в <em>array</em> с конкретна стойност. Когато се подаде стойност,
			<em>fill()</em> презаписва всички стойности в <em>array</em> с тази стойност. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> numbers = [1, 2, 3, 4];

numbers.fill(1);

console.log(numbers.toString());    // 1,1,1,1
	    	</pre>
			</dd>
		</dl>
		<p>Тука, извикването на
			<em>numbers.fill(1)</em> променя всички стойности в
			<em>numbers</em> на 1. Ако искате да се променят само някои от елементите, а не всички от тях, може евентуално да включите
			индекси за начало и край, като например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> numbers = [1, 2, 3, 4];

numbers.fill(1, 2);

console.log(numbers.toString());    // 1,2,1,1

numbers.fill(0, 1, 3);

console.log(numbers.toString());    // 1,0,0,1
	    	</pre>
			</dd>
		</dl>
		<p>В този пример,
			<em>numbers.fill(1, 2)</em> започва попълването на елементи от индекс 2. Индекса за край не е уточнен с трети аргумент, така
			че
			<em>numbers.length</em> се счита за краен индекс, което означава, че последните два елемента в
			<em>numbers</em> ще се запълнят с 1. Следващата операция,
			<em>numbers.fill(0, 1, 3)</em>, запълва <em>array</em> с елементи в индекси 1 и 2 със 0. Извикването на
			<em>fill()</em> с втори и трети аргумент ни дава възможност да запълним няколко елемента наведнъж без да се презаписва целия
			<em>array</em>.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Ако индексите за начало или край са отрицателни, тогава тези стойности се добавят към дължината на <em>array</em>, за да се определи
					крайното местоположение. Така например, начално местоположение от -1 дава
					<em>array.length-1</em>, като индекс върху, който
					<em>fill()</em> се извиква.</strong>
			</dd>
		</dl>
		<h3>Метода copyWithin()</h3>
		<p>Метода
			<em>copyWithin()</em> е подобен на
			<em>fill()</em> в това, че променя няколко елемента в <em>array</em> едновременно. Обаче, вместо да се посочва единична стойност за
			запълване,
			<em>copyWithin()</em> ви позволява да копирате стойност за запълване на елементите в <em>array</em> от самия <em>array</em>. За да постигнете
			това, трябва да подадете два аргумента към
			<em>copyWithin()</em>, индекса, от където метода трябва да започне запълването на стойности и индекса, от където започва копирането
			на стойности.</p>
		<p>Например, за да копирате стойностите от първите два елемента в <em>array</em>, върху последните два елемента в <em>array</em>, може да
			го направите по следния начин:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> numbers = [1, 2, 3, 4];

<span class="comment"><em>//поставяне на стойности в <em>array</em>, започвайки от индекс 2</em></span>
<span class="comment"><em>//копиране на стойности в <em>array</em>, започвайки от индекс 0</em></span>
numbers.copyWithin(2, 0);

console.log(numbers.toString());    // 1,2,1,2
	    	</pre>
			</dd>
		</dl>
		<p>Този код запълва стойности в
			<em>numbers</em> започвайки от индекс 2, така че двата индекса 2 и 3 ще бъдат презаписани. Вторият аргумент на
			<em>copyWithin()</em> е 0, който показва началото на копиране на стойности от индекс 0 и да продължи, докато няма повече елементи
			за копиране вътре.</p>
		<p>По подразбиране,
			<em>copyWithin()</em> винаги копира стойностите до края на <em>array</em>, но можете да предоставите трети не задължителен аргумент,
			за ограничаване на елементите, които трябва да бъдат презаписани. Този трети аргумент е с изключващ краен индекс, в който
			копирането на стойности спира. Ето един пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> numbers = [1, 2, 3, 4];

<span class="comment"><em>//поставяне на стойности в <em>array</em>, започвайки от индекс 2</em></span>
<span class="comment"><em>//копиране на стойности в <em>array</em>, започвайки от индекс 0</em></span>
<span class="comment"><em>//спиране на копирането на стойности, в индекс 1</em></span>
numbers.copyWithin(2, 0, 1);

console.log(numbers.toString());    // 1,2,1,4
	    	</pre>
			</dd>
		</dl>
		<p>В този пример, само стойността от индекс 0 се копира, защото избора за краен индекс е определен на 1. Последния елемент
			в <em>array</em> остава не променен.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Както и при
					<em>fill()</em> метода, ако се подаде отрицателно число за всеки аргумент на
					<em>copyWithin()</em>, дължината на <em>array</em> автоматично се добавя към тази стойност, за да се определи индекса за използване.</strong>
			</dd>
		</dl>
		<p>Случаи на употреба за
			<em>fill()</em> и
			<em>copyWithin()</em> може да не са очевидни за вас в този момент. Това е така, защото тези методи са възникнали първоначално
			за
			<em>typed arrays</em> и след това за съгласуваност са добавени за редовни <em>array</em>. Както ще научите в следващата част, ако
			използвате
			<em>typed arrays</em> за манипулиране на бита с пробитово изместване на редицата, тези методи са много полезни.</p>
		<h3>Typed Arrays</h3>
		<p>
			<em>Typed arrays</em> са <em>arrays</em> със специално предназначение, предназначени за работа с цифрови типове (не всички типове,
			както може да изглежда от името). Произхода на
			<em>typed arrays</em> може да бъде проследен обратно до WebGL, пристанище на Open GL ES 2.0 предназначен за работа в уеб-страници
			с &ltcanvas&gt елемент.
			<em>Typed arrays</em> са създадени, като част от този порт, за осигуряване на бърза пробитова аритметика в JavaScript.</p>
		<p>Аритметиката с числа в JavaScript е твърде бавна за WebGL, защото числата се съхраняват в 64-битов десетичен формат и се
			преобразуват в 32-битови цели числа когато е необходимо. Така че
			<em>typed arrays</em> са въведени за заобикаляне на това ограничение и осигуряване на по-добра производителност за аритметични
			операции. Концепцията е, че всяко едно число може да бъде третирано, като <em>array</em> от битове и по този начин може да се използват
			познатите методи за <em>arrays</em> в JavaScript.</p>
		<p>ECMAScript 6 прие
			<em>typed arrays</em>, като официална част на езика, за да се гарантира по-добра съвместимост в цялата JavaScript машина и
			оперативна съвместимост с JavaScript <em>arrays</em>. Докато версията на
			<em>typed arrays</em> в ECMAScript 6 не е точно същата, както версията на WebGL, те са достатъчно сходни, за да направи версията
			на ECMAScript 6 еволюция на версията на WebGL, а не по-различен подход.</p>
		<h3>Цифрови типове данни</h3>
		<p>JavaScript номерата се съхраняват в IEEE 754 формат, използвайки 64 бита за съхранение с плаваща запетая за представяне
			на броя. Този формат представлява
			<em>integers</em> (цели) и
			<em>floats</em> (десетични) числа в JavaScript, с преобразуване между двата формата, което се случва често, когато номерата
			се променят. <em>Arrays</em> позволяват съхранението и манипулирането на осем различни цифрови типа:</p>
		<dl>
			<dd>
				<ol>
					<li>Signed 8-bit integer (int8)</li>
					<li>Unsigned 8-bit integer (uint8)</li>
					<li>Signed 16-bit integer (int16)</li>
					<li>Unsigned 16-bit integer (uint16)</li>
					<li>Signed 32-bit integer (int32)</li>
					<li>Unsigned 32-bit integer (uint32)</li>
					<li>32-bit float (float32)</li>
					<li>64-bit float (float64)</li>
				</ol>
			</dd>
		</dl>
		<p>Ако искате да представите
			<em>int8</em> в JavaScript номер, вие ще загубите 56 бита. Тези битове може по-добре да се използват за съхранение на допълнителни
			<em>int8</em> стойности или друг номер, който изисква по-малко от 56 бита. Използването на бита по-ефективно е един от случаите
			на употреба на
			<em>typed array</em> адрес.</p>
		<p>Всички операции и обекти свързани с
			<em>typed arrays</em> са центрирани около осемте типа данни. За да ги използвате, обаче, ще трябва да създадете
			<em>array buffer</em> за съхранение на данни.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>В тази книга, аз ще се отнасям към тези типове със съкращенията, показани в скобите. Тези съкращения не се показват в
					действителния JavaScript код, те са просто обозначение за много по-дълги описания.</strong>
			</dd>
		</dl>
		<h3>Array buffer</h3>
		<p>В основата на всички
			<em>typed arrays</em> е <em>array buffer</em>, който е място в паметта и съдържа определен брой байтове. Създаването на <em>array buffer</em>
			е равносилно на извикване на
			<em>malloc()</em> в C за разпределяне на памет без да се уточнява, какво ще се съдържа в нея. Можете да създадете <em>array buffer</em>
			с помощта на
			<em>ArrayBuffer</em> конструктора, както следва:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> buffer = <span class="code">new</span> ArrayBuffer(10);   // allocate 10 bytes
	    		
	    	</pre>
			</dd>
		</dl>
		<p>Просто подавате броя байтове, които <em>array buffer</em> трябва да съдържа, когато извикате конструктора. Това
			<em>let</em> изявление създава <em>array buffer</em> с дължина 10 байта. След като е създаден <em>array buffer</em>, можете да извлечете броя
			на байтовете в него с помощта на
			<em>byteLength</em> свойството:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> buffer = <span class="code">new</span> ArrayBuffer(10);   // allocate 10 bytes
console.log(buffer.byteLength);     // 10
	    	</pre>
			</dd>
		</dl>
		<p>Можете също да използвате
			<em>slice()</em> метода за създаване на нов <em>array buffer</em>, който съдържа част от съществуващ <em>array buffer</em>. Метода
			<em>slice()</em> работи подобно на
			<em>slice()</em> метода за <em>array</em> , в който се подава начален и краен индекс, като аргументи и връща нова инстанция на
			<em>ArrayBuffer</em> съставена от елементите на оригинала. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> buffer = <span class="code">new</span> ArrayBuffer(10);   // allocate 10 bytes


<span class="code">let</span> buffer2 = buffer.slice(4, 6);
console.log(buffer2.byteLength);    // 2	    		
	    	</pre>
			</dd>
		</dl>
		<p>В този код,
			<em>buffer2</em> е създаден, чрез извличане на байтове в индексите 4 и 5. Точно, както при версията за <em>array</em> на този метод,
			втория аргумент за
			<em>slice()</em> е с изключващ краен индекс.</p>
		<p>Разбира се, създаването само на място за съхранение не е много полезно, без да могат да се записват данни в него. За да
			направите това, ще трябва да създадете
			<em>view</em>.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Един <em>array buffer</em> винаги представлява точния брой байтове, определени при неговото създаване. Можете да променяте данните
					съдържащи се в рамките на <em>array buffer</em>, но не и големината на самия <em>array buffer</em>.</strong>
			</dd>
		</dl>
		<h3>Манипулиране на array buffer с Views</h3>
		<p><em>Array buffer</em> представлява място в паметта и
			<em>views</em> е интерфейс, чрез който се манипулира тази памет.
			<em>View</em> работи в <em>array buffer</em> или част от байтовете на <em>array buffer</em>, като чете и пише данни в един от цифровите типове
			данни. Типа
			<em>DataView</em> е общ
			<em>view</em>, който позволява да се работи с всички осем типа цифрови данни.</p>
		<p>За да използваме
			<em>DataView</em>, първо трябва да създадем инстанция на
			<em>ArrayBuffer</em> и след това да го използваме за да създадем
			<em>new DataView</em>. Ето един пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> buffer = <span class="code">new</span> ArrayBuffer(10),
    view = <span class="code">new</span> DataView(buffer);	
	    	</pre>
			</dd>
		</dl>
		<p>Обекта
			<em>view</em> в този пример, има достъп до целият 10 байтов
			<em>buffer</em>. Алтернативно можем да създадем
			<em>view</em> само за част от буфера. Просто предоставяме байт за отместване и евентуално, броя на байтовете, които да се
			включат в това отместване. Когато няма включени определен брой байтове,
			<em>DataView</em> ще мине от отместването до края на буфера по подразбиране. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> buffer = <span class="code">new</span> ArrayBuffer(10),
    view = <span class="code">new</span> DataView(buffer, 5, 2);  // cover bytes 5 and 6
	    	</pre>
			</dd>
		</dl>
		<p>Тука,
			<em>view</em> действа само върху байтове в индекси 5 и 6. Този подход позволява да създавадете няколко
			<em>views</em> към същия <em>array buffer</em>, което може да бъде полезно, ако искате да използвате само част от място в паметта за
			цялото приложение, вместо динамично разпределяне на пространството, когато е необходимо.</p>
		<h3>Извличане на View информация</h3>
		<p>Можете да извлечате информация от
			<em>view</em>, използвайки следните само за четене свойства.</p>
		<dl>
			<dd>
				<ul>
					<li>
						<strong>
							<em>buffer</em>
						</strong> - <em>array buffer</em>, с който
						<em>view</em> е обвързан</li>
					<li>
						<strong>
							<em>byteOffset</em>
						</strong> - втори аргумент към
						<em>DataView</em> конструктора, ако е предвиден (0 е по подразбиране)</li>
					<li>
						<strong>
							<em>byteLength</em>
						</strong> - трети аргумент към
						<em>DataView</em> конструктора, ако е предвиден (буфера има
						<em>byteLength</em> по подразбиране)</li>
				</ul>
			</dd>
		</dl>
		<p>Използвайки тези свойства, можете да определите, къде точно view работи, например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> buffer = <span class="code">new</span> ArrayBuffer(10),
    view1 = <span class="code">new</span> DataView(buffer),        // cover all bytes
    view2 = <span class="code">new</span> DataView(buffer, 5, 2);  // cover bytes 5 and 6

console.log(view1.buffer === buffer);       // true
console.log(view2.buffer === buffer);       // true
console.log(view1.byteOffset);              // 0
console.log(view2.byteOffset);              // 5
console.log(view1.byteLength);              // 10
console.log(view2.byteLength);              // 2
	    	</pre>
			</dd>
		</dl>
		<p>Този код създава
			<em>view1</em>, който действа върху целия <em>array buffer</em> и
			<em>view2</em>, който работи върху малък участък от <em>array buffer</em>. Тези
			<em>views</em> са с еквивалентни буфер свойства, тъй като и двете работят върху същия <em>array buffer</em>. The
			<em>byteOffset</em> и
			<em>byteLength</em> са различни за всяко
			<em>view</em>, обаче. Те отразяват само част от <em>array buffer</em>, където всяко
			<em>views</em> работи.</p>
		<p>Разбира се, четенето на информация от паметта не е много полезно, само по себе си. Трябва да се запишат данни във и да
			се чететат тези данни от паметта, за да се извлече някаква полза.</p>
		<h3>Четене и записване на данни</h3>
		<p>За всеки от осемте цифрови типове данни в JavaScript
			<em>DataView</em> прототипа има метод за запис на данни, както и метод за четене на данни от <em>array buffer</em>. Имената на методите
			за всички, започват със “set” или “get”, последвани от съкращението на типа данни. Например, ето списък на методите за
			четене и записване, които могат да работят върху
			<em>int8</em> и
			<em>uint8</em> стойности:</p>
		<dl>
			<dd>
				<ul>
					<li>getInt8(byteOffset, littleEndian) - Четене на
						<em>int8</em> започвайки от
						<em>byteOffset</em>
					</li>
					<li>setInt8(byteOffset, value, littleEndian) - Записване на
						<em>int8</em> започвайки от
						<em>byteOffset</em>
					</li>
					<li>getUint8(byteOffset, littleEndian) - Четене на
						<em>uint8</em> започвайки от
						<em>byteOffset</em>
					</li>
					<li>setUint8(byteOffset, value, littleEndian) - Записване на
						<em>uint8</em> започвайки от
						<em>byteOffset</em>
					</li>
				</ul>
			</dd>
		</dl>
		<p>Методa
			<em>get</em> приема два аргумента:
			<em>byteOffset</em> (байт за отместване) за четене от и не задължителна булева стойност, която посочва дали стойността следва
			да се чете, като
			<em>little-endian</em> (малък-къс). (
			<em>Little-endian</em> означава, че най-маловажният бит е в байт 0, вместо в последния байт.) Метода
			<em>set</em> приема три аргумента:
			<em>byteOffset</em> да записва от, стойността за записване и не задължителна булева стойност, която посочва дали стойността
			трябва да се съхранява в
			<em>little-endian</em> формат.</p>
		<p>Въпреки, че аз само показвам методите, които можете да използвате с 8-битови стойности, съществуват същите методи за работа
			с 16- и 32-битови стойности. Просто сменете 8 във всяко име с 16 или 32. Наред с всички тези целочислени методи,
			<em>DataView</em> също има следните методи за четене и записване на десетични числа:</p>
		<dl>
			<dd>
				<ul>
					<li>getFloat32(byteOffset, littleEndian) - Четене на
						<em>float32</em> започвайки от
						<em>byteOffset</em>
					</li>
					<li>setFloat32(byteOffset, value, littleEndian) - Записване на
						<em>float32</em> започвайки от
						<em>byteOffset</em>
					</li>
					<li>getFloat64(byteOffset, littleEndian) - Четене на
						<em>float64</em> започвайки от
						<em>byteOffset</em>
					</li>
					<li>setFloat64(byteOffset, value, littleEndian) - Записване на
						<em>float64</em> започвайки от
						<em>byteOffset</em>
					</li>
				</ul>
			</dd>
		</dl>
		<p>За да видите методите "get" и "set" в действие, да разгледаме следния пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> buffer = <span class="code">new</span> ArrayBuffer(2),
    view = <span class="code">new</span> DataView(buffer);

view.setInt8(0, 5);
view.setInt8(1, -1);

console.log(view.getInt8(0));       // 5
console.log(view.getInt8(1));       // -1 
	    	</pre>
			</dd>
		</dl>
		<p>Този код използва дву-байтов <em>array buffer</em> за съхраняване на две
			<em>int8</em> стойности. Първата стойност се определя с отместване 0, а втората е с отместване 1, отразявайки факта, че всяка
			стойност обхваща пълен байт (8 бита). Тези стойности по-късно са извлечени от позициите си с метода
			<em>getInt8()</em>. Докато този пример използва
			<em>int8</em> стойности, можете да използвате всеки от осемте цифрови типа с техните съответните методи.</p>
		<p>
			<em>Views</em> са интересни, защото те ви позволяват да четете и пишете във всякакъв формат във всяка точка във времето, независимо
			от това, как се съхраняват данните преди това. Например записване на две
			<em>int8</em> стойности и четенето на буфера с
			<em>int16</em> метод работи добре, като в този пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> buffer = <span class="code">new</span> ArrayBuffer(2),
    view = <span class="code">new</span> DataView(buffer);

view.setInt8(0, 5);
view.setInt8(1, -1);

console.log(view.getInt16(0));      // 1535
console.log(view.getInt8(0));       // 5
console.log(view.getInt8(1));       // -1 
	    	</pre>
			</dd>
		</dl>
		<p>Извикването на
			<em>view.getInt16(0)</em> чете всички байтове във
			<em>view</em> и интерпретира тези байтове, като номера 1535. За да разберем защо това се случва, да разгледаме Фигура 10-1,
			която показва какво прави всеки
			<em>setInt8()</em> ред в <em>array buffer</em>.</p>
		<dl>
			<dd>
				<p>new ArrayBuffer(2)&nbsp; &nbsp; &nbsp; &nbsp;0000000000000000</p>
				<p>view.setInt8(0, 5);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0000010100000000</p>
				<p>view.setInt8(1, -1);&nbsp; &nbsp; &nbsp; &nbsp;0000010111111111</p>
			</dd>
		</dl>
		<p><em>Array buffer</em> започва с 16 бита, които са нули. Записването на 5 към първия байт със
			<em>setInt8</em> въвежда няколко 1-ци (в 8-битово представяне на 5, като 00000101). Записвайки -1 към втория байт определя
			всички битове в този байт към 1, което е второто допълнение за представянето на -1. След второто извикване на
			<em>setInt8()</em>, <em>array buffer</em> съдържа 16 бита и
			<em>getInt16()</em> чете тези битове като единo 16-битово цяло число, което е 1535 в
			<em>decimal</em>.</p>
		<p>Обекта
			<em>DataView</em> е идеален за случай на употреба, които смесва различни типове данни по този начин. Въпреки това, ако използвате
			един специфичен тип данни, тогава тип-спецификацията на
			<em>view</em> за типа e по-добър избор.</p>
		<h3>Typed Arrays Are Views</h3>
		<p>В ECMAScript 6,
			<em>typed arrays</em> са всъщност специфичните за типа
			<em>views</em> за <em>array buffer</em>. Вместо да се използва общ
				<em>DataView</em> обект, за да работи върху <em>array buffer</em> можете да използвате обекти, които налагат специфични типове данни.
				Има осем специфични типа
				<em>views</em>, съответстващи на осемте типа цифрови данни плюс един допълнителен по избор за
				<em>uint8</em> стойности.</p>
		<p>Таблица 10-1 показва съкратен вариант на пълния списък на тип-спецификацията за
			<em>view</em> от раздел 22.2 на ECMAScript 6 спецификацията.</p>
		<dl>
			<dd>
				<table class="table">
					<tr>
						<th>Constructor Name</th>
						<th>Element
							<br>Size</th>
						<th>Description</th>
						<th>Equivalent
							<br>C Type</th>
					</tr>
					<tr>
						<td>Int8Array</td>
						<td>1</td>
						<td>8-bit 2’s
							<br> complement
							<br>signed
							<br> integer</td>
						<td>signed
							<br>char</td>
					</tr>
					<tr>
						<td>Uint8Array</td>
						<td>1</td>
						<td>8-bit
							<br>unsigned
							<br>integer</td>
						<td>unsigned
							<br> char</td>
					</tr>
					<tr>
						<td>Uint8ClampedArray</td>
						<td>1</td>
						<td>8-bit
							<br> unsigned
							<br> integer
							<br>(clamped
							<br>conversion)</td>
						<td>unsigned
							<br>char</td>
					</tr>
					<tr>
						<td>Int16Array</td>
						<td>2</td>
						<td>16-bit 2’s
							<br> complement
							<br>signed
							<br>integer </td>
						<td>short</td>
					</tr>
					<tr>
						<td>Uint16Array</td>
						<td>2</td>
						<td>16-bit
							<br>unsigned
							<br>integer</td>
						<td>unsigned
							<br>short</td>
					</tr>
					<tr>
						<td>Int32Array</td>
						<td>4</td>
						<td>32-bit 2’s
							<br> complement
							<br>signed
							<br>integer</td>
						<td>int</td>
					</tr>
					<tr>
						<td>Uint32Array</td>
						<td>4</td>
						<td>32-bit
							<br>unsigned
							<br>integer
							<br>unsigned</td>
						<td>int</td>
					</tr>
					<tr>
						<td>Float32Array</td>
						<td>4</td>
						<td>32-bit IEEE
							<br>floating
							<br>point</td>
						<td>float</td>
					</tr>
					<tr>
						<td>Float64Array</td>
						<td>8</td>
						<td>64-bit IEEE
							<br>floating
							<br>point</td>
						<td>double</td>
					</tr>
				</table>
			</dd>
		</dl>
		<p>В лявата колона са изброени
			<em>typed arrays</em> конструкторите, a другите колони описват данните, които всеки
			<em>typed array</em> може да съдържа.
			<em>Uint8ClampedArray</em> е също, като
			<em>Uint8Array</em>, освен в случаите когато стойностите са по-малки от 0 и по-големи от 255. В този случай
			<em>Uint8ClampedArray</em> ще преобразува стойности по-ниски от 0 на 0 (-1 ще стане 0, например) и стойности по-големи от
			255 на 255 (300 ще стане 255, например).</p>
		<p>
			<em>Тyped arrays</em> операциите работят само върху определен тип данни. Например, всички операции на
			<em>Int8Array</em> работят с
			<em>int8</em> стойности. Размерът на елемент в
			<em>typed arrays</em> също зависи от типа на <em>array</em>. Докато един елемент в
			<em>Int8Array</em> е дълъг един байт,
			<em>Float64Array</em> използва осем байта за елемент. За щастие, елементите са достъпни чрез цифрови индекси, точно както
			редовни <em>array</em>, което позволява да се избегнат до някъде неудобните повиквания на “set” и“get” методите на
			<em>DataView</em>.</p>
		<div class="aside">
			<h3>Размер на елемент</h3>
			<p>Всеки
				<em>typed array</em> се състои от няколко елемента и размерът на елементите е броят на байтовете, които всеки елемент представлява.
				Тази стойност се съхранява в BYTES_PER_ELEMENT свойството на всеки конструктор и за всеки отделен случай, така че лесно
				можем да дадем заявка за размера на елемента.</p>
			<pre class="highlight">
console.log(UInt8Array.BYTES_PER_ELEMENT);    // 1
console.log(UInt16Array.BYTES_PER_ELEMENT);   // 2

<span class="code">let</span> ints = <span class="code">new</span> Int8Array(5);
console.log(ints.BYTES_PER_ELEMENT);          // 1
	  	</pre>
		</div>

		<h3>Създаване на специфични типове Views</h3>
		<p>Конструктора на
			<em>typed arrays</em> приема няколко типа аргументи, така че има няколко начина за създаване на
			<em>typed array</em>. Първо, можем да създадем нов
			<em>typed array</em> с подаване на същите аргументи, които
			<em>DataView</em> приема (
			<em>buffer</em>, незадължителен
			<em>byteOffset</em> и незадължителен
			<em>byteLength</em>). Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> buffer = <span class="code">new</span> ArrayBuffer(10),
    view1 = <span class="code">new</span> Int8Array(buffer),
    view2 = <span class="code">new</span> Int8Array(buffer, 5, 2);

console.log(view1.buffer === buffer);       // true
console.log(view2.buffer === buffer);       // true
console.log(view1.byteOffset);              // 0
console.log(view2.byteOffset);              // 5
console.log(view1.byteLength);              // 10
console.log(view2.byteLength);              // 2
	  	</pre>
			</dd>
		</dl>
		<p>В този код, двете
			<em>views</em> са две
			<em>UInt8Array</em> инстанции, които използват
			<em>buffer</em>. И двата
			<em>view1</em> и
			<em>view2</em> имат същите
			<em>buffer, byteOffset</em> и
			<em>byteLength</em> свойства, които съществуват за
			<em>DataView</em> инстанцията. Преминаването към използване на
			<em>typed array</em> е лесно, където можете да използвате
			<em>DataView</em> толкова дълго, колкото работите само с един цифров тип.</p>
		<p>Вторият начин за създаване на
			<em>typed array</em> е с подаване на номер към конструктора. Този номер представлява броя на елементите (не байтове) за разпределяне
			в <em>array</em>. Конструктора ще създаде нов буфер с правилния брой байтове за представяне на редицата на елементите в <em>array</em>
			и можем да получим достъп до броя на елементите в <em>array</em> с помощта на свойството
			<em>length</em>. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> ints = <span class="code">new</span> Int16Array(2),
    floats = <span class="code">new</span> Float32Array(5);

console.log(ints.byteLength);       // 4
console.log(ints.length);           // 2

console.log(floats.byteLength);     // 20
console.log(floats.length);         // 5
	  	</pre>
			</dd>
		</dl>
		<p>Създадения
			<em>ints</em> <em>array</em> е с място за два елемента. Всяко 16-битово цяло число изисква два байта за стойност, така <em>array</em> е разделен
			на четири байта. Създадения
			<em>floats</em> <em>array</em> е с място за пет елемента, така броят на необходимите байтове е 20 (четири байта на елемент). И в двата
			случая се създава нов буфер и може да бъде достъпен, използвайки
			<em>buffer</em> свойството ако е необходимо.</p>
		<dl>
			<dd>
				<div class="worning">
					<img src="./img/worning.jpg" alt="worning">
				</div>
				<strong>Ако не се подаде никакъв аргумент към конструктора на
					<em>typed array</em>, конструктора действа все едно, че му е подадена 0. Това създава
					<em>typed array</em>, който не може да побере никакви данни, защото 0 байта са разпределени на буфера. </strong>
			</dd>
		</dl>

		<p>Третият начин за създаване на
			<em>typed array</em> е да подадем един обект, като единствен аргумент към конструктора. Обекта може да бъде някой от следните:</p>
		<dl>
			<dd>
				<ul>
					<li>
						<strong>Typed Array </strong>- всеки елемент се копира в нов елемент на нов
						<em>typed array</em>. Например, ако се подаде
						<em>int8</em> на
						<em>Int16Array</em> конструктора, стойностите на
						<em>int8</em> ще бъдат копирани в един
						<em>int16</em> <em>array</em>. Новият
						<em>typed array</em> има различен <em>array buffer</em> от този, който му е подаден.</li>
					<li>
						<strong>Iterable</strong>- итератора на обекта се извиква за да извлече елементите и да ги вмъкне в
						<em>typed array</em>. Конструктора ще хвърли грешка ако някой от елементите е невалиден за
						<em>view</em> типа.</li>
					<li>
						<strong>Array</strong>- елементите на <em>array</em> се копират в нов
						<em>typed array</em>. Конструктора ще хвърли грешка ако някой от елементите е невалиден за типа.</li>
					<li>
						<strong>Array-Like Object (масиво-подобен обект)</strong>- държи се по същия начин, като
						<em>array</em>.</li>
				</ul>
			</dd>
		</dl>
		<p>Във всеки то тези случаи, нов
			<em>typed array</em> се създава с данните от обекта източник. Това може да бъде особено полезно, когато искате да инициализирате
			<em>typed array</em> с някои стойности, като тези:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> ints1 = <span class="code">new</span> Int16Array([25, 50]),
    ints2 = <span class="code">new</span> Int32Array(ints1);

console.log(ints1.buffer === ints2.buffer);     // false

console.log(ints1.byteLength);      // 4
console.log(ints1.length);          // 2
console.log(ints1[0]);              // 25
console.log(ints1[1]);              // 50

console.log(ints2.byteLength);      // 8
console.log(ints2.length);          // 2
console.log(ints2[0]);              // 25
console.log(ints2[1]);              // 50
	  	</pre>
			</dd>
		</dl>
		<p>Този пример създава
			<em>Int16Array</em> и го инициализира с <em>array</em> от две стойности. След това, се създава
			<em>Int32Array</em> и му се подава
			<em>Int16Array</em>. Стойностите 25 и 50 са копирани от
			<em>ints1</em> в
			<em>ints2</em>, като двата
			<em>typed arrays</em> имат съвсем отделни буфери. Същите номера са представени в двата
			<em>typed arrays</em>, но
			<em>ints2</em> има осем байта за представяне на данните, докато
			<em>ints1</em> има само четири.</p>
		<h3>Прилики между Typed arrays и редовни arrays</h3>
		<p>
			<em>Typed arrays</em> и редовни <em>arrays</em> са сходни по няколко начина и както вече видяхте в тази глава,
			<em>typed arrays</em> могат да бъдат използвани, като редовни <em>arrays</em> в много ситуации. Например, можем да проверим, колко
			елемента са в
			<em>typed array</em> използвайки
			<em>length</em> свойство и можем да получим достъп до елементите директно с помощта на цифровите индекси. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> ints = <span class="code">new</span> Int16Array([25, 50]);

console.log(ints.length);          // 2
console.log(ints[0]);              // 25
console.log(ints[1]);              // 50

ints[0] = 1;
ints[1] = 2;

console.log(ints[0]);              // 1
console.log(ints[1]);              // 2
	  	</pre>
			</dd>
		</dl>
		<p>В този код, се създава нов
			<em>Int16Array</em> с два елемента. Елементите се четат и пишат, като се използват техните цифрови индекси и тези стойности
			автоматично се съхраняват и преобразуват в
			<em>int16</em> стойности, като част от операцията. С това приликите не свършват обаче.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>За разлика от редовните <em>array</em>, не можете да променяте размера на
					<em>typed array</em> използвайки
					<em>length</em> свойството.
					<em>Length</em> свойството не е достъпно за записване, така че всеки опит да го промените се игнорира в
					<em>non-strict</em> режим и хвърля грешка в
					<em>strict</em> режим.</strong>
			</dd>
		</dl>
		<h3>Общи методи</h3>
		<p>
			<em>Typed arrays</em> включват голям брой методи, които са функционално еквивалентни на методите за редовни <em>arrays</em>. Можете
			да използвате следните методи на <em>array</em> върху
			<em>typed array</em>:</p>
		<dl>
			<dd>
				<ul>
					<li>
						<strong>copyWithin()</strong> - копира стойностите за <em>array</em> от самия <em>array</em>, започвайки от целата до края на <em>array</em>.</li>
					<li>
						<strong>fill()</strong> - замества всички елементи в <em>array</em> от началния до крайния индекс със статична стойност.</li>
					<li>
						<strong>filter()</strong> - създава нов <em>array</em> с всички елементи, които преминават теста изпълняван от тестващата функция.</li>
					<li>
						<strong>find()</strong> - връща стойността на първия съвпадащ елемент от <em>array</em> отговарящ на тестващата функция.</li>
					<li>
						<strong>findIndex()</strong> - връща индекса на първия съвпадащ елемент от <em>array</em> отговарящ на тестващата функция.</li>
					<li>
						<strong>forEach()</strong> - изпълнява предоставената функция по-веднъж за всеки елемент в <em>array</em>.</li>
					<li>
						<strong>indexOf()</strong> - връща позицията при първата поява на определена стойност в <em>array</em> или -1, ако не е намерена.</li>
					<li>
						<strong>join()</strong> - свързва всички елементи на <em>array</em> в
						<em>string</em> и връща този
						<em>string</em>.</li>
					<li>
						<strong>keys()</strong> - връща нов <em>array</em>
						<em>iterator</em>, който съдържа ключ за всеки индекс на <em>array</em>.</li>
					<li>
						<strong>lastIndexOf()</strong> - връща позицията при последната поява на определена стойност в <em>array</em> или -1, ако не е намерена.</li>
					<li>
						<strong>map()</strong> - създава нов <em>array</em> с резултата от извикването на предоставената функция за всеки елемент в този <em>array</em>.</li>
					<li>
						<strong>reduce()</strong> - прилага акумулираща функция върху всяка стойност в <em>array</em> от ляво на дясно, за да сведе <em>array</em> до
						една единствена стойност.</li>
					<li>
						<strong>reduceRight()</strong> - прилага акумулираща функция върху всяка стойност в <em>array</em> от дясно на ляво, за да сведе <em>array</em>
						до една единствена стойност.</li>
					<li>
						<strong>reverse()</strong> - обръща реда на елементите в <em>array</em>.</li>
					<li>
						<strong>slice()</strong> - връща избраните елементи от <em>array</em> в нов <em>array</em>.</li>
					<li>
						<strong>some()</strong> - тества дали някой елемент в <em>array</em> преминава теста изпълняван от предоставената функция.</li>
					<li>
						<strong>sort()</strong> - сортира елементите на <em>array</em> на място и връща <em>array</em>.</li>
					<li>
						<strong>values()</strong> - връща нов
						<em>Array Iterator</em> обект, който съдържа стойностите за всеки индекс в <em>array</em>.</li>
				</ul>
			</dd>
		</dl>
		<p>Имайте в предвид, че докато всички тези методи действат също, както тези на
			<em>Array.prototype</em>, те не са абсолютно същите. Методите на
			<em>typed arrays</em> имат допълнителни проверки за безопасност на цифровия тип и когато се връща <em>array</em>, ще се върне един
			<em>typed array</em> вместо редовен <em>array</em> (поради
			<em>Symbol.species</em>). Ето един прост пример, който демонстрира разликата:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> ints = <span class="code">new</span> Int16Array([25, 50]),
    mapped = ints.map(v => v * 2);

console.log(mapped.length);        // 2
console.log(mapped[0]);            // 50
console.log(mapped[1]);            // 100

console.log(mapped <span class="code">instanceof</span> Int16Array);  // true
	   	</pre>
			</dd>
		</dl>
		<p>Този пример използва
			<em>map()</em> метод за създаване на нов <em>array</em> базиран на стойности от
			<em>ints</em>. Преобразуващата функция удвоява всяка стойност в <em>array</em> и връща нова в
			<em>Int16Array</em>.</p>
		<h3>Едни и същи итератори</h3>
		<p>
			<em>Typed arrays</em> имат същите три итератора, както редовните <em>array</em>. Това са методите
			<em>entries(), keys()</em> и
			<em>values()</em>. Това означава, че позволяват използването на оператора
			<em>spread</em> и
			<em>for-of</em> цикъл с
			<em>typed arrays</em>, по същия начин, както бихте го направили с редовни <em>arrays</em>. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> ints = <span class="code">new</span> Int16Array([25, 50]),
    intsArray = [...ints];

console.log(intsArray <span class="code">instanceof Array</span>);    // true
console.log(intsArray[0]);                  // 25
console.log(intsArray[1]);                  // 50
			</pre>
			</dd>
		</dl>
		<p>Този код създава нов <em>array</em>
			<em>intsArray</em> съдържащ същите данни, както
			<em>typed array</em>
			<em>ints</em>. Както и при другите
			<em>iterables</em>, оператора
			<em>spread</em> е един лесен начин за превръщане на
			<em>typed arrays</em> в редовни <em>array</em>.</p>
		<h3>of() и from() методи</h3>

		<p>Накрая, всички
			<em>typed arrays</em> имат статичните методи
			<em>of()</em> и
			<em>from()</em>, които работят подобно на
			<em>Array.of()</em> и
			<em>Array.from()</em> методите. Разликата е, че методите за
			<em>typed arrays</em> връщат
			<em>typed array</em> вместо обикновен <em>array</em>. Ето няколко примера, които използват тези методи, за да създадат
			<em>typed array</em>:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> ints = Int16Array.of(25, 50),
    floats = Float32Array.from([1.5, 2.5]);

console.log(ints <span class="code">instanceof</span> Int16Array);        // true
console.log(floats <span class="code">instanceof</span> Float32Array);    // true

console.log(ints.length);       // 2
console.log(ints[0]);           // 25
console.log(ints[1]);           // 50

console.log(floats.length);     // 2
console.log(floats[0]);         // 1.5
console.log(floats[1]);         // 2.5
			</pre>
			</dd>
		</dl>
		<p>Методите
			<em>of()</em> и
			<em>from()</em> в този пример, се използват за създаване на
			<em>Int16Array</em> и
			<em>Float32Array</em>. Тези методи гарантират, че
			<em>typed arrays</em> могат да бъдат създадени също толкова лесно, колкото редовните <em>arrays</em>.</p>
		<h3>Разлики между
			<em>typed arrays</em> и редовни <em>arrays</em> </h3>
		<p>Най-значимата разлика между
			<em>typed arrays</em> и редовни <em>arrays</em> е, че
			<em>typed arrays</em> не са редовни <em>arrays</em>. Това означава, че те не наследяват от
			<em>Array</em> и
			<em>Array.isArray()</em> връща
			<em>false</em>, когато се подаде на
			<em>typed array</em>. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> ints = <span class="code">new</span> Int16Array([25, 50]);

console.log(ints <span class="code">instanceof Array</span>);     // false
console.log(<span class="code">Array</span>.isArray(ints));       // false
			</pre>
			</dd>
		</dl>
		<p>Променливата
			<em>ints</em> е
			<em>typed array</em>, така че не е инстанция на
			<em>Array</em> и не може да се индентифицира, като <em>array</em>. Това разграничение е важно, защото докато
			<em>typed arrays</em> и редовни <em>arrays</em> са сходни, има много начини, по които
			<em>typed arrays</em> се държат по различен начин.</p>
		<h4>Разлики в поведението</h4>
		<p>Докато редовните <em>arrays</em> могат да растат и свиват при взаимодействие с тях,
			<em>typed arrays</em> винаги остават със същия размер. Вие не може да присвоите стойност на несъществуващ цифров индекс в
			<em>typed array</em>, като можем с редовни <em>arrays</em>, тъй като
			<em>typed array</em> игнорира тази операция. Ето един пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> ints = <span class="code">new</span> Int16Array([25, 50]);

console.log(ints.length);          // 2
console.log(ints[0]);              // 25
console.log(ints[1]);              // 50

ints[2] = 5;

console.log(ints.length);          // 2
console.log(ints[2]);              // undefined
			</pre>
			</dd>
		</dl>
		<p>Въпреки присвояването на 5 в цифров индекс 2, в този пример,
			<em>ints</em> не расте изобщо. Дължината остава същата и стойността се изхвърля.</p>
		<p>
			<em>Тyped arrays</em> също имат проверки, за да се гарантира, че се използват само валидни типове данни. Нулата се използва
			на мястото на всички невалидни стойности. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> ints = <span class="code">new</span> Int16Array(["hi"]);

console.log(ints.length);       // 1
console.log(ints[0]);           // 0
			</pre>
			</dd>
		</dl>
		<p>Този код се опитва да използва стойността на
			<em>string</em> "hi" в
			<em>Int16Array</em>. Разбира се,
			<em>strings</em> са невалиден тип данни в
			<em>typed arrays</em>, така че се въвежда нула вместо стойността. Дължината на <em>array</em> остава същата и въпреки, че
			<em>ints[0]</em> съществува, тя просто съдържа 0.</p>
		<p>Същото ограничение се прилага за всички методи, които променят стойности в
			<em>typed array</em>. Например, ако функция се подаде към
			<em>map()</em>, който връща невалидна стойност за
			<em>typed array</em>, се използва нула за отговор:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> ints = <span class="code">new</span> Int16Array([25, 50]),
    mapped = ints.map(v => "hi");

console.log(mapped.length);        // 2
console.log(mapped[0]);            // 0
console.log(mapped[1]);            // 0

console.log(mapped <span class="code">instanceof</span> Int16Array);  // true
console.log(mapped <span class="code">instanceof Array</span>);       // false
			</pre>
			</dd>
		</dl>
		<p>Тъй като,
			<em>string</em> стойността "hi" не е 16-битово цяло число, то се заменя с 0 в резултата на <em>array</em>. Благодарение на това поведение
			за коригиране на грешки в
			<em>typed arrays</em>, не е нужно да се притесняваме за хвърляне на грешка, когато са налице невалидни данни, защото никога
			няма да има невалидни данни в <em>array</em>.</p>
		<h4>Липсващи методи</h4>
		<p>Последната разлика между
			<em>typed arrays</em> и редовни <em>array</em>, е че в
			<em>typed arrays</em> липсват няколко метода, които са на разположение за редовни <em>array</em>. Следните методи не са на разположение
			за
			<em>typed arrays</em>:</p>
		<dl>
			<dd>
				<ul>
					<li>
						<strong>concat()</strong> - обединява два или повече <em>arrays</em>. Този метод не променя съществуващите <em>array</em>, а вместо това връща
						нов <em>array</em>.</li>
					<li>
						<strong>pop()</strong> - премахва последния елемент от <em>array</em> и връща този елемент.</li>
					<li>
						<strong>push()</strong> - добавя един или повече елементи в края на <em>array</em> и връща <em>array</em> с новата дължина.</li>
					<li>
						<strong>shift()</strong> - премахва първият елемент от <em>array</em> и връща този елемент.</li>
					<li>
						<strong>splice()</strong> - променя съдържанието на <em>array</em> чрез премахване на съществуващите или с добавяне на нови елементи.</li>
					<li>
						<strong>unshift()</strong> - добавя един или повече елементи в началото на <em>array</em> и връща <em>array</em> с новата дължина.</li>
				</ul>
			</dd>
		</dl>
		<p>С изключение на
			<em>concat()</em>, другите методи могат да променят размера на <em>array</em>.
			<em>Typed arrays</em> не могат да променят размера си, поради което тези методи не са достъпни за
			<em>typed arrays</em>. Метода
			<em>concat()</em> не е достъпен, тъй като не е ясно за резултата, какво ще конкатенира в два
			<em>typed arrays</em> (особено ако те се занимават с различни типове данни).</p>
		<h3>Допълнителни методи</h3>
		<p>Накрая,
			<em>typed arrays</em> имат два метода, които не присъстват в редовните <em>array</em>:
			<em>set()</em> и
			<em>subarray()</em>. Тези два метода са противоположни,
			<em>set()</em> позволява копиране на друг <em>array</em> в съществуващ
			<em>typed array</em>, докато
			<em>subarray()</em> извлича част от съществуващ
			<em>typed array</em> в нов
			<em>typed array</em>.</p>
		<p>Метода
			<em>set()</em> приема <em>array</em> (било
			<em>typed</em> или редовен) и по избор отместване, с което да въвежда данните, ако не се подаде нищо, отместването по подразбиране
			е нула. Данните от <em>array</em>-аргумент се копират в дестинацията на
			<em>typed array</em>, като същевременно се гарантира, че се използват само валидни типове данни. Ето един пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> ints = <span class="code">new</span> Int16Array(4);

ints.set([25, 50]);
ints.set([75, 100], 2);

console.log(ints.toString());   // 25,50,75,100
	    	</pre>
			</dd>
		</dl>
		<p>Този код създава
			<em>Int16Array</em> с четири елемента. Първото извикване на
			<em>set()</em> копира две стойности за първия и втория елемент в <em>array</em>. Второто извикване на
			<em>set()</em> използва отместване с 2 за да покаже, че стойностите трябва бъдат поставени в <em>array</em>, започвайки от третия
			елемент.</p>
		<p>Метода
			<em>subarray()</em> приема по избор начален и краен индекс (крайния индекс е изключващ, както в
			<em>slice()</em> метода) и връща нов
			<em>typed array</em>. Можете също така да пропуснете двата аргумента, за да създадете клонинг на
			<em>typed array</em>. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> ints = <span class="code">new</span> Int16Array([25, 50, 75, 100]),
    subints1 = ints.subarray(),
    subints2 = ints.subarray(2),
    subints3 = ints.subarray(1, 3);

console.log(subints1.toString());   // 25,50,75,100
console.log(subints2.toString());   // 75,100
console.log(subints3.toString());   // 50,75
	    	</pre>
			</dd>
		</dl>
		<p>Тука са три
			<em>typed arrays</em>, създадени от оригинала
			<em>ints</em> в този пример. <em>Array</em>
			<em>subints1</em> е клонинг на
			<em>ints</em>, който съдържа същата информация. <em>Array</em>
			<em>subints2</em> започва да копира данни от индекс 2 и съдържа само последните два елемента на <em>array</em> (75 и 100). <em>Array</em>
			<em>subints3</em> съдържа елементите в средата на
			<em>ints</em> <em>array</em>, тъй като
			<em>subarray()</em> се извиква с аргументите за начален и краен индекс.</p>
	</article>
	<footer>
		<h3>Обобщение</h3>
		<p>ECMAScript 6 продължава работата на ECMAScript 5, като прави <em>array</em> по-полезни. Има още два нови начина за създаване
			на <em>array</em>, с методите
			<em>Array.of()</em> и
			<em>Array.from()</em>. Метода
			<em>Array.from()</em> може да преобразува
			<em>iterables</em> и масиво-подобни обекти в <em>array</em>. И двата метода са наследени от производен клас <em>array</em> и използват
			<em>Symbol.species</em> свойството за да се определи, какъв тип стойност трябва да върнат (други наследствени методи също
			се използват, когато се връщат <em>array</em>).</p>
		<p>Има и няколко нови метода за <em>array</em>. Методите
			<em>fill()</em> и
			<em>copyWithin()</em> позволяват да променяме елементите на <em>array</em> на място. Методите
			<em>find()</em> и
			<em>findIndex()</em> са полезни за намиране на първия елемент в <em>array</em>, който съвпада с дадени критерии. Първият връща първият
			елемент, който отговаря на критериите, а втория връща индекса, в който е намерен елемента.</p>
		<p>
			<em>Тyped arrays</em> всъщност не са <em>array</em>, тъй като не наследяват от
			<em>Array</em>, но изглеждат и се държат, като <em>array</em>.
			<em>Тyped arrays</em> съдържат един от осемте различни типа цифрови данни и са изградени върху
			<em>ArrayBuffer</em> обекти, които предоставят основните битове за номер или поредица от номера.
			<em>Typed arrays</em> са по-ефективен начин за правене на пробитова аритметика, защото стойностите не се преобразуват напред
			и назад между форматите, както се случва с типовете номера в JavaScript.</p>
	</footer>
	<nav>
		<a href="09_classes.html" title="previous chapter">◀</a>
		<a href="./index.html" title="cover">◆</a>
		<a href="11_promises.html" title="next chapter">▶</a>
	</nav>
</body>

</html>