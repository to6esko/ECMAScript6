<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Strings :: Understanding ECMAScript 6</title>
	<link rel="stylesheet" href="font.css">
</head>

<body>
	<nav>
		<a href="./01_block.html" title="previous chapter">◀</a>
		<a href="./index.html" title="cover">◆</a>
		<a href="./03_function.html" title="next chapter">▶</a>
	</nav>

	<header>
		<h1>
			<div class="head-num">Глава 2</div>Strings и Регулярни изрази</h1>
		<p>
			<em>Strings</em> е може би един от най-важните типове данни в програмирането. Те са в почти всеки език за програмиране от
			по-високо ниво, който е в състояние да работи с тях ефективно и са от основно значение за програмистите да създават полезни
			програми. Чрез разширяване, регулярните изрази са важни, защото дават допълнителна мощност на програмистите, която да
			упражнят върху
			<em>strings</em>. С тези факти в ума, създателите на ECMAScript 6 подобряват
			<em>strings</em> и регулярните изрази, чрез добавяне на нови възможности и дълго липсваща функционалност. Тази глава обхваща
			тези два вида промени.</p>
	</header>
	<article>
		<h3>По-добра Unicode поддръжка</h3>
		<p>Преди ECMAScript 6 в JavaScript,
			<em>strings</em> се въртят около 16-битово
			<em>character</em> (характер) кодиране (UTF-16). Всяка 16-битова последователност е кодови единици(
			<em>code unit</em>) представляващи характер. Всички
			<em>string</em> свойства и методи, като
			<em>length</em> свойство и
			<em>charAt()</em> метод, се основават на тези 16-битови кодови единици. Разбира се, 16-бита се използват за да бъдат достатъчни
			да съдържат всеки характер. Това вече не е вярно благодарение на разширения набор от характери въведени с Unicode.</p>
		<h3>UTF-16 кодови точки</h3>
		<p>Ограничаване дължината на характера до 16 бита не е възможно, заявиха от Unicode с цел на осигуряване на глобален уникален
			идентификатор за всеки характер в света. Тези глобални уникални идентификатори, наречени
			<em>code points</em>, са просто номера започващи от 0. Можете да мислите за кодовите точки, като характер кодове, където всеки
			номер представлява характер. Кодирането на характерите превежда кодовите точки в кодови единици, които са вътрешно последователни.
			За UTF-16, кодовите точки могат да бъдат съставени от много кодови единици.</p>
		<p>Първите 2
			<sup>16</sup> кодови точки в UTF-16 са представени, като единични 16-битови кодови единици. Този диапазон се нарича Basic Multilingual
			Plane (BMP). Всичко след това се счита за допълнителни нива, където кодовите точки не могат да бъдат представени с 16-бита.
			UTF-16 решава този проблем чрез въвеждане на сурогатни двойки, при които една кодова точка е представена от две 16-битови
			кодови единици. Това означава, че всеки един характер в
			<em>string</em> може да бъде или една кодова единица за BMP характер, което прави общо 16 бита, или две единици за допълнително
			ниво, което прави общо 32 бита.</p>
		<p>В ECMAScript 5, всички
			<em>string</em> операции работят с 16-битови кодови единици, което означава, че може да получите неочаквани резултати от UTF-16
			кодирани
			<em>strings</em> съдържащи сурогатни двойки, като в този пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> text = "𠮷";

console.log(text.length);           // 2
console.log(/^.$/.test(text));      // false

console.log(text.charAt(0));        // ""
console.log(text.charAt(1));        // ""

console.log(text.charCodeAt(0));    // 55362
console.log(text.charCodeAt(1));    // 57271			
			</pre>
			</dd>
		</dl>
		<p>Единичния Unicode характер "𠮷" е представен с помощта на сурогатна двойка и като такава JavaScript
			<em>string</em> операциите я третират, като два 16-битови характера. Това означава:</p>
		<dl>
			<dd>
				<ul>
					<li>Дължината на текста е 2, а трябва да бъде 1.</li>
					<li>Регулярния израз се опитва да съответства на един характер, но не успява защото си мисли, че има два характера.</li>
					<li>Метода
						<em>charAt()</em> не е в състояние да върне влиден характер, защото набора от 16 бита не съответства на печатния характер.</li>
				</ul>
			</dd>
		</dl>
		<p>Метода
			<em>charCodeAt()</em> не може просто да определи характера правилно. Той връща съответния 16-битов номер за всяка кодова единица,
			но това е най-близко, което може да получите за реалната стойност на
			<em>text</em> в ECMAScript 5.</p>
		<p>ECMAScript 6, от друга страна, налага UTF-16
			<em>string</em> кодиране за справяне с подобни проблеми. Стандартизиране на
			<em>string</em> операциите основаващи се на такова кодиране на характерите в JavaScript, може да поддържа функционалност проектирана
			да работи специално със сурогатни двойки. В останалата част от този раздел се разглеждат няколко ключови примера на тази
			функционалност.</p>
		<h3>Метода codePointAt()</h3>
		<p>Един метод в ECMAScript 6, който добавя изцяло подкрепа за UTF-16 е
			<em>codePointAt()</em> метода, който извлича Unicode кодова точка от
			<em>maps</em> за дадена позиция в
			<em>string</em>. Този метод приема позицията на код единица, а не позицията на характера и връща цялочислена стойност, както
			оператора
			<em>console.log()</em> показва в примера:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> text = "𠮷a";

console.log(text.charCodeAt(0));    // 55362
console.log(text.charCodeAt(1));    // 57271
console.log(text.charCodeAt(2));    // 97

console.log(text.codePointAt(0));   // 134071
console.log(text.codePointAt(1));   // 57271
console.log(text.codePointAt(2));   // 97
			</pre>
			</dd>
		</dl>
		<p>Метода
			<em>codePointAt()</em> връща същата стойност, като
			<em>charCodeAt()</em> метода, освен ако ако не оперира с
			<em>non-BMP</em> характери. Първият характер в
			<em>text</em> е
			<em>non-BMP</em> и следователно се състои от две кодови единици, което означава, че
			<em>length</em> свойството е 3, а не 2. Методът
			<em>charCodeAt()</em> връща само първата кодова единица за позиция 0, но
			<em>codePointAt()</em> връща пълната кодова точка, въпреки че точката на кода обхваща няколко кодови единици. И двата метода
			връщат една и съща стойност за позиция 1 (втората кодова единица на първия характер) и 2 (на "a" характера).</p>
		<p>Извикване на метода
			<em>codePointAt()</em> е най-лесният начин да се определи дали този характер е представен от една или две кодови точки. Ето
			една функция, която може да напишете за да провери това:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> is32Bit(c) {  
    <span class="code">return</span> c.codePointAt(0) > 0xFFFF;
}
console.log(is32Bit("𠮷"));         // true
console.log(is32Bit("a"));          // false				
			</pre>
			</dd>
		</dl>
		<p>Горната граница за 16-битови характерите е представена в шестнадесетичен вариант, като FFFF, така че всяка код точка над
			този брой трябва да бъде представен от две кодови единици, като общо произведение от 32 бита.</p>
		<h3>Метода String.fromCodePoint()</h3>
		<p>Когато ECMAScript осигурява начин за правене на нещо, той също има тенденцията да осигури начин за правене на обратното
			нещо. Използването на
			<em>codePointAt()</em>, извлича кодовата точка на характер в
			<em>string</em>, докато
			<em>String.fromCodePoint()</em> произвежда единичен характер от дадена кодова точка. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
console.log(<span class="code">String</span>.fromCodePoint(134071));  // "𠮷"				
			</pre>
			</dd>
		</dl>
		<p>Мислете за
			<em>String.fromCodePoint()</em>, като по-пълна версия на
			<em>String.fromCharCode()</em> метода. И двата дават един и същи резултат за характерите на BMP. Има само една разлика, когато
			премине кодовите точки за характерите извън BMP.</p>
		<h3>Метода normalize()</h3>
		<p>Друг интересен аспект от Unicode е, че различните характери могат да се считат за еквивалентни за целите на сортиране или
			други операции за сравняване. Има два начина да се определят тези отношения. Първия е,
			<em>канонична еквивалентност</em>, което означава две последователности от кодови точки се считат за взаимозаменяеми във всяко
			отношение. Така например, комбинация от два характера може да бъде канонично еквивалентна на един характер. Вторият е
			<em>съвместимост</em>. Две съвместими последователности от кодови точки изглеждат по различен начин, но могат да се използват
			взаимозаменяеми в определени ситуации.</p>
		<p>Благодарение на тези взаимоотношения, два
			<em>strings</em>, представляващи основно същия текст може да съдържат различни последователности от кодови точки. Например,
			характера “æ” и двойния характер
			<em>string “ae”</em> може да се използват, като взаимозаменяеми, но те не са еквивалентни ако се нормализират по някакъв начин.</p>
		<p>ECMAScript 6 поддържа Unicode форми за нормализация на даден
			<em>string</em>, като метода
			<em>normalize()</em>. Този метод евентуално приема един единствен
			<em>string</em> параметър, посочвайки Unicode формите за нормализация, които да приложи:</p>
		<dl>
			<dd>
				<ul>
					<li>Normalization Form Canonical Composition ("NFC"), който е по подразбиране</li>
					<li>Normalization Form Canonical Decomposition ("NFD")</li>
					<li>Normalization Form Compatibility Composition ("NFKC")</li>
					<li>Normalization Form Compatibility Decomposition ("NFKD")</li>
				</ul>
			</dd>
		</dl>
		<p>Извън обхвата на тази книга е да се обясни разликата между тези четири форми. Само имайте в предвид, че при сравняване
			на
			<em>strings</em>, двата
			<em>strings</em> трябва да бъдат нормализирани към една и съща форма. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> normalized = values.map(<span class="code">function</span>(text) {
    <span class="code">return</span> text.normalize();
});
normalized.sort(<span class="code">function</span>(first, second) { 
    <span class="code">if</span> (first < second) {
        <span class="code">return</span> -1;
    } else if (first === second) {
        <span class="code">return</span> 0;
    } else {
        <span class="code">return</span> 1;
    }
});	
			</pre>
			</dd>
		</dl>
		<p>Този код превръща
			<em>strings</em> във
			<em>values</em> <em>array</em> в нормализирана форма, така че <em>array</em> да бъде подреден по подходящ начин. Може също да се сортира оригиналния
			<em>array</em>, като се извика
			<em>normalize()</em>, като част от сравнението, както следва:</p>
		<dl>
			<dd>
				<pre class="highlight">
values.sort(<span class="code">function</span>(first, second) {
    <span class="code">var</span> firstNormalized = first.normalize(),  
        secondNormalized = second.normalize();
    <span class="code">if</span> (firstNormalized < secondNormalized) {   
        <span class="code">return</span> -1;
    } else if (firstNormalized === secondNormalized) {
        <span class="code">return</span> 0;
    } else {  
        <span class="code">return</span> 1;
    }
});		
			</pre>
			</dd>
		</dl>
		<p>За последно, най-важното нещо, което трябва да се отбележи за този код е, че и двата и първия и втория са нормализирани
			по един и същи начин. Тези примери са използвани по подразбиране, NFC, но може лесно да се уточни един от останалите,
			като този:</p>
		<dl>
			<dd>
				<pre class="highlight">
values.sort(<span class="code">function</span>(first, second) {
    <span class="code">var</span> firstNormalized = first.normalize("NFD"), 
        secondNormalized = second.normalize("NFD");
    <span class="code">if</span> (firstNormalized < secondNormalized) {  
        <span class="code">return</span> -1;
    } else if (firstNormalized === secondNormalized) {
        <span class="code">return</span> 0;
    } else {
        <span class="code">return</span> 1;
    }
});		
			</pre>
			</dd>
		</dl>
		<p>Ако никога не сте се притеснявали за Unicode нормализацията преди, тогава няма да има голяма полза от този метод сега.
			Но ако някога работите върху интернационално заявление, то със сигурност метода
			<em>normalize()</em> ще ви бъде полезен.</p>
		<p>Методите не са единствените подобрения, които ECMAScript 6 предвижда за работа с Unicode
			<em>strings</em>. Стандарта също така добавя и два полезни синтактични елемента.</p>
		<h3>Регулярен израз и u Flag</h3>
		<p>Може да постигнете много
			<em>string</em> операции използвайки регулярни изрази. Но не забравяйте, че регулярните изрази приемат 16-битов код, където
			всеки от тях е един характер. За да се справи с този проблем, ECMAScript 6 дефинира
			<em>u flag</em> за регулярни изрази, което е съкращение на Unicode.</p>
		<h4>u Flag в действие</h4>
		<p>Когато регулярен израз има
			<em>u flag set</em>, той превключва режима на работа на характерите, а не на кодовите единици. Това означава, че регулярния
			израз вече не трябва да се бърка от сурогатните двойки в
			<em>strings</em> и трябва да се държи, както се очаква. Например да разгледаме този код:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> text = "𠮷";
console.log(text.length);           // 2
console.log(/^.$/.test(text));      // false
console.log(/^.$/u.test(text));     // true			
				</pre>
			</dd>
		</dl>
		<p>Регулярния израз /^.$/ съвпада с всеки входящ
			<em>string</em> с един характер. Когато се използва без
			<em>u flag</em>, този регулярен израз съвпада с кодовите единици и така Японския характер (който е представен от две кодови
			единици) не съответства на регулярния израз. Когато се използва
			<em>u flag</em>, регулярния израз сравнява характери вместо кодови единици и така Японския характер съвпада.</p>
		<h4>Преброяване на кодови точки</h4>
		<p>За съжаление, ECMAScript 6 не може да определи, колко кодови точки съдържа един
			<em>string</em>, но може да използвате
			<em>u flag</em> с регулярен израз за да разберете това:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> codePointLength(text) {  
    <span class="code">var</span> result = text.match(/[\s\S]/gu);
    <span class="code">return</span> result ? result.length : 0;
}
console.log(codePointLength("abc"));    // 3
console.log(codePointLength("𠮷bc"));   // 3			
				</pre>
			</dd>
		</dl>
		<p>Този пример извиква
			<em>match()</em> да провери
			<em>text</em> за харатери на празни и не празни пространства (използвайки [\s\S] за да гарантира, че моделът съвпада с новите
			редове) с помощта на регулярен израз, който се прилага глобално с Unicode подръжка.
			<em>result</em> съдържа <em>array</em> от съвпадения, дори да има най-малко едно съвпадение, така че дължината на <em>array</em> е броя на
			кодовите точки в
			<em>string</em>. В Unicode, и двата
			<em>strings "abc"</em> и
			<em>"𠮷bc"</em> имат три характера, така че дължината на <em>array</em> е три.</p>
		<dl>
			<dd>
				<div class="worning">
					<img src="./img/worning.jpg" alt="worning">
				</div>
				<strong>Въпреки, че този подход работи, той не е много бърз, особено ако се прилага за дълги
					<em>strings</em>. Може да използвате
					<em>string</em> итератор (обсъден в
					<a href="08_iterators_and_generators.html">Глава 8</a>). Като цяло се опитайте да сведете до минимум броенето на кодови точки, когато е възможно.</strong>
			</dd>
		</dl>
		<h4>Определяне на поддръжка за u Flag</h4>
		<p>Тъй като
			<em>u flag</em> е промяна на синтаксиса, опитите да се използва в JavaScript машини, които не са съвместими с ECMAScript 6
			хвърля синтактична грешка. Най-сигурният начин да се определи дали
			<em>u flag</em> се поддържа е да се подкрепи с функция като тази:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> hasRegExpU(){  
    <span class="code">try</span> {
        <span class="code">var</span> pattern = <span class="code">new RegExp</span> (".", "u");
        <span class="code">return true</span>;
    }<span class="code">catch</span> (ex) {
        <span class="code">return false</span>;
    }
}	
				</pre>
			</dd>
		</dl>
		<p>Тази функция използва
			<em>RegExp</em> конструктор за да приеме
			<em>u flag</em>, като аргумент. Този синтаксис е валиден дори в по-стари машини на JavaScript и конструктора ще хвърли грешка
			ако
			<em>u</em> не се поддържа.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Ако вашия код все пак трябва да работи в по-стари машини на JavaScript, винаги използвайте
					<em>RegExp</em> конструктора при използването на
					<em>u flag</em>. Това ще попречи на синтактичните грешки и ще ви позволи оптимално използване на
					<em>u flag</em> без да абортирате изпълнението.</strong>
			</dd>
		</dl>
		<h3>Други string промени</h3>
		<p>JavaScript
			<em>strings</em> винаги са изоставали спрямо сходни характеристики на други езици. Това беше само до ECMAScript 5, където
			тези
			<em>strings</em> най-накрая получиха
			<em>trim()</em> метод и ECMAScript 6 продължава разширяването на капацитета на JavaScript да прави разбор на
			<em>strings</em> с нова функционалност.</p>
		<h3>Методи за идентифициране на Substrings</h3>
		<p>Програмистите в JavaScript използват
			<em>indexOf()</em> метода, за да определят какви
			<em>strings</em> има в други
			<em>strings</em>. ECMAScript 6 въвежда следните три метода, които са предназначени да правят това:</p>
		<dl>
			<dd>
				<ul>
					<li>Метода
						<em>includes()</em> - връща истина, ако даден текст е намерен някъде в рамките на
						<em>string</em>. И връща
						<em>false</em>, ако не е намерен.</li>
					<li>Метода
						<em>startsWith()</em> - връща истина, ако даден текст е намерен в началото на
						<em>string</em>. И връща
						<em>false</em> ако не е намерен.</li>
					<li>Метода
						<em>endsWith()</em> - връща истина, ако даден текст е намерен в края на
						<em>string</em>. И връща
						<em>false</em>, ако не е намерен.</dd>
			</li>
			</ul>
		</dl>
		<p>Тези методи приемат два аргумента: текст за търсене и не задължителен индекс от къде да започне търсенето. Когато се предостави
			втори аргумент,
			<em>includes()</em> и
			<em>startsWith()</em> започват съвпадението от този индекс, докато
			<em>endsWith()</em> започва съвпадението от дължината на
			<em>string</em> минус втория аргумент; когато втория аргумент е пропуснат,
			<em>includes()</em> и
			<em>startsWith()</em> търсят в началото на
			<em>string</em>, а
			<em>endsWith()</em> започва от края. Смисъла е, че втория аргумент намалява размера на
			<em>string</em> при търсене. Ето няколко примера, които показват тези три метода в действие:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> msg = "Hello world!";

console.log(msg.startsWith("Hello"));       // true
console.log(msg.endsWith("!"));             // true
console.log(msg.includes("o"));             // true

console.log(msg.startsWith("o"));           // false
console.log(msg.endsWith("world!"));        // true
console.log(msg.includes("x"));             // false

console.log(msg.startsWith("o", 4));        // true
console.log(msg.endsWith("o", 8));          // true
console.log(msg.includes("o", 8));          // false
				
			</pre>
			</dd>
		</dl>
		<p>Първите три извиквания не включват втори параметър, така че те ще търсят в целия
			<em>string</em>, ако е необходимо. Последните три извиквания проверяват само част от
			<em>string</em>. Извикването на
			<em>msg.startsWith("o", 4)</em> започва съвпадението от индекс 4 на
			<em>msg string</em>, който е “o” в “Hello”. Извикването на
			<em>msg.endsWith("o", 8)</em> започва съвпадението от индекс 4, тъй като 8 се изважда от дължината на
			<em>string</em> (12). Извикването на
			<em>msg.includes("o", 8)</em> започва съвпадението от индекс 8, който е “r” в “world”.</p>
		<dl>
			<dd>
				<div class="worning">
					<img src="./img/worning.jpg" alt="worning">
				</div>
				<strong>Методите
					<em>startsWith(), endsWith()</em> и
					<em>includes()</em> хвърлят грешка, ако им се подаде регулярен израз вместо
					<em>string</em>. Това контрастира с
					<em>indexOf()</em> и
					<em>lastIndexOf()</em>, които едновременно превръщат регулярен израз в аргумент на
					<em>string</em> и след това търсят този
					<em>string</em>.</strong>
			</dd>
		</dl>
		<h3>Метода repeat()</h3>
		<p>ECMAScript 6 също добавя метода
			<em>repeat()</em> за
			<em>strings</em>, който приема повторението на
			<em>string</em>, като аргумент. Той връща нов
			<em>string</em>, съдържащ оригиналния
			<em>string</em> повторен определен брой пъти. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
console.log("x".repeat(3));         // "xxx"
console.log("hello".repeat(2));     // "hellohello"
console.log("abc".repeat(4));       // "abcabcabcabc"
			</pre>
			</dd>
		</dl>
		<p>Този метод е удобна функция, която може да бъде полезна при манипулиране на текст. Това е особено полезно в кодово форматиране
			на
			<em>utilities</em>, които трябва да създадат нива за отстояние, като тези:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="comment"><em>// indent използва определен брой места</em></span>
<span class="code">var</span> indent = " ".repeat(4),   
    indentLevel = 0;
<span class="comment"><em>// когато се увеличи indent</em></span>
<span class="code">var</span> newIndent = indent.repeat(++indentLevel);	
			</pre>
			</dd>
		</dl>
		<p>Първия
			<em>repeat()</em> създава
			<em>string</em> от четири позиции, а
			<em>indentLevel</em> държи променливата на нивата. След това може просто да се извика
			<em>repeat()</em> с нарастващ
			<em>indentLevel</em> за промяна на броя на местата.</p>
		<p>ECMAScript 6 също прави някои промени за функционалността на регулярните изрази, които не се вписват в определена категория.
			Следващия раздел подчертава няколко.</p>
		<h3>Други промени на регулярните изрази</h3>
		<p>Регулярните изрази са важна част от работата със
			<em>strings</em> в JavaScript, подобно на много части от езика, те не са се променили много през последните версии. ECMAScript
			6, обаче, прави няколко подобрения заедно с актуализациите на
			<em>strings</em>.</p>
		<h3>Регулярни изрази с y Flag</h3>
		<p>ECMAScript 6 стандартизира
			<em>y flag</em> след, като бе въведен във Firefox, като разширение на свойство за регулярни изрази. Ефекта на
			<em>y flag</em> в регулярния израз е да търси
			<em>sticky</em> свойство и казва на търсачката да започне съвпадение на знаци в
			<em>string</em> от позиция посочена от регулярния израз на
			<em>lastIndex</em> свойството. Ако няма съвпадение на това място, регулярния израз спира търсенето. За да видите, как работи,
			нека изследваме следния код:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> text = "hello1 hello2 hello3",
    pattern = /hello\d\s?/,
    result = pattern.exec(text),
    globalPattern = /hello\d\s?/g,
    globalResult = globalPattern.exec(text),
    stickyPattern = /hello\d\s?/y,
    stickyResult = stickyPattern.exec(text);

console.log(result[0]);         // "hello1 "
console.log(globalResult[0]);   // "hello1 "
console.log(stickyResult[0]);   // "hello1 "

pattern.lastIndex = 1;
globalPattern.lastIndex = 1;
stickyPattern.lastIndex = 1;
result = pattern.exec(text);
globalResult = globalPattern.exec(text);
stickyResult = stickyPattern.exec(text);

console.log(result[0]);         // "hello1 "
console.log(globalResult[0]);   // "hello2 "
console.log(stickyResult[0]);   // Error! stickyResult is null
			</pre>
			</dd>
		</dl>
		<p>Този пример има три регулярни израза. Израза в
			<em>pattern</em> няма
			<em>flags</em>, този в
			<em>globalPattern</em> използва
			<em>g flag</em>, а този в
			<em>stickyPattern</em> използва
			<em>y flag</em>. Първата тройка на
			<em>console.log()</em> извиква трите регулярни израза, които трябва да върнат "hello1 " с интервал на края.</p>
		<p>След това,
			<em>lastIndex</em> свойството се променя на 1 и на трите модела, което означава, че регулярният израз започва да търси съвпадения
			от втория характер. Регулярният израз без
			<em>flags</em> напълно игнорира промяната на
			<em>lastIndex</em> и ще търси съвпадения на "hello1 " без инциденти. Регулярния израза със
			<em>g flag</em> търси съвпадения на "hello2 " защото търси напред след втория характер на
			<em>string</em>, който е ("e"). Регулярния израз
			<em>sticky</em> не съвпада с нищо, започвайки от втория характер, така че
			<em>stickyResult</em> е
			<em>null</em>.</p>
		<p>
			<em>sticky flag</em> запазва индекса на следващия характер след последното съвпадение в
			<em>lastIndex</em> всеки път, когато се извършва операция. Ако резултатите от операцията нямат съвпадение,
			<em>lastIndex</em> ще върне 0.
			<em>global flag</em> се държи по същия начин, както е показано тук:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> text = "hello1 hello2 hello3",    
    pattern = /hello\d\s?/,
    result = pattern.exec(text),
    globalPattern = /hello\d\s?/g,
    globalResult = globalPattern.exec(text),
    stickyPattern = /hello\d\s?/y,
    stickyResult = stickyPattern.exec(text);

console.log(result[0]);         // "hello1 "
console.log(globalResult[0]);   // "hello1 "
console.log(stickyResult[0]);   // "hello1 "

console.log(pattern.lastIndex);         // 0
console.log(globalPattern.lastIndex);   // 7
console.log(stickyPattern.lastIndex);   // 7

result = pattern.exec(text);
globalResult = globalPattern.exec(text);
stickyResult = stickyPattern.exec(text);

console.log(result[0]);         // "hello1 "
console.log(globalResult[0]);   // "hello2 "
console.log(stickyResult[0]);   // "hello2 "

console.log(pattern.lastIndex);         // 0
console.log(globalPattern.lastIndex);   // 14
console.log(stickyPattern.lastIndex);   // 14
				
			</pre>
			</dd>
		</dl>
		<p>Стойността на
			<em>lastIndex</em> се променя на 7 след първото извикване на
			<em>exec()</em> и на 14 след второто извикване, за променливите
			<em>stickyPattern</em> и
			<em>globalPattern</em>.</p>
		<p>Има два по-фини детайла за
			<em>sticky flag</em>, които трябва да запомним:</p>
		<dl>
			<dd>
				<ol>
					<li>Свойството
						<em>lastIndex</em> се зачита, само след извикване на методи, които съществуват в обекта на регулярните изрази, като
						<em>exec()</em> и
						<em>test()</em> методите. Подаване на регулярен израз към
						<em>string</em> методи, като
						<em>match()</em>, няма да доведе до
						<em>sticky</em> поведение.</li>
					<li>При използване на ^ характер за съвпадение с начало на
						<em>string</em>, регулярните изрази
						<em>sticky</em> съответстват само с началото на
						<em>string</em> (или от началото на линията за многоредов модел). Докато
						<em>lastIndex</em> е 0, ^ прави регулярния израз
						<em>sticky</em> да не се различава от
						<em>non-sticky</em>. Ако
						<em>lastIndex</em> не съответства на началото на единичен
						<em>string</em> или на началото на линията на многоредов модел, регулярния израз
						<em>sticky</em> никога няма да съвпадне.</li>
				</ol>
			</dd>
		</dl>
		<p>Както и при другите
			<em>flags</em> на регулярните изрази, може да се открие съвпадение с
			<em>y</em>, с използването на свойства. В този случай, ще се провери за
			<em>sticky</em> свойството, както следва:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> pattern = /hello\d/y;
 console.log(pattern.sticky);    // true		
			</pre>
			</dd>
		</dl>
		<p>Свойството
			<em>sticky</em> е вярно, ако присъства
			<em>sticky flag</em> и свойството е
			<em>false</em> ако го няма. Свойството
			<em>sticky</em> се отчита въз основа на присъствието на
			<em>flag</em> и не може да се промени в кода.</p>
		<p>Подобно на
			<em>u flag</em>,
			<em>y flag</em> е промяна в синтаксиса, така че това ще предизвика синтактична грешка при по-стари машини на JavaScript. Можете
			да използвате следния код за откриване на поддръжка:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> hasRegExpY() {   
    <span class="code">try</span> {  
        <span class="code">var</span> pattern = <span class="code">new RegExp</span>(".", "y");
        <span class="code">return true</span>;
    } catch (ex) {
        <span class="code">return false</span>;
    }
}		
			</pre>
			</dd>
		</dl>
		<p>Точно, както в
			<em>u</em> проверката, този израз връща
			<em>false</em> ако не е в състояние да създаде регулярен израз с
			<em>y flag</em>. В едно последно сходство със u, ако трябва да се използва
			<em>y</em> в кода на по-стари JavaScript машини, не забравяйте да използвате
			<em>RegExp</em> конструктора при дефинирането на регулярни изрази, за да се избегне синтактична грешка.</p>
		<h3>Копиране на регулярни изрази</h3>
		<p>В ECMAScript 5, може да се копират регулярни изрази, чрез подаването им в
			<em>RegExp</em> конструктора, като това:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> re1 = /ab/i,
    re2 = <span class="code">new RegExp</span>(re1);	
			</pre>
			</dd>
		</dl>
		<p>Променливата
			<em>re2</em> е просто копие на променливата
			<em>re1</em>. Но ако се предостави втори аргумент на
			<em>RegExp</em> конструктора, който определя
			<em>flags</em> за регулярния израз, този код няма да работи, както в този пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> re1 = /ab/i,   
    <span class="comment"><em>// хвърля грешка в ES5, но е наред в ES6</em></span>
    re2 = <span class="code">new RegExp</span>(re1, "g");	
			</pre>
			</dd>
		</dl>
		<p>Ако се изпълни този код в средата на ECMAScript 5, ще получите съобщение за грешка, че вторият аргумент не може да се използва,
			когато първият аргумент е регулярен израз. ECMAScript 6 променя това поведение, като разрешава втори аргумент и той има
			предимство пред всички
			<em>flags</em>, които присъстват в първия аргумент. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> re1 = /ab/i,
     <span class="comment"><em>// хвърля грешка в ES5, но е наред в ES6</em></span>
    re2 = <span class="code">new RegExp</span>(re1, "g");

console.log(re1.toString());            // "/ab/i"
console.log(re2.toString());            // "/ab/g"

console.log(re1.test("ab"));            // true
console.log(re2.test("ab"));            // true

console.log(re1.test("AB"));            // true
console.log(re2.test("AB"));            // false			
			</pre>
			</dd>
		</dl>
		<p>В този код,
			<em>re1</em> съдържа
			<em>i flag</em>, докато
			<em>re2</em> има само глобален
			<em>g flag</em>. Конструктора
			<em>RegExp</em> копира модела от
			<em>re1</em> и замества
			<em>i flag</em> със
			<em>g flag</em>. Без втория аргумент,
			<em>re2</em> ще има същия
			<em>flags</em>, като
			<em>re1</em>.</p>
		<h3>Свойството flags</h3>
		<p>Заедно с добавянето на нов
			<em>flag</em> и промяната на начина, по който може да се работи с
			<em>flags</em>, ECMAScript 6 добавя свойство свързано с тях. В ECMAScript 5, бихме могли да получим текста на регулярен израз,
			чрез използване на
			<em>source</em> свойство, за да получим
			<em>flag string</em>, ще трябва да се направи разбор на изхода на
			<em>toString()</em> метода, както е показано по долу:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> getFlags(re) { 
    <span class="code">var</span> text = re.toString();
    <span class="code">return</span> text.substring(
        text.lastIndexOf("/") + 1, text.length);
}

// toString() is "/ab/g"
<span class="code">var</span> re = /ab/g;
console.log(getFlags(re));          // "g"
			</pre>
			</dd>
		</dl>
		<p>Това превръща регулярния израз в
			<em>string</em> и след това се връща за да намери последния характер след /. Този характер е
			<em>flags</em>.</p>
		<p>ECMAScript 6 прави извличането на
			<em>flags</em> по-лесно, чрез добавяне на
			<em>flags</em> свойство към
			<em>source</em> свойството. И двете свойства имат прототип
			<em>accessor</em> свойство, което ги прави само за четене. Свойството
			<em>flags</em> прави проверката на регулярни изрази по-лесна за отстраняване на грешки и наследени цели.</p>
		<p>Едно закъсняло допълнение към ECMAScript 6, за
			<em>flags</em> свойството е връщането на
			<em>string</em> представяне на всякакви
			<em>flags</em>, приложени към регулярния израз. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> re = /ab/g;
console.log(re.source);     // "ab"
console.log(re.flags);      // "g"
			</pre>
			</dd>
		</dl>
		<p>Това извлича всички
			<em>flags</em> на
			<em>re</em> и ги отпечатва на конзолата с далеч по-малко редове код, от колкото
			<em>toString()</em> техниката може. Използването на
			<em>source</em> и
			<em>flags</em> заедно ни позволява да извлечем парчета от регулярния израз, от които имаме нужда без директен разбор на израза
			в
			<em>string</em>.</p>
		<p>Промените на
			<em>strings</em> и регулярните изрази обхванати в тази глава определено са мощни, но ECMAScript 6 увеличава силата си върху
			<em>strings</em> по много по-голям начин. Тя въвежда
			<em>template literals</em> при правенето на
			<em>strings</em>, което ги прави по-гъвкави.</p>
		<h3>Template Literals</h3>
		<p>
			<em>Strings</em> в JavaScript винаги са имали ограничена функционалност в сравнение със
			<em>strings</em> в другите езици. Така например, до ECMAScript 6 за
			<em>strings</em> липсваха методите обхванати в тази глава и съединяването на
			<em>string</em> беше токова просто, колкото е възможно. За да даде възможност на програмистите да решават по-сложни проблеми,
			<em>template literals</em> на ECMAScript 6 предоставят синтаксис за създаване на домейн-специфични езици (DSLs) за по-сигурен
			начин на работа със съдържанието, от наличните по-ранни решения в ECMAScript 5. (DSL е програмен език, предназначен за
			конкретна цел, за разлика от езици с общо предназначение, като JavaScript). В уикипедия ECMAScript предлага следното описание
			на
			<a href="http://wiki.ecmascript.org/doku.php?id=harmony:quasis">template literal strawman</a>:</p>
		<dl>
			<dd style="color: cornflowerblue">Тази схема разширява синтаксиса на ECMAScript със
				<em>syntactic sugar</em> за да даде възможност на библиотеките да предоставят на DSLs възможност, лесно да произвежда заявки
				и манипулира съдържанието от други езици, които са имунизирани или устойчиви на атаките на XSS, SQL Injection и т.н.</dd>
		</dl>
		<p>В действителност, обаче,
			<em>template literals</em> са отговор на ECMAScript 6 за следните признаци, които липсваха на JavaScript през целия път в
			ECMAScript 5:</p>
		<dl>
			<dd>
				<ul>
					<li>
						<strong>Multiline strings</strong> - официална концепция за многоредови
						<em>strings</em>.</li>
					<li>
						<strong>Basic string formatting</strong> -способност да се замени част от
						<em>string</em> със стойности, които се съдържат в променливи.</li>
					<li>
						<strong>HTML escaping</strong> - способност да се трансформира
						<em>string</em>, така че безопасно да се вмъкне в HTML.</li>
				</ul>
			</dd>
		</dl>
		<p>Вместо да се опитват да добавят повече функционалност към вече съществуващата за
			<em>strings</em> в JavaScript,
			<em>template literals</em> представляват един изцяло нов подход към решаването на тези проблеми.</p>
		<h3>Basic Syntax</h3>
		<p>Простите,
			<em>template literals</em> действат, като редовни
			<em>strings</em> оградени от
			<em>backticks (`)</em> (апостроф) вместо с двойни или единични кавички. Например, помислете за следното:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> message = `Hello world!`;
console.log(message);               // "Hello world!"
console.log(<span class="code">typeof</span> message);        // "string"
console.log(message.length);        // 12
			</pre>
			</dd>
		</dl>
		<p>Този код показва, че променливата
			<em>message</em> съдържа нормален JavaScript
			<em>string</em>. Синтаксиса на
			<em>template literal</em> се използва за създаване на
			<em>string</em> стойност, която след това се възлага на
			<em>message</em> променливата.</p>
		<p>Ако искате да използвате апостроф в
			<em>string</em>, трябва да (избягате)
			<em>escape</em> с обратно наклонена черта (\), както в този вариант на
			<em>message</em> променливата:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> message = `\`Hello\` world!`;
console.log(message);               // "`Hello` world!"
console.log(typeof message);        // "string"
console.log(message.length);        // 14			
			</pre>
			</dd>
		</dl>
		<p>Няма нужда от
			<em>escape</em> на двойни или единични кавички вътре в
			<em>template literals</em>.</p>
		<h3>Multiline Strings</h3>
		<p>JavaScript програмистите са търсили начин за създаване на няколко реда
			<em>strings</em>, както в първата версия на езика. Но когато се използват единични или двойни кавички,
			<em>strings</em> трябва задължително да бъдат само на един ред.</p>
		<h3>Pre-ECMAScript 6 Workarounds</h3>
		<p>Благодарение на дълго-годишни синтактични бъгове, JavaScript не разполага със заобикаляне на проблема. Може да създадете
			няколко реда
			<em>strings</em> ако има обратно наклонена черта (\) преди всеки нов ред. Ето един пример</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> message = "Multiline \
string";
console.log(message);       // "Multiline string"				
				</pre>
			</dd>
		</dl>
		<p>В
			<em>message string</em> няма нови редове, които да се представят при отпечатване на конзолата, защото наклонената черта се
			третира, като продължение, а не като нов ред. За да се покаже новия ред в продукцията, ще трябва да се включи ръчно:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> message = "Multiline \n\
string";
console.log(message);       // "Multiline
                            //  string"
			</pre>
			</dd>
		</dl>
		<p>Това трябва да отпечата
			<em>Multiline String</em> на две отделни линии на всички основни JavaScript машини, но това поведение често се определя като
			грешка и много програмисти препоръчват да се избягва.</p>
		<p>Други опити преди ECMAScript 6 за създаване на няколко реда
			<em>strings</em> обикновено разчитат на <em>arrays</em> или на конкатенация на
			<em>strings</em>, като например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> message = [  
    "Multiline ", 
    "string"
].join("\n");
<span class="code">let</span> message = "Multiline \n" +
    "string";
				</pre>
			</dd>
		</dl>
		<p>При всички от начините, JavaScript програмистите са работили около липсата на няколко реда
			<em>strings</em>, като още нещо, което да се желае.</p>
		<h3>Multiline Strings - лесния начин</h3>
		<p>ECMAScript 6
			<em>template literals</em> правят няколко реда
			<em>strings</em> лесно, защото няма специален синтаксис. Просто включвате нов ред където искате и го показвате в резултата.
			Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> message = `Multiline
string`;
console.log(message);           // "Multiline
                                //  string"
console.log(message.length);    // 16	
			</pre>
			</dd>
		</dl>
		<p>Всички празни пространства вътре в апострофите са част от
			<em>string</em>, така че внимавайте с отстоянието. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> message = `Multiline
               string`;
console.log(message);           // "Multiline
                                //                 string"
console.log(message.length);    // 31
			</pre>
			</dd>
		</dl>
		<p>В този код, всички празни места преди втората линия на
			<em>template literal</em> се считат, като част от
			<em>string</em>. Ако направата на текст с правилни отстояния е важно за вас, помислете първо да не оставите нищо на първия
			ред от
			<em>multiline template</em> и след това отстоянията, както следва:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> html = `
&ltdiv&gt
    &lth1&gtTitle&lt/h1&gt
&lt/div&gt`.trim();		
			</pre>
			</dd>
		</dl>
		<p>Този код започва от първата линия, но няма никакъв текст до втората линия. Таговете на HTML за отстъп изглеждат правилно
			и после
			<em>trim()</em> метода се извиква за да премахне първия празен ред.</p>
		<div class="aside">
			<p>Ако предпочитате, можете да използвате \n в
				<em>template literal</em> за да посочи къде трябва да се вмъкне нов ред:</p>
			<pre class="highlight">
<span class="code">let</span> message = `Multiline\nstring`;
 console.log(message);           // "Multiline
                                 //string"
console.log(message.length);     // 16			
			</pre>
		</div>
		<h3>Осъществяване на замествания</h3>
		<p>До този момент,
			<em>template literals</em> може да изглеждат, като красиви версии на нормални JavaScript
			<em>strings</em>. Истинската разлика е в
			<em>template literal</em> заместванията. Заместванията позволяват да вградим всеки валиден израз в JavaScript, вътре в
			<em>template literal</em> и изходния резултат, като част от
			<em>string</em>.</p>
		<p>Заместванията са разделени с отваряне ${ и затваряне }, като могат да имат всеки JavaScript израз вътре. Най-простото заместване
			позволява да вградите локални променливи директно в резултата на
			<em>string</em>, като това:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> name = "Nicholas",
    message = `Hello, ${name}.`;
console.log(message);       // "Hello, Nicholas."
			</pre>
			</dd>
		</dl>
		<p>Замяната ${name} има достъп до локалната променлива
			<em>name</em> и я вмъква в
			<em>message string</em>. Променливата
			<em>message</em> държи в резултата тази замяна.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>
					<em>Template literal</em> има достъп до всяка достъпна променлива в обхвата, в който се определя. Всеки опит да се използва
					необявена променлива в
					<em>template literal</em> хвърля грешка и в двата режима
					<em>strict</em> и
					<em>non-strict modes</em>.</strong>
			</dd>
		</dl>
		<p>Тъй като всички замествания са в JavaScript изрази, можем да заместим повече от прости имена на променливи. Можем лесно
			да вградим изчисления, извиквания на функции и още.. . Например:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">let</span> count = 10,
    price = 0.25,
    message = `${count} items cost $${(count * price).toFixed(2)}.`;
console.log(message);       // "10 items cost $2.50."
			</pre>
			</dd>
		</dl>
		<p>Този код извършва изчисление, като част от
			<em>template literal</em>. Променливите
			<em>count</em> и
			<em>price</em> се умножават, за да получим резултат, който се форматира с два знака след десетичната запетая използвайки
			<em>.toFixed()</em>. Знакът за долар $ преди второто заместване се извежда, както е , защото не е последван от фигурни скоби.</p>
		<p>
			<em>Template literals</em> са също JavaScript изрази, което означава, че може да се постави
			<em>template literal</em> вътре в друг
			<em>template literal</em>, както в този пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> name = "Nicholas",
    message = `Hello, ${`my name is ${ name }`}.`;
console.log(message);        // "Hello, my name is Nicholas."	
			</pre>
			</dd>
		</dl>
		<p>В този пример, вторият
			<em>template literal</em> е вътре в първия. След първия ${, започва другия
			<em>template literal</em>. Втория ${ показва началото на вградения израз на вътрешния
			<em>template literal</em>. Тази експресия е на променливата
			<em>name</em>, която се вмъква в резултата.</p>
		<h3>Tagged Templates</h3>
		<p>Досега видяхме, как
			<em>template literals</em> могат да създават по няколко реда
			<em>strings</em> и да вмъкваме стойности в
			<em>string</em> без конкатенация. Но истинската сила на
			<em>template literals</em> идва от
			<em>tagged templates</em>. &nbsp;&nbsp;
			<em>template tag</em> извършва трансформация на
			<em>template literal</em> и връща крайната
			<em>string</em> стойност. Този
			<em>tag</em> е посочен в началото на
			<em>template</em>, точно преди първия ` характер, както е показано тук:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> message = tag`Hello world`;				
			</pre>
			</dd>
		</dl>
		<p>В този пример,
			<em>tag</em> е
			<em>template tag</em> , който се прилага към
			<em>`Hello world` template literal</em>.</p>
		<h3>Определяне на Tags</h3>
		<p>
			<em>Tag</em> е проста функция, която се извиква с данните на
			<em>template literal. &nbsp;&nbsp; tag</em> получава данните за
			<em>template literal</em>, като отделни парчета и трябва да комбинира парчетата за да създаде резултата. Първият аргумент
			е <em>array</em>, съдържащ
			<em>strings</em>, който се тълкува от JavaScript. Всеки следващ аргумент се тълкува от стойността на замяната.</p>
		<p>
			<em>Tag</em> функциите обикновено се определят с помощта
			<em>rest</em> аргументи, които следва да се занимават с данните по-лесно:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> tag(literals, ...substitutions) {
     // return a string
}
			</pre>
			</dd>
		</dl>
		<p>За да разберем по-добре това, което се подава на таговете, имайте в предвид следното:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">let</span> count = 10,
    price = 0.25,
    message = passthru`${count} items cost $${(count * price).toFixed(2)}.`;	
			</pre>
			</dd>
		</dl>
		<p>Ако имате функция наречена
			<em>passthru()</em>, тази функция ще получи три аргумента. Първо, тя ще получи
			<em>literals</em> <em>array</em>, съдържащ следните елементи:</p>
		<dl>
			<dd>
				<ul>
					<li>празен
						<em>string</em> преди заместването ("")</li>
					<li>
						<em>string</em> след първото заместване и преди второто (" items cost $")</li>
					<li>
						<em>string</em> след второто заместване (".")</li>
				</ul>
			</dd>
		</dl>
		<p>Следващия аргумент ще бъде 10, който интерпретира стойността на
			<em>count</em> променливата. Това ще бъде първия елемент в
			<em>substitutions</em> <em>array</em>. Последния аргумент ще бъде "2.50", който е тълкуваната стойност на
			<em>(count * price).toFixed(2)</em> и вторият елемент на
			<em>substitutions</em> <em>array</em>.</p>
		<p>Имайте в предвид, че първият елемент в
			<em>literals</em> е празен
			<em>string</em>. Това гарантира, че
			<em>literals[0]</em> е винаги в началото на
			<em>string</em>, точно както
			<em>literals[literals.length - 1]</em> е винаги края на
			<em>string</em>. Винаги има едно по-малко в заместването на
			<em>literal</em>, което означава, че израза
			<em>substitutions.length === literals.length - 1</em> винаги е верен.</p>
		<p>Използвайки този модел на
			<em>literals</em> и
			<em>substitutions</em> <em>arrays</em>, те могат да се преплитат за създаване на резултат в
			<em>string</em>. Първият елемент в
			<em>literals</em> е на първо място, първият елемент в
			<em>substitutions</em> е на следващо място, и т.н., докато
			<em>string</em> се запълни. Като пример, можем да имитираме поведението по подразбиране на
			<em>template literal</em> с редуващите се стойности на тези два <em>array</em>:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">function</span> passthru(literals, ...substitutions) {
    <span class="code">let</span> result = "";
    <span class="comment"><em>// пускаме цикъл само за броя на замените</em></span>
    <span class="code">for</span> (<span class="code">let</span> i = 0; i < substitutions.length; i++) {
        result += literals[i];
        result += substitutions[i];
    }
    <span class="comment"><em>// добавяне на  последния literal</em></span>
    result += literals[literals.length - 1];
    <span class="code">return</span> result;
}
<span class="code">let</span> count = 10,
    price = 0.25,
    message = passthru`${count} items cost $${(count * price).toFixed(2)}.`;
console.log(message);       // "10 items cost $2.50."		
			</pre>
			</dd>
		</dl>
		<p>Този пример дефинира
			<em>passthru tag</em>, който изпълнява същата трансформация, както поведението по подразбиране на
			<em>template literal</em>. Единственият трик е използването на
			<em>substitutions.length</em> за цикъла, вместо
			<em>literals.length</em> за да се избегне случайно подминаване на края на
			<em>substitutions</em> <em>array</em>. Това работи, защото връзката между
			<em>literals</em> и
			<em>substitutions</em> е добре дефинирана в ECMAScript 6.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Стойностите, които се съдържат в
					<em>substitutions</em> не са непременно
					<em>strings</em>. Ако израза оценява номера, както в предишния пример, тогава се подава цифрова стойност вътре. Определянето,
					как тази стойност да се изведе в резултата е част от работата на
					<em>tags</em>.</strong>
			</dd>
		</dl>
		<h3>Използване на необработени стойности в Template Literals</h3>
		<p>
			<em>Template tags</em> също имат достъп до информацията на необработен
			<em>string</em>, което означава най-вече достъп до
			<em>escapes</em> на характера, преди трансформацията им в еквивалентни характери. Най-простия начин да се работи с необработени
			<em>string</em> стойности е използването на вградения
			<em>String.raw() tag</em>. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> message1 = `Multiline\nstring`,
    message2 = <span class="code">String</span>.raw`Multiline\nstring`;
console.log(message1);          // "Multiline
                                //  string"
console.log(message2);          // "Multiline\\nstring"
			</pre>
			</dd>
		</dl>
		<p>В този код \n в
			<em>message1</em> се тълкува, като знак за нов ред, докато \n в
			<em>message2</em> се връща в необработен вид "\\n" (наклонена черта и
			<em>n</em> характери). Извличането на информация от необработен
			<em>string</em>, дава възможност за по-сложна обработка, когато е необходимо.</p>
		<p>Информацията от необработен
			<em>string</em> също се подава на
			<em>template tags</em>. Първият аргумент в
			<em>tag</em> функцията е <em>array</em> с възможност за допълнително свойство, наречено
			<em>raw</em>. Свойството
			<em>raw</em> е <em>array</em> съдържащ необработен еквивалент на всяка
			<em>literal</em> стойност. Например, стойността на
			<em>literals[0]</em> винаги е еквивалент на
			<em>literals.raw[0]</em>, която съдържа необработена
			<em>string</em> информация. Знаейки това, можем да имитираме
			<em>String.raw()</em> използвайки следния код:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> raw(literals, ...substitutions) {
    <span class="code">let</span> result = "";
    <span class="comment"><em>// пускаме цикъл само за броя на замените</em></span>
    <span class="code">for</span> (<span class="code">let</span> i = 0; i < substitutions.length; i++) {
        result += literals.raw[i];   <span class="comment"><em>// използваме необработена 
        стойност</em></span>
        result += substitutions[i];
    }
    <span class="comment"><em>// добавяне на последния literal</em></span>
    result += literals.raw[literals.length - 1];
    <span class="code">return</span> result;
}
<span class="code">let</span> message = raw`Multiline\nstring`;
console.log(message);           // "Multiline\\nstring"
console.log(message.length);    // 17		
			</pre>
			</dd>
		</dl>
		<p>Кода използва
			<em>literals.raw</em> вместо
			<em>literals</em> за изходния резултат на
			<em>string</em>. Това означава, че всеки
			<em>escapes</em> характер, включително и Unicode кодовата точка
			<em>escapes</em>, трябва да бъде върнат в необработен вид.
			<em>Raw strings</em> са полезни, когато искаме изходния
			<em>string</em> да съдържа код в който трябва да се включи
			<em>escaping</em> на характера (например, ако искаме да се генерира документация на някакъв код, можем да искаме в продукцията
			да се вижда действителния код).</p>
	</article>
	<footer>
		<h3>Обобщение</h3>
		<p>Пълната Unicode поддръжка позволява на JavaScript да се справи със UTF-16 характерите по логически начин. Способноста да
			се прехвърля между кодова точка и характер, чрез
			<em>codePointAt()</em> и
			<em>String.fromCodePoint()</em> е важна стъпка за манипулирането на
			<em>string</em>. Добавянето на
			<em>u flag</em> в регулярния израз дава възможност да се работи с кодови точки вместо 16-битови характери, както и метода
			<em>normalize()</em> дава възможност за подходящи сравнения на
			<em>string</em>.</p>
		<p>ECMAScript 6 също добавя нови методи за работа със
			<em>strings</em>, които позволяват лесно да се идентифицират
			<em>substring</em> независимо от тяхната позиция в родителския
			<em>string</em>. В регулярните изрази също е добавена повече функционалност.</p>
		<p>
			<em>Template literals</em> са важно допълнение към ECMAScript 6, които ви позволяват да създадете домейн-специфични езици
			(DSLs) за по-лесно създаване на
			<em>strings</em>. Способноста директно да се вградят променливи в
			<em>template literals</em>, означава за програмистите по-безопасно средство от конкатенация на
			<em>string</em> за композиране на дълги
			<em>strings</em> с променливи.</p>
		<p>Вградената поддръжка за
			<em>multiline strings</em> също прави
			<em>template literals</em> - полезна актуализация за JavaScript
			<em>strings</em>, които никога не са имали тази възможност. Въпреки разрешаването на новите редове директно вътре във
			<em>template literal</em>, вие все още може да използвате \n и други
			<em>character escape</em> последователности.</p>
		<p>
			<em>Template tags</em> са важна част от функцията за създаване на DSLs.
			<em>Tags</em> са функции, които получават парчета от
			<em>template literal</em>, като аргументи. След това можем да използваме тези данни за връщане на подходяща
			<em>string</em> стойност. Предоставените данни включват
			<em>literals</em>, техните необработени еквиваленти, както и всякакви заместващи стойности. Тези части от информация могат
			да се използват за определяне на правилния изход на
			<em>tag</em>.</p>
	</footer>
	<nav>
		<a href="./01_block.html" title="previous chapter">◀</a>
		<a href="./index.html" title="cover">◆</a>
		<a href="./03_function.html" title="next chapter">▶</a>
	</nav>
</body>

</html>