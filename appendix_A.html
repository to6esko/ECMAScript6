<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Приложение А :: Understanding ECMAScript 6</title>
	<link rel="stylesheet" href="font.css">
</head>

<body>
	<nav>
		<a href="./13_modules.html" title="previous chapter">◀</a>
		<a href="./index.html" title="cover">◆</a>
		<a href="./appendix_B.html" title="next chapter">▶</a>
	</nav>

	<header id="header" class="">
		<h1>Приложение А: По-малки ECMAScript 6 промени</h1>
		<p>Заедно с големите промени споменати в тази книга, ECMAScript 6 направи няколко други промени, които са по-малки, но все
			пак полезени за подобряване на JavaScript. Тези промени включват, добавяне на нови методи за изчисления, пипване на Unicode
			идентификаторите и формализиране на __proto__ свойството. Аз ще опиша всичките в настоящото допълнение.</p>
	</header>
	<!-- /header -->
	<article>
		<h3>Работа с цели числа</h3>
		<p>JavaScript използва IEEE 754 система на кодиране за представлявяне на цели и десетични числа, което доведе до много объркване
			през годините. Езика минава през големи усилия за да гарантира, че програмистите не трябва да се притесняват за детайлите
			на
			<em>number</em> кодирането, но проблеми все още се създават от време на време. ECMAScript 6 има за цел да се справи с това,
			като прави по-лесно идентифицирането и работата с цели числа.</p>
		<h4>Идентифициране на цели числа</h4>
		<p>Първо, ECMAScript 6 добавя
			<em>Number.isInteger()</em> метода, който позволява да се определи дали една стойност е цяло число в JavaScript. Тъй като,
			JavaScript използва IEEE 754 да представлява номера и десетични числа, те се съхраняват по различен начин. Метода
			<em>Number.isInteger()</em> се възползва от това и когато се извика върху стойност, JavaScript двигателя се оглежда за най-основното
			представяне на стойността, за да определи дали тази стойност е цяло число. Това означава, че номерата, които изглеждат,
			като десетични всъщност може би са съхранени, като цели числа и това е причината
			<em>Number.isInteger()</em> да върне
			<em>true</em>. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
console.log(<span class="code">Number</span>.isInteger(25));      // true
console.log(<span class="code">Number</span>.isInteger(25.0));    // true
console.log(<span class="code">Number</span>.isInteger(25.1));    // false
				</pre>
			</dd>
		</dl>
		<p>В този код,
			<em>Number.isInteger()</em> връща
			<em>true</em> за 25 и 25.0 въпреки, че последното прилича на десетично. Добавянето на десетична точка за номер, не означава
			автоматично десетично число в JavaScript. Тъй като, 25.0 е наистина само 25, то се съхранява, като цяло число. Номерът
			25.1, обаче се съхранява, като десетично, защото има стойност на фракция.</p>
		<h4>Safe Integers</h4>
		<p>IEEE 754 може само точно да представлява цели числа между -2
			<sup>53</sup> и 2
			<sup>53</sup> и извън този "безопасен" диапазон, бинарното представяне използва повторно някои цифрови стойности. Това означава,
			че JavaScript може само безопасно да представлява числа в IEEE 754 диапазона преди проблемите да станат явни. Например,
			помислете върху този код:</p>
		<dl>
			<dd>
				<pre class="highlight">
console.log(<span class="code">Math</span>.pow(2, 53));      // 9007199254740992
console.log(<span class="code">Math</span>.pow(2, 53) + 1);  // 9007199254740992
				</pre>
			</dd>
		</dl>
		<p>Този пример не съдържа печатна грешка, две различни числа са представени, като едно и също цяло число в JavaScript. Ефектът
			става все по-разпространен при по-нататъшното попадане на стойността извън безопасния диапазон.</p>
		<p>ECMAScript 6 въвежда
			<em>Number.isSafeInteger()</em> метода за по добро идентифициране на цели числа, които могат точно да се представят от езика.
			Той също така добавя
			<em>Number.MAX_SAFE_INTEGER</em> и
			<em>Number.MIN_SAFE_INTEGER</em> свойства, които да представляват горната и долна граница на този диапазон.
			<em>Number.isSafeInteger()</em> метода гарантира, че стойността е цяло число и попада в рамките на безопасния диапазон за
			целочислени стойности, както в този пример:

		</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> inside = <span class="code">Number</span>.MAX_SAFE_INTEGER,
    outside = inside + 1;

console.log(<span class="code">Number</span>.isInteger(inside));          // true
console.log(<span class="code">Number</span>.isSafeInteger(inside));      // true

console.log(<span class="code">Number</span>.isInteger(outside));         // true
console.log(<span class="code">Number</span>.isSafeInteger(outside));     // false
			</pre>
			</dd>
		</dl>
		<p>Номерът в
			<em>inside</em> е най-голямото безопасно цяло число, така че връща
			<em>true</em> за
			<em>Number.isInteger()</em> и
			<em>Number.isSafeInteger()</em> методите. Номерът
			<em>outside</em> е първата съмнителна стойност за цяло число, така че вече не се смята за безопасна, въпреки че тя все още
			е цяло число. </p>
		<p>През по-голямата част от времето вие ще искате да се справяте с безопасни числа при аритметика или сравняване в JavaScript,
			така че използването на
			<em>Number.isSafeInteger()</em>, като част от входа за валидиране е добра идея.</p>
		<h4>Нови Math методи</h4>
		<p>Новия акцент върху игри и графики доведе до ECMAScript 6 да включва
			<em>typed arrays</em> в JavaScript, което също доведе до разбирането, че JavaScript машината може да направи много математически
			изчисления по-ефективно. Но оптимизацията на стратегии, като
			<em>asm.js</em>, който работи върху под- множества в JavaScript, за да подобри производителноста се нуждае от повече информация
			за извършване на изчисления по най-бързия възможен начин. Например, знаейки дали номерата трябва да бъдат третирани, като
			32-битови цели числа или 64-битови числа с плаваща запетая е важно за хардуерно базирани операции, които са много по-бързи
			от колкото софтуерно базирани операции.</p>
		<p>В резултат на това, ECMAScript 6 добавя няколко нови метода към
			<em>Math</em> обекта, за да подобри скоростта на общи математически изчисления. Подобряването на скоростта на общите изчисления
			също подобрява цялостната скорост на приложенията, които изпълняват много изчисления, като например графични програми.
			Новите методи са изброени по-долу:</p>
		<dl>
			<dd>
				<ul>
					<li>Math.acosh(x) - Връща обратния хиперболичен косинус на x.</li>
					<li>Math.asinh(x) - Връща обратния хиперболичен синус на x.</li>
					<li>Math.atanh(x) - Връща обратния хиперболичен тангенс на x.</li>
					<li>Math.cbrt(x)
						< - Връща кубичния корен на x.</li>
							<li>Math.clz32(x) - Връща броя на водещите нулеви битове в представянето на 32-битовото цяло число x.</li>
							<li>Math.cosh(x) - Връща хиперболичния косинус на x.</li>
							<li>Math.expm1(x) - Връща резултата от изваждането на 1 от експоненциална функция на x.</li>
							<li>Math.fround(x) - Връща най-близката единична точност на float за x.</li>
							<li>Math.hypot(...values) - Връща корен квадратен от сбора на квадратите на всеки аргумент.</li>
							<li>Math.imul(x, y) - Връща резултата от извършване истинско 32-битово умножение на два аргумента.</li>
							<li>Math.log1p(x) - Връща натуралния логаритъм от 1 + x.</li>
							<li>Math.log10(x) - Връща база 10 логаритъм от x.</li>
							<li>Math.log2(x) - Връща база 2 логаритъм от x.</li>
							<li>Math.sign(x) - Връща -1 ако х е отрицателно, 0 ако x е 0 или - 0 или 1 ако х е положително.</li>
							<li>Math.sinh(x) - Връща хиперболичния синус на x.</li>
							<li>Math.tanh(x) - Връща хиперболичния тангенс на x.</li>
							<li>Math.trunc(x) - Премахва цифри след десетичната запетая и връща цяло число.</li>
				</ul>
			</dd>
		</dl>
		<p>Извън обхвата на тази книга е да се обясни по подробно всеки нов метод и това което прави. Въпреки това, ако търсите по-разумно
			общо изчисление, не забравяйте да проверите за нови
			<em>Math</em> методи, преди да го изпълните сами.</p>
		<h3>Unicode идентификатори</h3>
		<p>ECMAScript 6 предлага по-добра Unicode поддръжка от предишните версии на JavaScript и също така променя начина, по-който
			характерите могат да се използват, като идентификатори. В ECMAScript 5 вече е възможно да се използват Unicode екраниращи
			последователности за идентификатори. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="comment"><em>// Валидно в ECMAScript 5 и 6</em></span>
<span class="code">var</span> \u0061 = "abc";

console.log(\u0061);        // "abc"

<span class="comment"><em>// еквивалентно на</em></span>
// console.log(a);          // "abc"
				</pre>
			</dd>
		</dl>
		<p>След
			<em>var</em> изявлението в този пример, можете да използвате \u0061 или
			<em>а</em> за достъп до променливата. В ECMAScript 6 можете да използвате Unicode точково кодиране за екраниращи последователности,
			като идентификатори, като това:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="comment"><em>// Валидно в ECMAScript 5 и 6</em></span>
<span class="code">var</span> \u{61} = "abc";

console.log(\u{61});        // "abc"

<span class="comment"><em>// еквивалентно на</em></span>
// console.log(a);          // "abc"
				</pre>
			</dd>
		</dl>
		<p>Този пример просто заменя \u0061 с неговия точково кодиран еквивалент. Иначе прави същото нещо като предишния пример.</p>
		<p>Освен това, ECMAScript 6 официално определя валидни идентификатори по отношение на
			<a href="http://unicode.org/reports/tr31/">Unicode Standard Annex #31: Unicode Identifier and Pattern Syntax</a>, който дава следните правила:</p>
		<dl>
			<dd>
				<ol>
					<li>Първия характер трябва да бъде $, _, или всеки Unicode символ с извлечено основно свойство от ID_Start. </li>
					<li>Всеки следващ характер трябва да бъде $, _, \u200c (zero-width non-joiner), \u200d (zero-width joiner), или всеки Unicode
						символ с извлечено основно свойство от ID_Continue.</li>
				</ol>
			</dd>
		</dl>
		<p>На ID_Start и ID_Continue извлечените основни свойства са определени в
			<em>Unicode Identifier</em> и
			<em>Pattern Syntax</em>, като начин за идентифициране на символи, които са подходящи за използване в идентификатори на променливи
			и имена на домейни. Спецификацията не е специфична за JavaScript.</p>
		<h3>Формализиране на proto свойство</h3>
		<p>Дори преди ECMAScript 5 да е завършен, няколко JavaScript машини вече изпълняваха потребителско свойство, наречено __proto__
			, което може да се използва за получаване и задаване на [[Prototype]]. Ефективно, __proto__ е ранен предшественик на методите
			<em>Object.getPrototypeOf()</em> и
			<em>Object.setPrototypeOf()</em>. Очаква се всички JavaScript машини да премахнат това не реалистично свойство (това са популярни
			JavaScript библиотеки използващи __proto__ ), така че ECMAScript 6 също формализира това __proto__ поведение. Въпреки,
			че формализирането е в приложение B на ECMA-262, заедно с това предупреждение:</p>
		<dl>
			<dd style="color: cornflowerblue">Тези функции не се считат за част от основния език ECMAScript. Програмистите не трябва да използват или предполагат съществуването
				на тези характеристики и поведение, когато пишат нов ECMAScript код. ECMAScript реализациите са обезкуражени от формите
				му на прилагане, освен ако изпълнението е част от уеб браузър или се изисква да изпълни същото наследяване в ECMAScript
				кода, с което уеб браузърите се сблъскват.</dd>
		</dl>
		<p>Спецификацията на ECMAScript препоръчва да използвате
			<em>Object.getPrototypeOf()</em> и
			<em>Object.setPrototypeOf()</em> вместо него, защото __proto__има следните характеристики:</p>
		<ol>
			<li>Можете да зададете __proto__ само веднъж в даден обект . Ако зададете две __proto__ свойства ще бъде хвърлена грешка.
				Това е единственото свойство на обект с такова ограничение.</li>
			<br>
			<li>Изчислената форма ["__proto__"] действа, като редовно свойство и не определя или връща прототипа на текущия обект. Всички
				правила свързани с обектни свойства се прилагат в тази форма, за разлика от не-изчислената форма, която има изключения.</li>
		</ol>
		<p>Въпреки, че е най-добре да се избягва използването на __proto__ свойство, е интересно да се види, как спецификацията го
			определя. В ECMAScript 6 машината,
			<em>Object.prototype.__proto__ </em> е дефинирано, като свойство за достъп, чийто
			<em>get</em> метод извиква
			<em>Object.getPrototypeOf()</em> и чиито
			<em>set</em> метод извиква
			<em>Object.setPrototypeOf()</em> методите. Това оставя впечатление, че няма реална разлика между използването на __proto__
			и
			<em>Object.getPrototypeOf() / Object.setPrototypeOf()</em> с изключение на това, че __proto__ ви позволява да настроите прототипа
			на даден обект директно. Ето как става това:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">let</span> person = {
    getGreeting() {
        <span class="code">return</span> "Hello";
    }
};

<span class="code">let</span> dog = {
    getGreeting() {
        <span class="code">return</span> "Woof";
    }
};

<span class="comment"><em>// прототипа е person</em></span>
<span class="code">let</span> friend = {
    __proto__: person
};
console.log(friend.getGreeting());                      // "Hello"
console.log(<span class="code">Object</span>.getPrototypeOf(friend) === person);  // true
console.log(friend.__proto__ === person);               // true

// set prototype to dog
friend.__proto__ = dog;
console.log(friend.getGreeting());                      // "Woof"
console.log(friend.__proto__ === dog);                  // true
console.log(<span class="code">Object</span>.getPrototypeOf(friend) === dog);     // true
				</pre>
			</dd>
		</dl>
		<p>Вместо да извика
			<em>Object.create()</em> за да направи
			<em>friend</em> обекта, този пример създава стандартен обект, който присвоява стойност на свойството __proto__. От друга страна,
			при създаване на обект с
			<em>Object.create()</em> метода, ще трябва да уточните пълните описания на свойства за каквито и да било допълнителни обектни
			свойства.</p>
	</article>
	<nav>
		<a href="./13_modules.html" title="previous chapter">◀</a>
		<a href="./index.html" title="cover">◆</a>
		<a href="./appendix_B.html" title="next chapter">▶</a>
	</nav>
</body>

</html>