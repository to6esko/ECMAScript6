<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Promises :: Understanding ECMAScript 6</title>
	<link rel="stylesheet" href="font.css">
</head>

<body>
	<nav>
		<a href="10_array.html" title="previous chapter">◀</a>
		<a href="./index.html" title="cover">◆</a>
		<a href="./12_proxies_and_reflection.html" title="next chapter">▶</a>
	</nav>
	<header id="header" class="">
		<h1>
			<div class="head-num">Глава 11</div>
			<em>Promises</em> и Асинхронно програмиране</h1>
		<p>Една от най-силните страни на JavaScript е колко лесно се справя с асинхронното програмиране. Тъй като JavaScript възниква,
			като език за уеб, е изискване да бъде в състояние да отговаря на асинхронни взаимодействия с потребители, като например
			кликвания и натискане на клавиш. Node.js допълнително популяризира асинхронното програмиране в JavaScritp, чрез използване
			на обратни извиквания, като алтернатива на събития. Тъй като все повече и повече програми започнаха да използват асинхронно
			програмиране, тези два модела - събития и извиквания, не са достатъчно мощни, за да поддържат всичко, което програмистите
			искат да направят.
			<em>Promises</em> са решение на този проблем.</p>
		<p>
			<em>Promises</em> са друга възможност за асинхронно програмиране и работи, като
			<em>futures</em> и
			<em>deferreds</em> в другите езици.
			<em>Promise</em> определя някакъв код, който да бъде изпълнен по-късно (като събития и обратни извиквания) и също така изрично
			да посочва дали кода е успял или се е провалил в работата си. По този начин, можем да направим верижни
			<em>promises</em> заедно въз основа на успеха или неуспеха по начини, които са по-лесни за разбиране и отстраняване на грешки.
		</p>
		<p>Преди да може да получите добро разбиране на това как работят
			<em>promises</em>, е важно да се разберат някои основни понятия, от които те са изградени.</p>
	</header>
	<!-- /header -->
	<article>
		<h3>Asynchronous Programming Background</h3>
		<p>JavaScript машината е изградена върху идеята за еднонишков контур на събитие. Еднонишково означава, че само една част от
			кода се изпълнява в даден момент от време. Това е различно от други езици, като Java или C++, където няколко нишки могат
			да позволят множество различни части от код да се изпълняват едновременно. Поддържане и опазване на състоянието, когато
			няколко парчета код могат да получат достъп и променят това състояние е труден проблем и източник на чести грешки в софтуера.</p>
		<p>Понеже JavaScript машината може да изпълнява само едно парче код в даден момент, е необходимо да се следи този код, който
			е предназначен да се изпълнява. Този код се съхранява в
			<em>job queue</em>. Всеки път, когато част от кода е готов да се изпълни той се добавя към
			<em>job queue</em>. Когато JavaScript машината завърши изпълнението на код, контура на събитието взема следващата задача от
			<em>job queue</em> и я изпълнява. Контура на събитието е процес вътре в JavaScript машината, който следи изпълнението на код
			и управлява
			<em>job queue</em>. Имайте в предвид, че в
			<em>job queue</em> изпълнението на работата започва да тече от първата задача до последната.</p>
		<h3>Модел на Events (събития)</h3>
		<p>Когато потребител кликне с мишката или натисне клавиш от клавиатурата, се задейства събитие (като
			<em>onclick</em>). Това събитие може да се използва, за да се отговори на взаимодействието чрез добавяне на нова задача, обратно
			в
			<em>job queue</em>. Това е най-основната форма на асинхронно програмиране в JavaScript: кода на манипулатора на събитието
			не се изпълнява, докато трае ефекта на събитието и когато се изпълни, той е с подходящ контекст. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> button = <span class="code">document</span>.getElementById("my-btn");
button.onclick = <span class="code">function</span>(event) {
    console.log("Clicked");
};
			</pre>
			</dd>
		</dl>
		<p>В този код,
			<me>console.log("Clicked")</em> няма да се изпълни, докато
				<em>button</em> е натиснат. Когато
				<em>button</em> се натисне, функцията присвоена от
				<em>onclick</em> се добавя обратно към
				<em>job queue</em> и ще бъде изпълнена, когато всички други задачи преди нея са изпълнени.</p>
		<p>Събитията работят добре за прости взаимодействия, като това, но наредени верижно няколко отделни асинхронни събития е по
			сложно, защото вие трябва да следите целта на събитието за всяко събитие. Освен това, трябва да се гарантира, че всички
			подходящи манипулатори на събития са добавени преди самото възникване на събитието. Например, ако
			<em>button</em> в предишния пример е натиснат преди дефинирането на
			<em>onclick</em>, няма да се случи нищо. Така че, докато събитията са полезни за отговори на потребителски взаимодействия
			и подобна функционалност, която се проявява рядко, те не са много гъвкави за по-сложни нужди.</p>
		<h3>Моделът на Callbacks (обратно извикване)</h3>
		<p>Когато Node.js е създаден, той укрепва модела на асинхронното програмиране с популяризиране на модела за обратно извикване.
			Модела на обратното извикване е подобен на модела на събитието, тъй като не изпълнява код, до една по-късна точка във
			времето. Това е различно, защото функцията за извикване е подадена, като аргумент.</p>
		<dl>
			<dd>
				<pre class="highlight">
readFile("example.txt", <span class="code">function</span>(err, contents) {
    <span class="code">if</span> (err) {
        <span class="code">throw</span> err;
    }

    console.log(contents);
});
console.log("Hi!");
			</pre>
			</dd>
		</dl>
		<p>Този код използва традиционния Node.js стил за грешка при обратно извикване. Функцията
			<em>readFile()</em> е предназначена да чете от файл на диск (посочен, като първи аргумент) и след това изпълнява обратно извикване
			(като втори аргумент). Ако има грешка,
			<em>err</em> е обекта за грешка, в противен случай,
			<em>contents</em> съдържа съдържанието на файла, като
			<em>string</em>.</p>
		<p>Използвайки модела на обратното извикване,
			<em>readFile()</em> започва изпълнението незабавно и спира, когато започва да чете от диска. Това означава, че
			<em>console.log("Hi!")</em> се извежда веднага след извикването на
			<em>readFile()</em> преди
			<em>console.log(contents)</em> да отпечата нещо. Когато
			<em>readFile()</em> приключи, той добавя нова задача в края на
			<em>job queue</em> с функцията за обратно извикване и нейните аргументи. Като тази работа се извършва след приключване
			на всички други задачи преди нея.</p>
		<p>Моделът за обратно извикване е по-гъвкав от събития, защото е по-лесно да се наредят верижно няколко извиквания заедно.
			Например:
		</p>
		<dl>
			<dd>
				<pre class="highlight">
readFile("example.txt", <span class="code">function</span>(err, contents) {
    <span class="code">if</span> (err) {
        <span class="code">throw</span> err;
    }

    writeFile("example.txt", <span class="code">function</span>(err) {
        <span class="code">if</span> (err) {
            <span class="code">throw</span> err;
        }

        console.log("File was written!");
    });
});
			</pre>
			</dd>
		</dl>
		<p>В този код, успешното извикване на
			<em>readFile()</em> води до друго асинхронно повикване, този път към
			<em>writeFile()</em> функцията. Обърнете внимание, че една и съща основна проверка
			<em>err</em> присъства и в двете функции. Когато
			<em>readFile()</em> завърши, той добавя работа в
			<em>job queue</em>, което води до
			<em>writeFile()</em>, която се извиква (ако няма грешки). След това,
			<em>writeFile()</em> добавя работа в
			<em>job queue</em>, когато тя завърши.</p>
		<p>Въпреки, че това работи доста добре, можем бързо да влезем в модел, който е известен под името
			<em>callback hell. Callback hell</em> се случва, когато има твърде много вложени обратни извиквания:</p>
		<dl>
			<dd>
				<pre class="highlight">
method1(<span class="code">function</span>(err, result) {

    <span class="code">if</span> (err) {
        <span class="code">throw</span> err;
    }

    method2(<span class="code">function</span>(err, result) {

        <span class="code">if</span> (err) {
            <span class="code">throw</span> err;
        }

        method3(<span class="code">function</span>(err, result) {

            <span class="code">if</span> (err) {
                <span class="code">throw</span> err;
            }

            method4(<span class="code">function</span>(err, result) {

                <span class="code">if</span> (err) {
                    <span class="code">throw</span> err;
                }

                method5(result);
            });

        });

    });

});
			</pre>
			</dd>
		</dl>
		<p>Влагането на няколко метода на извикване, както в този пример, създава заплетена мрежа от код, който е труден за разбиране
			и отстраняване на грешки. Обратните извиквания също създават проблеми, когато искате да постигнете по сложна функционалност.
			Какво става, ако искате две асинхронни операции да текат паралелно и да бъдете уведомени, когато и двете са изпълнени?
			И какво става, ако стартирате две асинхронни операции, но се взема резултата само на първата, която е завършила?</p>
		<p>В тези случаи се налага да следите няколко обратни извиквания и операциите за почистване. Това е точно там, където
			<em>Promises</em> значително подобряват ситуацията.</p>
		<h3>
			<em>Promises</em> основи</h3>
		<p>
			<em>Promise</em> е контейнер за резултата на асинхронна операция. Вместо да се абонирате за дадено събитие или подадете обратно
			извикване към функция, функцията може да върне
			<em>promise</em>, като това:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="comment"><em>// readFile обещава да завърши в някакъв момент в бъдеще</em></span>
<span class="code">let</span> promise = readFile("example.txt");
			</pre>
			</dd>
		</dl>
		<p>В този код,
			<em>readFile()</em> всъщност не започва да чете файла незабавно, това ще се случи по-късно. Вместо това, функцията връща обект
			на
			<em>promise</em>, представляващ асинхронна операция за четене, така че да може да се работи с нея в бъдеще. Точно кога ще
			можете да работите с този резултат, зависи изцяло от това, как жизнения цикъл влияе на
			<em>promise</em>.</p>
		<h3>Жизнен цикъл на
			<em>promise</em>
		</h3>
		<p>Всяко
			<em>promise</em> преминава през кратък жизнен цикъл, който започва в изчакване на състоянието, което е показател, че асинхронната
			операция все още не е завършена. Изчакването на
			<em>promise</em> се счита за неуредено.
			<em>Promise</em> в последния пример е в състояние на изчакване, веднага след като функцията
			<em>readFile()</em> го върне. След като, асинхронната операция завърши,
			<em>promise</em> се счита за уредено и влиза в едно от двете възможни състояния:</p>
		<dl>
			<dd>
				<ul>
					<li>
						<em>Fulfilled </em>-
						<em>promise</em> на асинхронната операция завършва успешно.</li>
					<li>
						<em>Rejected </em>-
						<em>promise</em> на асинхронната операция не завършва успешно, поради грешка или някаква друга причина.</li>
				</ul>
			</dd>
		</dl>
		<p>Вътрешно [[PromiseState]] свойството е настроено на "pending", "fulfilled" или "rejected" (изчакване, изпълнение или отхвърляне)
			за да отрази състоянието на
			<em>promise</em>. Това свойство не е изложено в обекта на
			<em>promise</em>, така че не можете да определите програмно, кое е състоянието на
			<em>promise</em>. Но можете да предприемете конкретно действие, когато
			<em>promise</em> променя състоянието с помощта на
			<em>then()</em> метода.</p>
		<p>Метода
			<em>then()</em> е налице за всички
			<em>promises</em> и взема два аргумента. Първия аргумент е функция за извикване, когато
			<em>promise</em> е изпълнено. Всички допълнителни данни, свързани с асинхронната операция са подадени в изпълнението на тази
			функция. Вторият аргумент е функция за извикване, когато
			<em>promise</em> е отхвърлено. Подобно на функцията за изпълнение, във функцията за отхвърляне са подадени всички допълнителни
			данни, свързани с отхвърлянето.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Всеки обект, който реализира
					<em>then()</em> метод по този начин, се нарича
					<em>thenable</em>. Всички
					<em>promises</em> са
					<em>thenables</em>, но не всички
					<em>thenables</em> са
					<em>promises</em>.</strong>
			</dd>
		</dl>
		<p>И двата аргумента към
			<em>then()</em> не са задължителни, но с тях можете да слушате за всяка комбинация от изпълнението и отхвърлянето. Например,
			помислете за тази поредица от
			<em>then()</em> извиквания:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> promise = readFile("example.txt");

<span class="comment"><em>// слушаме, както за изпълнение, така и за отхвърляне</em></span>
promise.then(<span class="code">function</span>(contents) {
    <span class="comment"><em>// изпълнение</em></span>
    console.log(contents);
}, <span class="code">function</span>(err) {
    <span class="comment"><em>// отхвърляне</em></span>
    console.error(err.message);
});

<span class="comment"><em>// слушаме само за изпълнение - грешки не се отчитат</em></span>
promise.then(<span class="code">function</span>(contents) {
    <span class="comment"><em>// изпълнение</em></span>
    console.log(contents);
});

<span class="comment"><em>// слушаме само за отхвърляне - успех не се съобщава</em></span>
promise.then(<span class="code">null, function</span>(err) {
    <span class="comment"><em>// отхвърляне</em></span>
    console.error(err.message);
});	
			</pre>
			</dd>
		</dl>
		<p>Всичките три извиквания на
			<em>then()</em> работят върху едно и също
			<em>promise</em>. Първото извикване слуша, както за изпълнение така и за отхвърляне. Второто слуша само за изпълнение, грешки
			няма да бъдат докладвани. Третото просто слуша за отхвърляне и не докладва успех.</p>
		<p>
			<em>Promises</em> също имат
			<em>catch()</em> метод, който се държи също, като
			<em>then()</em>, само когато се подава към манипулатор за отхвърляне. Например, следното извикване на
			<em>catch()</em> и
			<em>then()</em> e функционално еквивалентнo:</p>
		<dl>
			<dd>
				<pre class="highlight">
promise.<span class="code">catch</span>(<span class="code">function</span>(err) {
    <span class="comment"><em>// отхвърляне</em></span>
    console.error(err.message);
});

<span class="comment"><em>// е също като:</em></span>

promise.then(<span class="code">null, function</span>(err) {
    <span class="comment"><em>// отхвърляне</em></span>
    console.error(err.message);
});
			</pre>
			</dd>
		</dl>
		<p>Целта е да се използва комбинацията от
			<em>then()</em> и
			<em>catch()</em>, за да се справят правилно с резултата на асинхронните операции. Тази система е по-добра от събития и обратни
			извиквания, защото прави операцията за успех или провал напълно ясна. (Събитията не са склонни да се изстрелват, когато
			има грешка и затова не трябва да забравяте във функцията за обратно извикване, винаги да проверявате за аргумента на грешка.)
			Ако не се прикачи манипулатор за отхвърляне към
			<em>promise</em>, всички неуспехи ще се случват мълчаливо. Добра идея е винаги да прикачвате манипулатор за отхвърляне, дори
			и само за да се регистрира провала.</p>
		<p>Манипулаторите за изпълнение и отхвърляне ще бъдат изпълнени, дори ако се добавят към
			<em>job queue</em>, след като
			<em>promise</em> вече е уредено. Това ви позволява да добавите ново изпълнение и отхвърляне, работещи по всяко време и се
			гарантира, че те ще се извикат. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> promise = readFile("example.txt");

<span class="comment"><em>// оригинално изпълнение на манипулатор</em></span>
promise.then(<span class="code">function</span>(contents) {
    console.log(contents);

    <span class="comment"><em>// добавяне на друг нов</em></span>
    promise.then(<span class="code">function</span>(contents) {
        console.log(contents);
    });
});
			</pre>
			</dd>
		</dl>
		<p>В този код, манипулатора за изпълнение добавя друг манипулатор за изпълнение на същото
			<em>promise</em>.
			<em>Promise</em> вече е изпълнено в този момент, така че новия манипулатор за изпълнение се добавя в края на
			<em>job queue</em> и се извиква, когато е готов. Манипулаторите за отхвърляне работят по същия начин.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Всяко извикване към
					<em>then()</em> или
					<em>catch()</em> създава нова работа за изпълнение, когато
					<em>promise</em> е разрешено. Въпреки това, тази работа в крайна сметка е в отделен
					<em>job queue</em>, който е запазен единствено за
					<em>promises</em>. Точните подробности за този втори
					<em>job queue</em> не са толкова важни за разбирането на това как работят
					<em>promises</em>, както и разбирането на това как
					<em>job queue</em> работят по принцип, като цяло.</strong>
			</dd>
		</dl>
		<h3>Създаване на неопределени
			<em>promises</em>
		</h3>
		<p>Нови
			<em>promises</em> се създават с помощта на
			<em>Promise</em> конструктора. Този конструктор приема един единствен аргумент, който е функция наречена изпълнител (
			<em>executor</em>), съдържаща кода за инициализиране на
			<em>promise</em>. На изпълнителя се подават две функции, като аргументи
			<em>resolve()</em> и
			<em>reject()</em>. Функцията
			<em>resolve()</em> се извиква, когато изпълнителя е приключил успешно, за да сигнализира, че
			<em>promise</em> е готово да бъде
			<em>resolved</em> (разрешено), докато
			<em>reject()</em> функцията показва, че изпълнителя не е успял.</p>
		<p>Ето един пример, който използва
			<em>promise</em> в Node.js за изпълнение на
			<em>readFile()</em> функцията от по-рано в тази глава.</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="comment"><em>// Node.js пример</em></span>

<span class="code">let</span> fs = require("fs");

<span class="code">function</span> readFile(filename) {
    <span class="code">return new</span> Promise(<span class="code">function</span>(resolve, reject) {
        <span class="comment"><em>// задейства асинхронна операция</em></span>
        fs.readFile(filename, { encoding: "utf8" }, <span class="code">function</span>(err, contents) {
            <span class="comment"><em>// проверява за грешки</em></span>
            <span class="code">if</span> (err) {
                reject(err);
            }
            <span class="comment"><em>// четенето успява</em></span>
            resolve(contents);
        });
    });
}

<span class="code">let</span> promise = readFile("example.txt");

<span class="comment"><em>// слуша, както за изпълнение, така и за отхвърляне</em></span>
promise.then(<span class="code">function</span>(contents) {
    <span class="comment"><em> // изпълнение</em></span>
    console.log(contents);
}, <span class="code">function</span>(err) {
    <span class="comment"><em>// отхвърляне</em></span>
    console.error(err.message);
});
			</pre>
			</dd>
		</dl>
		<p>В този пример, асинхронното извикване на натуралния
			<em>Node.js fs.readFile()</em> е увито в едно
			<em>promise</em>. Изпълнителя или подава обект за грешка към функцията
			<em>reject()</em> или съдържанието на файла към функцията
			<em>resolve()</em>.</p>
		<p>Имайте в предвид, че изпълнителя тръгва незабавно, когато се извика
			<em>readFile()</em>. Когато някое от
			<em>resolve()</em> или
			<em>reject()</em> се извика във вътрешността на изпълнителя, работата се добавя към
			<em>job queue</em> в поръчка за разрешаване на
			<em>promise</em>. Това се нарича
			<em>job scheduling</em> (работен график) и ако някога сте използвали
			<em>setTimeout()</em> или
			<em>setInterval()</em> функции, значи сте запознати с него. В работния график новата работа да се добавя в
			<em>job queue</em>, като се казва, “не я изпълнявай точно сега, но я изпълни по-късно". Например,
			<em>setTimeout()</em> функцията позволява да зададете закъснение преди добавяне на работата към
			<em>job queue</em>.</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="comment"><em>// добавяне на тази функция към job queue, след като изминат 500ms </em></span>
setTimeout(<span class="code">function</span>() {
    console.log("Timeout");
}, 500)

console.log("Hi!");
			</pre>
			</dd>
		</dl>
		<p>В този код, работния график се добавя към
			<em>job queue</em> след 500ms. Двете извиквания на
			<em>console.log()</em> извеждат следното:
		</p>
		<dl>
			<dd>
				<pre class="highlight">
				<p>Hi!<br>Timeout</p>
			</pre>
			</dd>
		</dl>
		<p>Благодарение на закъснението от 500ms, изхода на функцията подадена към
			<em>setTimeout()</em> е показан след изхода от извикването на
			<em>console.log("Hi!")</em>.</p>
		<p>
			<em>Promises</em> работят по същия начин. Изпълнителя на
			<em>promise</em> се изпълнява незабавно, преди всичко, като след това се появява в изходния код. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> promise = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    console.log("Promise");
    resolve();
});

console.log("Hi!");
			</pre>
			</dd>
		</dl>
		<p>Изхода на този код е:</p>
		<dl>
			<dd>
				<pre class="highlight">
				<p>Promise <br>Hi!</p>
			</pre>
			</dd>
		</dl>
		<p>Извикването на
			<em>resolve()</em>, задейства асинхронна операция. Функциите подадени към
			<em>then()</em> и
			<em>catch()</em> се използват асинхронно, тъй като те също се добавят към края на
			<em>job queue</em>. Ето един пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> promise = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    console.log("Promise");
    resolve();
});

promise.then(<span class="code">function</span>() {
    console.log("Resolved.");
});

console.log("Hi!");
			</pre>
			</dd>
		</dl>
		<p>Изхода на този пример е:</p>
		<dl>
			<dd>
				<pre class="highlight">
				<p>Promise <br>Hi!<br>Resolved</p>
			</pre>
			</dd>
		</dl>
		<p>Обърнете внимание, че въпреки, че извикването на
			<em>then()</em> се появява преди
			<em>console.log("Hi!")</em>, то всъщност не се изпълнява до по-късно (за разлика от
			<em>executor</em>). Това е, защото манипулаторите за изпълнение и отхвърляне, винаги се добавят към края на
			<em>job queue</em>, след като изпълнителя е завършил.</p>
		<h3>Създаване на уредени
			<em>promises</em>
		</h3>
		<p>
			<em>Promise</em> конструктора е най-добрият начин за създаване на неуредени
			<em>promises</em>, поради динамичния характер на това, което прави изпълнителя на
			<em>promise</em>. Но ако искате
			<em>promise</em> да представлява само една известна стойност, то тогава няма смисъл да минава през работния график за работа,
			който просто подава стойност към
			<em>resolve()</em> функцията. Вместо това има два метода, които създават уредени
			<em>promises</em> с дадена конкретна стойност.</p>
		<h4>Използване Promise.resolve ()</h4>
		<p>Метода
			<em>Promise.resolve()</em> приема един единствен аргумент и връща
			<em>promise</em> в изпълнено състояние. Това означава, че няма работен график, който да се изпълни и трябва да добавите един
			или повече манипулатора работещи с
			<em>promise</em>, за извличане на стойността. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> promise = Promise.resolve(42);

promise.then(<span class="code">function</span>(value) {
    console.log(value);         // 42
});
			</pre>
			</dd>
		</dl>
		<p>Този код създава изпълнено
			<em>promise</em>, така че манипулатора за изпълнение получава стойност 42. Ако се добави манипулатор за отхвърляне към това
			<em>promise</em>, той никога няма да се извика, защото
			<em>promise</em> никога няма да бъде в състояние на отхвърляне.
		</p>
		<h4>Използване Promise.reject ()</h4>
		<p>Можете също да създадете отхвърлени
			<em>promises</em> с помощта на
			<em>Promise.reject()</em> метода. Той работи по същия начин, както
			<em>Promise.resolve()</em> с изключение, на това, че създаденото
			<em>promise</em> е в състояние на отхвърляне, както следва:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> promise = Promise.reject(42);

promise.<span class="code">catch</span>(<span class="code">function</span>(value) {
    console.log(value);         // 42
});
			</pre>
			</dd>
		</dl>
		<p>Всички допълнителни манипулатори за отхвърляне добавени към това
			<em>promise</em> ще бъдат извикани, но не и манипулаторите за изпълнение.
		</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Ако подадем
					<em>promise</em> към
					<em>Promise.resolve()</em> или
					<em>Promise.reject()</em> методите,
					<em>promise</em> се връща без промяна.</strong>
			</dd>
		</dl>
		<h4>Non-Promise Thenables</h4>
		<p>И двата,
			<em>Promise.resolve()</em> и
			<em>Promise.reject()</em> също приемат
			<em>non-promise thenables</em>, като аргументи. Когато подадем
			<em>non-promise thenable</em>, тези методи създават ново
			<em>promise</em>, което се извиква след
			<em>then()</em> функцията.</p>
		<p>
			<em>Non-promise thenable</em> се създава, когато един обект има
			<em>then()</em> метод, който приема два аргумента:
			<em>resolve</em> и
			<em>reject</em>. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> thenable = {
    then: <span class="code">function</span>(resolve, reject) {
        resolve(42);
    }
};
			</pre>
			</dd>
		</dl>
		<p>Обекта
			<em>thenable</em> в този пример, има характеристики свързани с
			<em>promise</em>, различни от
			<em>then()</em> метода. Можете да извикате
			<em>Promise.resolve()</em>, за да превърне
			<em>thenable</em> в изпълнено
			<em>promise</em>:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> thenable = {
    then: <span class="code">function</span>(resolve, reject) {
        resolve(42);
    }
};

<span class="code">let</span> p1 = Promise.resolve(thenable);
p1.then(<span class="code">function</span>(value) {
    console.log(value);     // 42
});
			</pre>
			</dd>
		</dl>
		<p>В този пример,
			<em>Promise.resolve()</em> извиква
			<em>thenable.then()</em>, така че състоянието на
			<em>promise</em> да може да се определи. Състоянието на
			<em>promise</em> за
			<em>thenable</em> е изпълнено, защото
			<em>resolve(42)</em> се извиква вътре в
			<em>then()</em> метода. Новото
			<em>promise</em> наречено
			<em>p1</em> се създава в изпълнено състояние със стойността подадена от
			<em>thenable</em> (т. е. 42), така че манипулатора за изпълнение на
			<em>p1</em> получава 42, като стойност.</p>
		<p>Същият процес може да се използва с
			<em>Promise.resolve()</em>, за да създадете отхвърлено
			<em>promise</em> от
			<em>thenable</em>:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> thenable = {
    then: <span class="code">function</span>(resolve, reject) {
        reject(42);
    }
};

<span class="code">let</span> p1 = Promise.resolve(thenable);
p1.catch(<span class="code">function</span>(value) {
    console.log(value);     // 42
});
			</pre>
			</dd>
		</dl>
		<p>Този пример е подобен на последния с изключение на това, че
			<em>thenable</em> се отхвърля. Когато
			<em>thenable.then()</em> се изпълнява, се създава ново
			<em>promise</em> в отхвърлено състояние със стойност 42. Тази стойност след това се подава към манипулатора за отхвърляне
			на
			<em>p1</em>.</p>
		<p>И двата
			<em>Promise.resolve()</em> и
			<em>Promise.reject()</em> работят по този начин за да може лесно да се работи с
			<em>non-promise thenables</em>. Много библиотеки използват
			<em>thenables</em> още преди
			<em>promise</em> се въведат в ECMAScript 6, така че възможността да се преобразуват
			<em>thenables</em> във форма на
			<em>promise</em> е важно за обратна съвместимост с предишните съществуващи библиотеки. Когато не сте сигурни дали един обект
			е
			<em>promise</em>, подаването на обекта през
			<em>Promise.resolve()</em> или
			<em>Promise.reject()</em> (в зависимост от очаквания резултат) е най-добрия начин за разбиране, защото
			<em>promises</em> просто преминават непроменени.</p>
		<h3>Изпълнител на грешки</h3>
		<p>Ако се хвърли грешка вътре в изпълнителя, след това се извиква манипулатора за отхвърляне на
			<em>promise</em>. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> promise = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    <span class="code">throw new Error</span>("Explosion!");
});

promise.<span class="code">catch</span>(<span class="code">function</span>(error) {
    console.log(error.message);     // "Explosion!"
});		
			</pre>
			</dd>
		</dl>
		<p>В този код, изпълнителя умишлено хвърля грешка. Във всеки изпълнител има скрит
			<em>try-catch</em> блок, така че грешката се улавя и след това се подава на манипулатора за отхвърляне. В този смисъл. предишния
			пример е еквивалентен на този:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="comment"><em>// еквивалентно на предишния пример</em></span>
<span class="code">let</span> promise = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    <span class="code">try</span> {
        <span class="code">throw new Error</span>("Explosion!");
    } <span class="code">catch</span> (ex) {
        reject(ex);
    }
});

promise.<span class="code">catch</span>(<span class="code">function</span>(error) {
    console.log(error.message);     // "Explosion!"
});		
			</pre>
			</dd>
		</dl>
		<p>Изпълнителя държи улавянето на всички хвърлени грешки, за да се опрости този случай на обща употреба, но хвърлена грешка
			в изпълнителя се съобщава, само когато присъства манипулатор за отхвърляне. В противен случай грешката не се съобщава.
			Това стана проблем за програмистите в началото на използването на
			<em>promises</em>, така че в JavaScript средите решиха да се справят с него, чрез използване на куки за улов на отхвърлени
			<em>promises</em>.</p>
		<h3>Global Promise Rejection Handling</h3>
		<p>Един от най-спорните аспекти на
			<em>promises</em> е мълчаливия отказ, което се случва, когато едно
			<em>promise</em> се отхвърли и не разполага с манипулатор за отхвърляне. Някои смятат, че това е най-големия недостатък в
			спецификацията, като това е единствената част на езика JavaScript, която очевидно не прави грешки, когато те се появят.</p>
		<p>Определяне на, дали отхвърленото
			<em>promise</em> е обработено, не е лесно поради естеството на
			<em>promises</em>. Например, да вземем следния пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> rejected = Promise.reject(42);

<span class="comment"><em>// в този момент, отхвърлянето не е обработено</em></span>

<span class="comment"><em>// известно време по-късно...</em></span>
rejected.<span class="code">catch</span>(<span class="code">function</span>(value) {
    <span class="comment"><em>// сега отхвърлянето е обработено</em></span>
    console.log(value);
});
			</pre>
			</dd>
		</dl>
		<p>Можете да извикате
			<em>then()</em> или
			<em>catch()</em> във всеки един момент от време и те да работят правилно независимо от това дали
			<em>promise</em> е уредено или не, което го прави трудно за разбиране, точно кога
			<em>promise</em> ще бъде обработено. В този случай
			<em>promise</em> се отхвърля веднага и не се обработва по-късно.</p>
		<p>Въпреки, че е възможно следващата версия на ECMAScript да се справи с този проблем, браузърите и Node.js са приложили промени
			за справяне с този проблем. Имайте в предвид, че те не са част от спецификацията на ECMAScript 6, но са ценен инструмент
			при използването на
			<em>promises</em>.</p>
		<h3>Node.js Rejection Handling</h3>
		<p>В Node.js, има две събития в
			<em>process</em> обекта, свързани с обработката на отхвърлени
			<em>promises</em>.</p>
		<dl>
			<dd>
				<ul>
					<li>
						<em>unhandledRejection</em>- излъчва при отхвърлено
						<em>promise</em> и няма манипулатор за отхвърляне, извикан в рамките на един контур на цикъл на събитие</li>
					<li>
						<em>rejectionHandled</em>- излъчва при отхвърлено
						<em>promise</em> и има манипулатор за отхвърляне, извикано в рамките на един контур на цикъл на събитие</li>
				</ul>
			</dd>
		</dl>
		<p>Тези две събития са проектирани да работят заедно, за подпомагане на идентифициране на
			<em>promises</em>, които са отхвърлени и не се обработват.</p>
		<p>На манипулатора на събитието
			<em>unhandledRejection</em> се подава причина за отхвърлянето (често обекта на грешка) и
			<em>promise</em>, което е отхвърлено. Следният код показва
			<em>unhandledRejection</em> в действие:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> rejected;

process.on("unhandledRejection", <span class="code">function</span>(reason, promise) {
    console.log(reason.message);            // "Explosion!"
    console.log(rejected === promise);      // true
});

rejected = Promise.reject(<span class="code">new Error</span>("Explosion!"));	
			</pre>
			</dd>
		</dl>
		<p>Този пример, създава отхвърлено
			<em>promise</em> с обекта на грешка и слуша за
			<em>unhandledRejection</em> събитието. Манипулатора на събитието получава обект на грешка, като първи аргумент и
			<em>promise</em>, като втори.</p>
		<p>Манипулатора на събитието
			<em>rejectionHandled</em> получава само един аргумент, който е
			<em>promise</em>, което е отхвърлено. Например:
		</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> rejected;

process.on("rejectionHandled", <span class="code">function</span>(promise) {
    console.log(rejected === promise);              // true
});

rejected = Promise.reject(<span class="code">new Error</span>("Explosion!"));

<span class="comment"><em>// изчаква добавяне на манипулатора за отхвърляне</em></span>
setTimeout(<span class="code">function</span>() {
    rejected.<span class="code">catch</span>(<span class="code">function</span>(value) {
        console.log(value.message);     // "Explosion!"
    });
}, 1000);			
			</pre>
			</dd>
		</dl>
		<p>Тука,
			<em>rejectionHandled</em> събитието се излъчва, когато манипулатора за отхвърляне се извика най-накрая. Ако манипулатора за
			отхвърляне е прикрепен непосредствено след създаването на
			<em>rejected</em>, събитието няма да бъде излъчено. Манипулатора за отхвърляне се извиква по същото време с контура на цикъла
			на събитието, в което
			<em>rejected</em> е създаден, което не е позволено.</p>
		<p>За правилно проследяване на потенциално необработени отхвърляния, използвайте
			<em>unhandledRejection</em> и
			<em>rejectionHandled</em> събитията, за да се поддържа списък на потенциално необработените отхвърляния. След това изчакайте
			известен период от време, за да се запознаят със списъка. Например:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">let</span> possiblyUnhandledRejections = <span class="code">new</span> Map();

<span class="comment"><em>// когато, отхвърлянето е необработено го добавяме в map</em></span>
process.on("unhandledRejection", <span class="code">function</span>(reason, promise) {
    possiblyUnhandledRejections.set(promise, reason);
});

process.on("rejectionHandled", <span class="code">function</span>(promise) {
    possiblyUnhandledRejections.delete(promise);
});

setInterval(<span class="code">function</span>() {

    possiblyUnhandledRejections.forEach(<span class="code">function</span>(reason, promise) {
        console.log(reason.message ? reason.message : reason);

        <span class="comment"><em>// направи нещо за да се справят с тези отхвърляния</em></span>
        handleRejection(promise, reason);
    });

    possiblyUnhandledRejections.clear();

}, 60000);
			</pre>
			</dd>
		</dl>
		<p>Този код е просто необработено отхвърляне на
			<em>tracker</em>. Той използва
			<em>map</em> за съхраняване на
			<em>promises</em> и причините за тяхното отхвърляне. Всяко
			<em>promise</em> е ключ и причината за тази стойност. Всеки път, когато
			<em>unhandledRejection</em> излъчва,
			<em>promise</em> и неговата причина за отхвърляне, се добавят към
			<em>map</em>. Всеки път, когато
			<em>rejectionHandled</em> излъчва, обработеното
			<em>promise</em> се отстранява от
			<em>map</em>. В резултат на това,
			<em>possiblyUnhandledRejections</em> расте и да се свива при всяко извикване на събитие. Извикването на
			<em>setInterval()</em> периодично проверява списъка на възможните необработени отхвърляния и извежда информацията в конзолата
			(в действителност, вероятно ще искате да направите нещо друго, да влезете или по някакъв друг начин да се справите с отхвърлянето).
			В този пример използваме
			<em>map</em> вместо
			<em>weak map</em>, защото трябва да се запознаят с
			<em>map</em> периодично и да видят кои
			<em>promises</em> са налице, което не е възможно с
			<em>weak map</em>.</p>
		<p>Докато този пример е специфичен за Node.js, браузърите също прилагат подобен механизъм за съобщаване на програмистите за
			необработени отхвърляния.</p>
		<h3>Browser Rejection Handling</h3>
		<p>Браузърите също излъчват две събития, за подпомагане на идентифицирането на необработени отхвърляния. Тези събития се излъчват
			от
			<em>window</em> обекта и са ефективно същите еквиваленти, като на Node.js:</p>
		<dl>
			<dd>
				<ul>
					<li>
						<em>unhandledrejection</em>- излъчва при отхвърлено
						<em>promise</em> и няма манипулатор за отхвърляне, извикан в рамките на един контур на цикъл на събитие</li>
					<li>
						<em>rejectionhandled</em>- излъчва при отхвърлено
						<em>promise</em> и има манипулатор за отхвърляне, извикан в рамките на един контур на цикъл на събитие</li>
				</ul>
			</dd>
		</dl>
		<p>Докато прилагането на Node.js подава индивидуални параметри към манипулатора на събитието, манипулатора на събитие за тези
			събития получава обект на събитие със следните свойства:</p>
		<dl>
			<dd>
				<ul>
					<li>
						<em>type</em> - името на събитието ("unhandledrejection" или "rejectionhandled")</li>
					<li>
						<em>promise</em> - обекта на
						<em>promise</em>, което е било отхвърлено</li>
					<li>
						<em>reason</em> - стойността на отхвърляне от
						<em>promise</em>
					</li>
				</ul>
			</dd>
		</dl>
		<p>Друга разлика в изпълнението на браузъра е, че стойността на отхвърляне (
			<em>reason</em>) е разположение за двете събития. Например:
		</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">let</span> rejected;

<span class="code">window</span>.onunhandledrejection = <span class="code">function</span>(event) {
    console.log(event.type);                    // "unhandledrejection"
    console.log(event.reason.message);          // "Explosion!"
    console.log(rejected === event.promise);    // true
};

<span class="code">window</span>.onrejectionhandled = <span class="code">function</span>(event) {
    console.log(event.type);                    // "rejectionhandled"
    console.log(event.reason.message);          // "Explosion!"
    console.log(rejected === event.promise);    // true
};

rejected = Promise.reject(<span class="code">new Error</span>("Explosion!"));			
		    </pre>
			</dd>
		</dl>
		<p>Този код възлага на двата манипулатора на събития да използват DOM Level 0 нотация за
			<em>onunhandledrejection</em> и
			<em>onrejectionhandled</em> (можете също да използвате
			<em>addEventListener</em>("unhandledrejection") и
			<em>addEventListener</em>("rejectionhandled") ако предпочитате). Всеки манипулатор получава обект на събитие, съдържащ информация
			за отхвърленото
			<em>promise</em>. Всички три свойства
			<em>type, promise</em> и
			<em>reason</em>, са на разположение и в двата манипулатора на събития.</p>
		<p>Кода, който следи за необработени отхвърляния в браузъра е много подобен на кода за Node.js:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">let</span> possiblyUnhandledRejections = <span class="code">new</span> Map();

<span class="comment"><em>// когато отхвърлянето е необработено, го добавяме в map</em></span>
<span class="code">window</span>.onunhandledrejection = <span class="code">function</span>(event) {
    possiblyUnhandledRejections.set(event.promise, event.reason);
};

<span class="code">window</span>.onrejectionhandled = <span class="code">function</span>(event) {
    possiblyUnhandledRejections.<span class="code">delete</span>(event.promise);
};

setInterval(<span class="code">function</span>() {

    possiblyUnhandledRejections.forEach(<span class="code">function</span>(reason, promise) {
        console.log(reason.message ? reason.message : reason);

        <span class="comment"><em>// направи нещо за да се справят с тези отхвърляния</em></span>
        handleRejection(promise, reason);
    });

    possiblyUnhandledRejections.clear();

}, 60000);	
		    </pre>
			</dd>
		</dl>
		<p>Това изпълнение е почти точно същото, като изпълнението на Node.js. Той използва същия подход на съхраняване на
			<em>promises</em> и техните стойности за отхвърляне в
			<em>map</em> и след това ги инспектира по-късно. Единствената разлика е, когато информацията се извлича от манипулаторите
			на събитието.</p>
		<p>Обработката на отхвърлени
			<em>promise</em> може да бъде трудна, но вие току що започнахте да виждате, колко мощни наистина могат да бъдат
			<em>promises</em>. Сега е време да предприемем следващата стъпка - верига от няколко
			<em>promises</em> заедно.</p>
		<h3>Верижни
			<em>promises</em>
		</h3>
		<p>До този момент
			<em>promises</em> може да изглеждат, като малко повече от частично подобрение с помощта на някаква комбинация от извикване
			и
			<em>setTimeout()</em> функцията, но има много повече за
			<em>promises</em>, от колкото виждаме. По-специално има редица начини за верига от
			<em>promises</em> заедно, за постигане на по-сложно асинхронно поведение.</p>
		<p>Всяко извикване на
			<em>then()</em> или
			<em>catch()</em> всъщност създава и връща друго
			<em>promise</em>. Това второ
			<em>promise</em> е разрешено само, след като първото е изпълнено или отхвърлено. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> p1 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(42);
});

p1.then(<span class="code">function</span>(value) {
    console.log(value);
}).then(<span class="code">function</span>() {
    console.log("Finished");
});
			</pre>
			</dd>
		</dl>
		<p>Резултата от този пример е:</p>
		<dl>
			<dd>
				<pre class="highlight">
				<p>42 <br>Finished</p>
			</pre>
			</dd>
		</dl>
		<p>Извикването към
			<em>p1.then()</em> връща второ
			<em>promise</em>, върху което се извиква
			<em>then()</em>. Манипулатора за изпълнение на втория
			<em>then()</em> се извиква само, след като първото
			<em>promise</em> е разрешено. Ако се освободим от този пример, това изглежда така:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> p1 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(42);
});

<span class="code">let</span> p2 = p1.then(<span class="code">function</span>(value) {
    console.log(value);
})

p2.then(<span class="code">function</span>() {
    console.log("Finished");
}); 
        </pre>
			</dd>
		</dl>
		<p>В тази свободна версия на кода, резултат на
			<em>p1.then()</em> се съхранява в
			<em>p2</em>, след това
			<em>p2.then()</em> се извиква за да добави манипулатор за окончателното изпълнение. Както може би се досещате,
			<em>p2.then()</em> също връща
			<em>promise</em>. Този пример просто не използва това
			<em>promise</em>.</p>
		<h3>Прихващане на грешки</h3>
		<p>Верижните
			<em>promises</em> ни позволяват да улавяме грешки, които могат да възникнат по време на изпълнение или при манипулатора за
			отхвърляне от предишното
			<em>promise</em>. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> p1 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(42);
});

p1.then(<span class="code">function</span>(value) {
    throw new Error("Boom!");
}).catch(<span class="code">function</span>(error) {
    console.log(error.message);     // "Boom!"
});
			</pre>
			</dd>
		</dl>
		<p>В този пример, манипулатора за изпълнение за
			<em>p1</em> хвърля грешка. Верижното извикване към
			<em>catch()</em> метода, който е във второто
			<em>promise</em>, може да получи тази грешка, чрез манипулатора за отхвърляне. Същото важи и ако един манипулатор за отхвърляне
			хвърли грешка:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> p1 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    <span class="code">throw new Error</span>("Explosion!");
});

p1.<span class="code">catch</span>(<span class="code">function</span>(error) {
    console.log(error.message);     // "Explosion!"
    <span class="code">throw new Error</span>("Boom!");
}).<span class="code">catch</span>(<span class="code">function</span>(error) {
    console.log(error.message);     // "Boom!"
});
			</pre>
			</dd>
		</dl>
		<p>Тука, изпълнителя хвърля грешка, след това задейства манипулатора за отхвърляне на
			<em>p1</em>. Този манипулатор после хвърля друга грешка, която е уловена от манипулатора на второто отхвърлено
			<em>promise</em>. По този начин оковани извикванията на
			<em>promises</em> могат да бъдат информирани за грешки в други
			<em>promises</em> по веригата.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Винаги има манипулатор за отхвърляне в края на веригата от
					<em>promises</em>, за да се гарантира, че могат правилно да се справят с всички грешки, които могат да възникнат.</strong>
			</dd>
		</dl>
		<h3>Връщане на стойност във верига от
			<em>promises</em>
		</h3>
		<p>Друг важен аспект на веригите от
			<em>promises</em> е способноста да се подават данни от едно
			<em>promise</em> към следващото. Вече видяхте, че стойността подадена към манипулатора
			<em>resolve()</em> вътре в изпълнителя, се подава към манипулатора за изпълнение на това
			<em>promise</em>. Можете да продължите подаването на данни по веригата, като посочите стойност за връщане от манипулатора
			за изпълнение. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> p1 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(42);
});

p1.then(<span class="code">function</span>(value) {
    console.log(value);         // "42"
    <span class="code">return</span> value + 1;
}).then(<span class="code">function</span>(value) {
    console.log(value);         // "43"
});
			</pre>
			</dd>
		</dl>
		<p>В този пример, манипулатора за изпълнение на
			<em>p1</em> връща стойност
			<em>(value + 1)</em>, когато бъде изпълнен. Тъй като
			<em>value</em> е 42 (от изпълнителя), манипулатора за изпълнение връща 43. Тази стойност след това се подава към манипулатора
			за изпълнение на второто
			<em>promise</em>, което го извежда на конзолата.</p>
		<p>Същото нещо е възможно с помощта на манипулатора за отхвърляне. Когато един манипулатор за отхвърляне се извика, той може
			да върне стойност. Тази стойност след това се използва, за да изпълни следващото
			<em>promise</em> във веригата. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> p1 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    reject(42);
});

p1.<span class="code">catch</span>(<span class="code">function</span>(value) {
    <span class="comment"><em>// първи манипулатор за изпълнение</em></span>
    console.log(value);         // "42"
    <span class="code">return</span> value + 1;
}).then(<span class="code">function</span>(value) {
    <span class="comment"><em>// втори манипулатор за изпълнение</em></span>
    console.log(value);         // "43"
});
			</pre>
			</dd>
		</dl>
		<p>Тука, изпълнителя извиква
			<em>reject()</em> с 42. Тази стойност се подава в манипулатора за отхвърляне на
			<em>promise</em>, където се връща
			<em>value + 1</em>. Въпреки, че тази върната стойност идва от манипулатора за отхвърляне, тя все още може да се използва в
			манипулатора за изпълнение на следващото
			<em>promise</em> във веригата. Това дава възможност на провала на едно
			<em>promise</em> да позволи възстановяване на цялата верига при необходимост.</p>
		<h3>Връщане на
			<em>promises</em> от вериги с
			<em>promises</em>
		</h3>
		<p>Връщането на примитивни стойности от манипулатора за изпълнение и отхвърляне, позволява прехвърляне на данни между
			<em>promises</em>, но какво става ако върне обект? Ако обекта е
			<em>promise</em>, има една допълнителна стъпка, която трябва да бъде взета, за да се определи, как да се процедира. Да разгледаме
			следния пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> p1 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(42);
});

<span class="code">let</span> p2 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(43);
});

p1.then(<span class="code">function</span>(value) {
    <span class="comment"><em>// първи манипулатор за изпълнение</em></span>
    console.log(value);     // 42
    <span class="code">return</span> p2;
}).then(<span class="code">function</span>(value) {
    <span class="comment"><em>// втори манипулатор за изпълнение</em></span>
    console.log(value);     // 43
});
			</pre>
			</dd>
		</dl>
		<p>В този код, работния график на
			<em>p1</em> разрешава 42. Манипулатора за изпълнение на
			<em>p1</em> връща
			<em>p2</em>,
			<em>promise</em> вече е в разрешено състояние. Втория манипулатор за изпълнение се извиква, защото
			<em>p2</em> е бил изпълнен. Ако
			<em>p2</em> се отхвърли, ще се извика манипулатор за отхвърляне (ако има такъв) вместо втория манипулатор за изпълнение.</p>
		<p>Важно е да се признае за този модел, че втория манипулатор за изпълнение не се добавя към
			<em>p2</em>, а по-скоро към трето
			<em>promise</em>. Следователно втория манипулатор за изпълнение е приложен към третото
			<em>promise</em>. Предишния пример е еквивалентен на това:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> p1 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(42);
});

<span class="code">let</span> p2 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(43);
});

<span class="code">let</span> p3 = p1.then(<span class="code">function</span>(value) {
    <span class="comment"><em>// първи манипулатор за изпълнение</em></span>
    console.log(value);     // 42
    <span class="code">return</span> p2;
});

p3.then(<span class="code">function</span>(value) {
    <span class="comment"><em>// втори манипулатор за изпълнение</em></span>

    console.log(value);     // 43
});
			</pre>
			</dd>
		</dl>
		<p>От това става ясно, че втория манипулатор за изпълнение е приложен към
			<em>p3</em>, а не към
			<em>p2</em>. Това е малка, но важна разлика, тъй като втория манипулатор за изпълнение не се извиква, ако
			<em>p2</em> се отхвърли. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> p1 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(42);
});

<span class="code">let</span> p2 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    reject(43);
});

p1.then(<span class="code">function</span>(value) {
    <span class="comment"><em>// първи манипулатор за изпълнение</em></span>
    console.log(value);     // 42
    <span class="code">return</span> p2;
}).then(<span class="code">function</span>(value) {
        <span class="comment"><em>// втори манипулатор за изпълнение</em></span>

    console.log(value);     <span class="comment"><em>// никога не се извиква</em></span>
});
			</pre>
			</dd>
		</dl>
		<p>В този пример, втория манипулатор за изпълнение никога не се извиква, защото
			<em>p2</em> се отхвърля. Може обаче да се добави манипулатор за отхвърляне, вместо него:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> p1 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(42);
});

<span class="code">let</span> p2 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    reject(43);
});

p1.then(<span class="code">function</span>(value) {
    <span class="comment"><em>// първи манипулатор за изпълнение</em></span>
    console.log(value);     // 42
    <span class="code">return</span> p2;
}).<span class="code">catch</span>(<span class="code">function</span>(value) {
    <span class="comment"><em>// манипулатор за отхвърляне</em></span>
    console.log(value);     // 43
});
			</pre>
			</dd>
		</dl>
		<p>Тука, манипулатора за отхвърляне се извиква в резултат на отхвърлянето на
			<em>p2</em>. Отхвърлената стойност 43 от
			<em>p2</em> е подадена в манипулатора за отхвърляне.</p>
		<p>Върнатата
			<em>thenables</em> от манипулатора за изпълнение и отхвърляне не се променя, когато се изпълняват изпълнителите на
			<em>promise</em>. Първото дефинирано
			<em>promise</em> ще изпълни своя изпълнител първо, последван от изпълнителя на второто
			<em>promise</em> и т.н. Върнатите
			<em>thenables</em> просто ви позволяват допълнителни отговори към резултатите на
			<em>promise</em>. Може да се отложи изпълнението на манипулатора за изпълнение, чрез създаване на ново
			<em>promise</em> в рамките на манипулатора за изпълнение. Например:
		</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> p1 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(42);
});

p1.then(<span class="code">function</span>(value) {
    console.log(value);     // 42

    <span class="comment"><em>// създаване на ново <em>promise</em></em></span>
    <span class="code">let</span> p2 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
        resolve(43);
    });

    <span class="code">return</span> p2
}).then(<span class="code">function</span>(value) {
    console.log(value);     // 43
});
			</pre>
			</dd>
		</dl>
		<p>В този пример, се създава ново
			<em>promise</em> в рамките на манипулатора за изпълнение на
			<em>p1</em>. Това означава, че манипулатора на второто изпълнение няма да се изпълни, докато
			<em>p2</em> не е изпълнено. Този модел е полезен, когато искате да изчакате предното
			<em>promise</em> да се уреди, преди да задействате друго
			<em>promise</em>.</p>
		<h3>Отговор на множество
			<em>promises</em>
		</h3>
		<p>До този момент, всеки пример тази глава се е занимавал с отговора на едно
			<em>promise</em> в даден момент. Има моменти обаче, когато ще искате да следите развитието на множество
			<em>promises</em>, за да се определи следващото действие. ECMAScript 6 предвижда два метода, които да следят множество
			<em>promises</em>:
			<em>Promise.all()</em> и
			<em>Promise.race()</em>.</p>
		<h3>Метода Promise.all()</h3>
		<p>Метода
			<em>Promise.all()</em> приема един аргумент, който е
			<em>iterable</em> (също като
			<em>array</em>) на
			<em>promises</em> за наблюдение и връща
			<em>promise</em>, което е разрешено само, когато всяко
			<em>promise</em> в
			<em>iterable</em> е разрешено. Върнатото
			<em>promise</em> е изпълнено, когато се изпълни всяко
			<em>promise</em> в
			<em>iterable</em>, например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> p1 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(42);
});

<span class="code">let</span> p2 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(43);
});

<span class="code">let</span> p3 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(44);
});

<span class="code">let</span> p4 = Promise.all([p1, p2, p3]);

p4.then(<span class="code">function</span>(value) {
    console.log(<span class="code">Array</span>.isArray(value));  // true
    console.log(value[0]);              // 42
    console.log(value[1]);              // 43
    console.log(value[2]);              // 44
});
			</pre>
			</dd>
		</dl>
		<p>Всяко от
			<em>promises</em> в този пример разрешава номер. Извикването на
			<em>Promise.all()</em> създава ново
			<em>promise</em>
			<em>p4</em>, което в крайна сметка е изпълнено, когато всички
			<em>promises</em> са изпълнени. Резултата подаден към манипулатора за изпълнение на
			<em>p4</em> е
			<em>array</em>, съдържащ всички разрешени стойности: 42, 43 и 44. Стойностите се съхраняват по реда решените
			<em>promises</em>, така могат да се сравнят резултатите на
			<em>promises</em> с
			<em>promises</em>, които ги решават.</p>
		<p>Ако някое от
			<em>promises</em> подадени към
			<em>Promise.all()</em> е отхвърлено, върнатото
			<em>promise</em> се отхвърля незабавно, без да чака другите
			<em>promises</em> да завършат:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> p1 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(42);
});

<span class="code">let</span> p2 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    reject(43);
});

<span class="code">let</span> p3 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(44);
});

<span class="code">let</span> p4 = Promise.all([p1, p2, p3]);

p4.<span class="code">catch</span>(<span class="code">function</span>(value) {
    console.log(<span class="code">Array</span>.isArray(value))   // false
    console.log(value);                 // 43
});
			</pre>
			</dd>
		</dl>
		<p>В този пример,
			<em>p2</em> се отхвърля със стойност 43. Манипулатора за отхвърляне на
			<em>p4</em> се извиква веднага, без да чака
			<em>p1</em> или
			<em>p3</em> да завършат изпълнението (те все още завършват изпълнението, просто
			<em>p4</em> не чака).
		</p>
		<p>Манипулатора за отхвърляне винаги получава една стойност, а не
			<em>array</em>, стойността е стойността на отхвърляне от
			<em>promise</em>, което е отхвърлено. В този случай, манипулатора за отхвърляне подава 43, за да отрази отхвърлянето от
			<em>p2</em>.</p>
		<h3>Метода Promise.race()</h3>
		<p>Метода
			<em>Promise.race()</em> осигурява малко по-различен поглед върху наблюдението на множество
			<em>promises</em>. Този метод също приема
			<em>iterable</em> на
			<em>promises</em> за наблюдение и връща
			<em>promise</em>, обаче, върнатото
			<em>promise</em> е уредено веднага, след като е уредено първото
			<em>promise</em>. Вместо да чака всички
			<em>promises</em> да бъдат изпълнени, както в
			<em>Promise.all()</em> метода, метода
			<em>Promise.race()</em> връща съответното
			<em>promise</em> веднага, след като някое от
			<em>promises</em> е изпълнено в
			<em>array</em>. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> p1 = Promise.resolve(42);

<span class="code">let</span> p2 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(43);
});

<span class="code">let</span> p3 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(44);
});

<span class="code">let</span> p4 = Promise.race([p1, p2, p3]);

p4.then(<span class="code">function</span>(value) {
    console.log(value);     // 42
});
			</pre>
			</dd>
		</dl>
		<p>В този код,
			<em>p1</em> е създаден, като изпълнено
			<em>promise</em>, докато другите са в работния график. Манипулатора за изпълнение на
			<em>p4</em> се извиква после със стойност 42 и игнорира останалите
			<em>promises</em> напълно.
			<em>Promises</em> подадени към
			<em>Promise.race()</em> наистина участват в състезанието, за да се види, кое е уредено първо. Ако е изпълнено първото
			<em>promise</em> за уреждане, после върнатото
			<em>promise</em> е изпълнено, ако първото
			<em>promise</em> за уреждане е отхвърлено, тогава върнатото
			<em>promise</em> се отхвърля. Ето един пример с отхвърляне:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> p1 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(42);
});

<span class="code">let</span> p2 = Promise.reject(43);

<span class="code">let</span> p3 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(44);
});

<span class="code">let</span> p4 = Promise.race([p1, p2, p3]);

p4.<span class="code">catch</span>(<span class="code">function</span>(value) {
    console.log(value);     // 43
});
			</pre>
			</dd>
		</dl>
		<p>Тука,
			<em>p4</em> се отхвърля, защото
			<em>p2</em> е вече в отхвърлено състояние, когато
			<em>Promise.race()</em> се извиква. Въпреки, че
			<em>p1</em> и
			<em>p3</em> са изпълнени, техните резултати са игнорирани, тъй като те се появяват, след като
			<em>p2</em> се отхвърли.</p>
		<h3>Наследяване от
			<em>promises</em>
		</h3>
		<p>Също като другите вградени типове, можете да използвате
			<em>promises</em>, като база за извлечен клас. Това ви позволява да определите свой вариант на
			<em>promises</em>, за разширяване на това, което вградените
			<em>promises</em> могат да направят. Да предположим, че искате да създадте едно
			<em>promise</em>, което използва
			<em>success()</em> и
			<em>failure()</em> в допълнение към
			<em>then()</em> и
			<em>catch()</em> методите. Можте да го направите, както следва:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">class</span> MyPromise <span class="code">extends</span> Promise {

    <span class="comment"><em>// използва default конструктор</em></span>

    success(resolve, reject) {
        <span class="code">return this</span>.then(resolve, reject);
    }

    failure(reject) {
        <span class="code">return this.catch</span>(reject);
    }

}

<span class="code">let</span> promise = <span class="code">new</span> MyPromise(<span class="code">function</span>(resolve, reject) {
    resolve(42);
});

promise.success(<span class="code">function</span>(value) {
    console.log(value);             // 42
}).failure(<span class="code">function</span>(value) {
    console.log(value);
});
			</pre>
			</dd>
		</dl>
		<p>В този пример,
			<em>MyPromise</em> произлиза от
			<em>Promise</em> и има два допълнителни метода.
			<em>success()</em> имитира метода
			<em>resolve()</em> и
			<em>failure()</em> имитира
			<em>reject()</em> метода.</p>
		<p>И двата,
			<em>success()</em> и
			<em>failure()</em> използват
			<em>this</em> за извикване на методa, който имитират. Полученото
			<em>promise</em> функционира също, като вграденото
			<em>promise</em>, освен че сега може да извикате
			<em>success()</em> и
			<em>failure()</em> ако искате.</p>
		<p>Тъй като, статичните методи са наследени, това означава, че
			<em>MyPromise.resolve(), MyPromise.reject(), MyPromise.race()</em> и
			<em>MyPromise.all()</em> методите, също присъстват в получените
			<em>promises</em>. Докато последните два метода се държат също, като вградените методи, първите два са малко по-различни.</p>
		<p>И двата
			<em>MyPromise.resolve()</em> и
			<em>MyPromise.reject()</em> ще върнат инстанция на
			<em>MyPromise</em> независимо от подадената стойност, защото използват
			<em>Symbol.species</em> свойството (виж
			<a href="09_classes.html">Глава 9</a>) за да определят вида на
			<em>promise</em> за връщане. Така, че ако вграденото
			<em>promise</em> се подаде на двата метода, то ще бъде разрешено или отхвърлено и върнато в нов
			<em>MyPromise</em>, така че да може да се присвои от манипулатора за изпълнение и отхвърляне. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> p1 = <span class="code">new</span> Promise(<span class="code">function</span>(resolve, reject) {
    resolve(42);
});

<span class="code">let</span> p2 = MyPromise.resolve(p1);
p2.success(<span class="code">function</span>(value) {
    console.log(value);         // 42
});

console.log(p2 <span class="code">instanceof</span> MyPromise);   // true
			</pre>
			</dd>
		</dl>
		<p>Тука,
			<em>p1</em> е вградено
			<em>promise</em>, което се подава на
			<em>MyPromise.resolve()</em>. Резултата
			<em>p2</em> е инстанция на
			<em>MyPromise</em>, където стойността разрешена от
			<em>p1</em> е подадена в манипулатора за изпълнение.</p>
		<p>Ако една инстанция на
			<em>MyPromise</em> се подаде към
			<em>MyPromise.resolve()</em> или
			<em>MyPromise.reject()</em>, тя просто ще бъде върната директно без да бъде разрешена. Във всички други случаи, тези два метода
			се държат също, като
			<em>Promise.resolve()</em> и
			<em>Promise.reject()</em>.</p>
		<h3>Asynchronous Task Running</h3>
		<p>
			<a href="08_iterators_and_generators.html">Глава 8</a>, въвежда генератори и ви показва как можете да ги използвате за асинхронни
			<em>task running</em>, като този:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> fs = require("fs");

<span class="code">function</span> run(taskDef) {

    <span class="comment"><em>// създаване на итератор, предоставен на друго място</em></span>
    <span class="code">let</span> task = taskDef();

    <span class="comment"><em>// начало на задачата</em></span>
    <span class="code">let</span> result = task.next();

    <span class="comment"><em>// рекурсивна функция, която държи извикванията към next()</em></span>
    <span class="code">function</span> step() {

        <span class="comment"><em>// ако има още нещо за правене</em></span>
        <span class="code">if</span> (!result.done) {
            <span class="code">if</span> (<span class="code">typeof</span> result.value === "function") {
                result.value(<span class="code">function</span>(err, data) {
                    <span class="code">if</span> (err) {
                        result = task.<span class="code">throw</span>(err);
                        <span class="code">return</span>;
                    }

                    result = task.next(data);
                    step();
                });
            } <span class="code">else</span> {
                result = task.next(result.value);
                step();
            }
        }
    }

    <span class="comment"><em>// стартиране на процеса</em></span>
    step();

}

<span class="comment"><em>// Дефиниране на функция за използване на task runner</em></span>

<span class="code">function</span> readFile(filename) {
    <span class="code">return function</span>(callback) {
        fs.readFile(filename, callback);
    };
}

<span class="comment"><em>// Пускане на задачата</em></span>

run(<span class="code">function</span>*() {
    <span class="code">let</span> contents = <span class="code">yield</span> readFile("config.json");
    doSomethingWith(contents);
    console.log("Done");
});
			</pre>
			</dd>
		</dl>
		<p>Има някои болни точки в това изпълнение. Първо, опаковането на всяка функция във функция, която връща функция е малко объркващо
			(дори това изречение е объркващо). Второ, няма начин да се направи разлика между върнатата стойност от функция, предназначена
			за обраното извикване на
			<em>task runner</em> и върнатата стойност, която не е за обратно извикване.</p>
		<p>С
			<em>promises</em>, може значително да се опрости и обобщи този процес, като се гарантира, че всяка асинхронна операция връща
			<em>promise</em>. Този общ интерфейс означава, че може значително да се опрости асинхронния код. Ето един начин, с който бихте
			могли да опростите този
			<em>task runner</em>:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> fs = require("fs");

<span class="code">function</span> run(taskDef) {

    <span class="comment"><em>// създаване на итератор</em></span>
    <span class="code">let</span> task = taskDef();

    <span class="comment"><em>// начало на задачата</em></span>
    <span class="code">let</span> result = task.next();

    <span class="comment"><em>// рекурсивна функция за обхождане</em></span>
    (<span class="code">function</span> step() {

        <span class="comment"><em>// ако има още нещо за правене</em></span>
        <span class="code">if</span> (!result.done) {

            <span class="comment"><em>// разрешаване на <em>promise</em> за лесно правене</em></span>
            <span class="code">let</span> promise = Promise.resolve(result.value);
            promise.then(<span class="code">function</span>(value) {
                result = task.next(value);
                step();
            }).<span class="code">catch</span>(<span class="code">function</span>(error) {
                result = task.<span class="code">throw</span>(error);
                step();
            });
        }
    }());
}

<span class="comment"><em>// Дефиниране на функция за използване на task runner</em></span>

<span class="code">function</span> readFile(filename) {
    <span class="code">return new</span> Promise(<span class="code">function</span>(resolve, reject) {
        fs.readFile(filename, <span class="code">function</span>(err, contents) {
            <span class="code">if</span> (err) {
                reject(err);
            } <span class="code">else</span> {
                resolve(contents);
            }
        });
    });
}

<span class="comment"><em>// Стартиране на задачата</em></span>

run(<span class="code">function</span>*() {
    <span class="code">let</span> contents = <span class="code">yield</span> readFile("config.json");
    doSomethingWith(contents);
    console.log("Done");
});
			</pre>
			</dd>
		</dl>
		<p>В тази версия на кода, функцията
			<em>run()</em> изпълнява генератор за създаване на итератор. Той извиква
			<em>task.next()</em> да стартиране на задачата и рекурсивно извиква
			<em>step()</em> докато итератора завърши.</p>
		<p>Вътре в
			<em>step()</em> функцията, ако има още работа за вършене
			<em>result.done</em> е
			<em>false</em>. В този момент
			<em>result.value</em> трябва да бъде
			<em>promise</em>, но
			<em>Promise.resolve()</em> се използва само в случай, че въпросната функция не върне
			<em>promise</em>. (Не забравяйте, че
			<em>Promise.resolve()</em> само преминава през всяко
			<em>promise</em>, което и е подадено и ще обвие всяко не-
			<em>promise</em> в
			<em>promise</em>). После, се добавя манипулатор за изпълнение, който извлича стойността от
			<em>promise</em> и я подава обратно към итератора. След това,
			<em>result</em> присвоява следващия добит резултат преди самоизвикването на
			<em>step()</em>.</p>
		<p>Манипулатор за отхвърляне съхранява всички отхвърлени резултати в обект за грешка. Метода
			<em>task.throw()</em> подава този обект за грешка обратно в итератора и ако е уловена грешка в задачата,
			<em>result</em> присвоява следващия добит резултат. Накрая, се извиква
			<em>step()</em> вътре в
			<em>catch()</em>, за да продължи.</p>
		<p>Тази функция
			<em>run()</em> може да работи с всеки генератор, който използва
			<em>yield</em>, като начин за използване на асинхронен код без да показва
			<em>promises</em> (или обратни извиквания) на програмиста. В действителност, тъй като върнатата стойност от извикването на
			функция винаги се преобразува в
			<em>promise</em>, функцията може да върне нещо различно от
			<em>promise</em>. Това означава, че можем да използваме синхронни и асинхронни методи, които да работят правилно, когато са
			извикани посредством
			<em>yield</em> и ние никога не трябва да проверяваме дали върнатата стойност е
			<em>promise</em>.</p>
		<p>Единствената грижа е да се гарантира, че асинхронни функции, като
			<em>readFile()</em>, връщайки
			<em>promise</em>, правилно индентифицират състоянието му. За вградени методи на Node.js, означава, че трябва да се преобразуват
			тези методи, за да връщат
			<em>promises</em>, вместо да използват обратни извиквания.</p>
		<div class="aside">
			<h3>Future Asynchronous Task Running</h3>
			<p>По време на моето писане, е в ход работата по привеждане на по-прост синтаксис за асинхронни
				<em>task runner</em> в JavaScript. Напредва работата по
				<em>await</em> синтаксиса, които ще е огледален на базирания на
				<em>promises</em> пример от предходния раздел. Основната идея е да се използва функция маркирана с
				<em>async</em> вместо генератор и използва
				<em>await</em> вместо
				<em>yield</em> при извикване на функция, като например:</p>
			<pre class="highlight">
(async <span class="code">function</span>() {
    <span class="code">let</span> contents = await readFile("config.json");
    doSomethingWith(contents);
    console.log("Done");
});
	  	</pre>
			<p>Ключовата дума
				<em>async</em> преди
				<em>function</em> показва, че функцията е предназначена да работи по асинхронен начин. Ключовата дума
				<em>await</em> сигнализира, че извикването на функцията
				<em>readFile("config.json")</em> трябва да върне
				<em>promise</em> и ако това не стане, отговорът трябва да бъде опакован в
				<em>promise</em>. Точно както с изпълнението на
				<em>run()</em> в предходния раздел,
				<em>await</em> ще хвърли грешка, ако
				<em>promise</em> е отхвърлено и по друг начин да върне стойност от
				<em>promise</em>. Крайният резултат е, че може да се напише асинхронен код, като синхронен, без управлението на итератор-базирано
				състояние на машината.</p>
			<p>Синтаксиса
				<em>await</em> се очаква да бъде финализиран в ECMAScript 2017 (ECMAScript 8).</p>
		</div>
	</article>
	<footer>
		<h3>Обобщение</h3>
		<p>
			<em>Promises</em> са предназначени за подобряване на асинхронното програмиране в JavaScript, като ви дават повече контрол
			и компонентност над асинхронните операции, от колкото събитията и обратните извиквания могат. Това се постига чрез планиране
			на работния график, които да бъде добавен към работата на
			<em>job queue</em> в JavaScript машината за по-късно изпълнение, докато втория
			<em>job queue</em> следи манипулаторите за изпълнение и отхвърляне, за да гарантира правилното изпълнение.</p>
		<p>
			<em>Promises</em> имат три състояния:
			<em>pending, fulfilled</em> и
			<em>rejected</em>.
			<em>Promise</em> започва в състояние на изчакване (
			<em>pending</em>) и се изпълняват с успех (
			<em>success</em>) или отхвърляне (
			<em>failure</em>). И в двата случая могат да се добавят манипулатори за уведомяване, които да посочат, кога
			<em>promise</em> е уредено. Метода
			<em>then()</em> ви позволява да зададете манипулатор за изпълнение и отхвърляне, а
			<em>catch()</em> метода ви позволява зададете само манипулатор за отхвърляне.
		</p>
		<p>Можете да наредите верижно
			<em>promises</em> заедно по най-различни начини и да предавате информация между тях. Всяко извикване на
			<em>then()</em> създава и връща ново
			<em>promise</em>, което е разрешено, когато и предното е разрешено. Тези вериги могат да бъдат използвани за да предизвикат
			отговори на поредица от асинхронни събития. Можете също да използвате
			<em>Promise.race()</em> и
			<em>Promise.all()</em> за да следите развитието на множество
			<em>promises</em> и отговорите по съответния начин.</p>
		<p>
			<em>Asynchronous task running</em> се прави по-лесно, когато комбинирате генератори и
			<em>promise</em>, като
			<em>promises</em> дават общ интерфейс, който асинхронните операции могат да върнат. След това, можете да използвате генератори
			и оператора
			<em>yield</em> за изчакване на асинхронните отговори и да се реагира по адекватен начин.</p>
		<p>Повечето нови уеб
			<em>APIs</em> се строят на върха на
			<em>promises</em> и можете да очаквате още много други да последват примера им в бъдеще.</p>
	</footer>
	<nav>
		<a href="10_array.html" title="previous chapter">◀</a>
		<a href="./index.html" title="cover">◆</a>
		<a href="./12_proxies_and_reflection.html" title="next chapter">▶</a>
	</nav>
</body>

</html>