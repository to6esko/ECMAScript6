<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Proxies and Reflection :: Understanding ECMAScript 6</title>
  <link rel="stylesheet" href="font.css">
</head>

<body>
  <nav>
    <a href="11_promises.html" title="previous chapter">◀</a>
    <a href="./index.html" title="cover">◆</a>
    <a href="./13_modules.html" title="next chapter">▶</a>
  </nav>
  <header id="header" class="">
    <h1>
      <div class="head-num">Глава 12</div>Proxies и Reflection API</h1>
    <p>Една от целите, споделяни от ECMAScript 5 и ECMAScript 6 е продължаване на разбулване на тайнственоста около функционалността
      на JavaScript. Например преди ECMAScript 5, имаше
      <em>nonenumerable</em> и
      <em>nonwritable</em> обектни свойства в JavaScript, но нямаше начин програмистите да определят свои собствени
      <em>nonenumerable</em> или
      <em>nonwritable</em> свойства. Това доведе до включването на
      <em>Object.defineProperty()</em> метода в ECMAScript 5 за да се даде възможност на програмистите да правят това, което
      JavaScript машината вече беше способна да прави.</p>
    <p>ECMAScript 6 дава на програмистите по-нататъшен достъп до възможностите на JavaScript машината, чрез добавяне на вградени
      обекти. За да се даде възможност на програмистите да създават вградени обекти, езикът разкрива вътрешното функциониране
      на обекти чрез
      <em>proxies</em>, които могат да прихващат и да променят операции от ниско ниво в двигателя на JavaScript. Тази глава започва
      с описание на проблема, за който
      <em>proxies</em> са предназначени, а след това се обсъжда как можете да създавате и използвате
      <em>proxies</em> ефективно.</p>
  </header>
  <!-- /header -->
  <article>
    <h3>Проблем с arrays</h3>
    <p>
      <em>Array</em> обекта на JavaScript се държи по начин, който програмистите не можеха да имитират в собствените си обекти
      преди ECMAScript 6. Свойството
      <em>length</em> на
      <em>arrays</em> се засяга, когато присвоявате стойности към специфични елементи на
      <em>array</em> и може да променяте елементите на
      <em>array</em> чрез промяна на
      <em>length</em> свойството. Например:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> colors = ["red", "green", "blue"];

console.log(colors.length);         // 3

colors[3] = "black";

console.log(colors.length);         // 4
console.log(colors[3]);             // "black"

colors.length = 2;

console.log(colors.length);         // 2
console.log(colors[3]);             // undefined
console.log(colors[2]);             // undefined
console.log(colors[1]);             // "green"
  			</pre>
      </dd>
    </dl>
    <p>Тука,
      <em>colors</em> започва с три елемента. Присвояването на "black" към
      <em>colors[3]</em> автоматично увеличава стойността на
      <em>length</em> свойството на четири. Определянето на
      <em>length</em> свойството обратно на две, премахва последните два елемента в
      <em>array</em>, оставяйки само първите два елемента. Няма нищо в ECMAScript 5, което да позволява на програмистите да постигнат
      същото поведение, но
      <em>proxies</em> променят това.</p>
    <dl>
      <dd>
        <div class="info">
          <img src="./img/info.jpg" alt="info">
        </div>
        <strong>Това е нестандартно поведение, защото
          <em>arrays</em> се считат за екзотични обекти в ECMAScript 6.</strong>
      </dd>
    </dl>
    <h3>Какво са Proxies и Reflection?</h3>
    <p>Можете да създадете
      <em>proxy</em>, което да използвате на място върху друг обект (наречен
      <em>target</em> ), като извикате
      <em>new Proxy()</em>.
      <em>Proxy</em> виртуализира мишената, така че
      <em>proxy</em> и
      <em>target</em> изглеждат, като един и същи обект на функционалност използвана от
      <em>proxy</em>.</p>
    <p>
      <em>Proxies</em>, обаче ви позволява да прихващате операции от ниско ниво, които иначе са вътрешни за JavaScript машината.
      Тези операции от ниско ниво са засечени с помощта на
      <em>trap</em>, който е функция, която отговаря за конкретна операция.</p>
    <p>
      <em>Reflection API</em>, представлявана от
      <em>Reflect object</em>, е колекция от методи, които дават поведение по подразбиране за същите операции от ниско ниво,
      които
      <em>proxies</em> могат да заменят. Има
      <em>Reflect</em> метод за всеки
      <em>proxy trap</em>. Тези методи имат същото име и му се подават същите аргументи, както на неговия съответен
      <em>proxy trap</em>. Таблицата по-долу съдържа всички
      <em>proxy traps</em>.</p>
    <div id="table-stayle">
      <dl>
        <dd>
          <table class="table">
            <tr>
              <th>Proxy Trap</th>
              <th>Overrides the Behavior Of</th>
              <th>Default Behavior</th>
            </tr>
            <tr>
              <td>get</td>
              <td>Reading a property value</td>
              <td>Reflect.get()</td>
            </tr>
            <tr>
              <td>set</td>
              <td>Writing to a property</td>
              <td>Reflect.set()</td>
            </tr>
            <tr>
              <td>has</td>
              <td>The in operator</td>
              <td>Reflect.has()</td>
            </tr>
            <tr>
              <td>deletePropery</td>
              <td>The delete operator</td>
              <td>Reflect.deleteProperty()</td>
            </tr>
            <tr>
              <td>getPrototypeOf</td>
              <td>Object.getPrototypeOf()</td>
              <td>Reflect.getPrototypeOf()</td>
            </tr>
            <tr>
              <td>setPrototypeOf</td>
              <td>Object.setPrototypeOf()</td>
              <td>Reflect.setPrototypeOf()</td>
            </tr>
            <tr>
              <td>isExtensible</td>
              <td>Object.isExtensible()</td>
              <td>Reflect.isExtensible()</td>
            </tr>
            <tr>
              <td>preventExtensions</td>
              <td>Object.preventExtensions()</td>
              <td>Reflect.preventExtensions()</td>
            </tr>
            <tr>
              <td>getOwnPropertyDescriptor</td>
              <td>Object.getOwnPropertyDescriptor </td>
              <td>Reflect.getOwnPropertyDescriptor()</td>
            </tr>
            <tr>
              <td>defineProperty</td>
              <td>Object.defineProperty()</td>
              <td>Reflect.defineProperty()</td>
            </tr>
            <tr>
              <td>ownKeys</td>
              <td>Object.keys, Object.getOwnPropertyNames(), Object.getOwnPropertySymbols()
              </td>
              <td>Reflect.ownKeys()</td>
            </tr>
            <tr>
              <td>apply</td>
              <td>Calling a function</td>
              <td>Reflect.apply()</td>
            </tr>
            <tr>
              <td>construct</td>
              <td>Calling a function with new</td>
              <td>Reflect.construct()</td>
            </tr>
          </table>
        </dd>
      </dl>
    </div>
    <p>Всеки един
      <em>traps</em> замества някое от вградените поведения на JavaScript обектите, позволявайки ви да прихващате и променяте
      поведението. Ако все пак ви се наложи да използвате вградено поведение, тогава можете да използвате съответния
      <em>reflection API</em> метод. Връзката между
      <em>proxies</em> и
      <em>reflection API</em> става ясна, когато започнете да създавате
      <em>proxies</em>, така че най-добре да разгледаме няколко примера.</p>
    <dl>
      <dd>
        <div class="info">
          <img src="./img/info.jpg" alt="info">
        </div>
        <strong>В първоначалната спецификация на ECMAScript 6 имаше допълнителен
          <em>trap</em>, наречен
          <em>enumerate</em>, който е проектиран да променя с
          <em>for-in</em> и
          <em>Object.keys()</em> начина на изброяване на свойствата на даден обект. Обаче,
          <em>enumerate trap</em> беше премахнат в ECMAScript 7 (наречен също ECMAScript 2016 г.), тъй като по време на изпълнението
          са открити трудности.
          <em>enumerate trap</em> вече не съществува в средата на JavaScript и следователно не е предмет на тази глава.</strong>
      </dd>
    </dl>
    <h3>Създаване на Proxy</h3>
    <p>
      <em>Proxies</em> се създават с помощта на
      <em>Proxy</em> конструктора и подаване на два аргумента
      <em>target</em> (цел) и
      <em>handler</em> (манипулатор). Манипулатора е обект, който определя една или повече цели. Proxy използва поведение по
      подразбиране за всички операции, освен когато
      <em>traps</em> са дефинирани за тази операция. За да се създаде просто препращане на
      <em>proxy</em>, можете да използвате
      <em>handler</em> без никакви
      <em>traps</em>:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> target = {};

<span class="code">let</span> proxy = <span class="code">new Proxy</span>(target, {});

proxy.name = "proxy";
console.log(proxy.name);        // "proxy"
console.log(target.name);       // "proxy"

target.name = "target";
console.log(proxy.name);        // "target"
console.log(target.name);       // "target"
          
        </pre>
      </dd>
    </dl>
    <p>В този пример,
      <em>proxy</em> препраща всички операции директно на
      <em>target</em>. Когато "proxy" се възлага на
      <em>proxy.name</em> свойството,
      <em>name</em> се създава в
      <em>target</em>. Самия
      <em>proxy</em> не съхранява това свойство, това е просто препращане на операцията към
      <em>target</em>. Аналогично, стойностите на
      <em>proxy.name</em> и
      <em>target.name</em> са същите, защото те са две препратки към
      <em>target.name</em>. Това също означава, че задаването на нова стойност на
      <em>target.name</em>, кара
      <em>proxy.name</em> да отрази същата промяна. Разбира се,
      <em>proxies</em> без
      <em>traps</em> не са много интересни, така че какво се случва, когато се дефинира
      <em>trap</em>.</p>
    <h3>Валидиране на свойства с използване на set Trap</h3>
    <p>Да предположим, че искате да създадете обект, чийто стойности на свойства трябва да са номера. Това означава, че всяко
      ново свойство, добавено към обекта трябва да е валидирано и да бъде хвърлена грешка, ако стойността не е номер. За
      да постигнете това трябва да дефинирате
      <em>set trap</em>, който отменя поведението по подразбиране на настройката за създаване на стойност.
      <em>Set trap</em> получава четири аргумента:</p>
    <dl>
      <dd>
        <ol>
          <li>
            <strong>trapTarget</strong> - обекта, който ще получи свойството (
            <em>proxy target</em>).</li>
          <li>
            <strong>key</strong> - ключ за свойството (
            <em>string</em> или
            <em>simbol</em>) за записване.</li>
          <li>
            <strong>value</strong> - стойност за записване на свойството.</li>
          <li>
            <strong>receiver</strong> - обекта, на който се извършва операцията (обикновено е
            <em>proxy</em>).</li>
        </ol>
      </dd>
    </dl>
    <p>Съответстващия огледален
      <em>trap</em> метод на
      <em>Reflect.set()</em> е
      <em>set</em>, който е поведението по подразбиране за тази операция.
      <em>Reflect.set()</em> метода приема същите четири аргумента, като
      <em>set proxy trap</em>, което го прави лесен за използване във вътрешността на
      <em>trap</em> метода.
      <em>Trap</em> трябва да върне
      <em>true</em>, ако свойството е създадено или
      <em>false</em> ако не е (
      <em>Reflect.set()</em> метода връща правилната стойност на базата на успешна
      <em>if</em> операция).</p>
    <p>За валидиране на стойностите на свойствата, можете да използвате
      <em>set trap</em> и да инспектирате
      <em>value</em> стойността, която се подава вътре. Ето един пример:</p>
    <dl>
      <dd>
        <pre class="highlight-overflow">
<span class="code">let</span> target = {
    name: "target"
};

<span class="code">let</span> proxy = <span class="code">new Proxy</span>(target, {
        set(trapTarget, key, value, receiver) {

            <span class="comment"><em>// игнорира съществуващите свойства за да не ги засегне</em></span>
            <span class="code">if</span> (!trapTarget.hasOwnProperty(key)) {
                <span class="code">if</span> (<span class="code">isNaN</span>(value)) {
                    <span class="code">throw new</span> TypeError("Property must be a number.");
                }
            }

            <span class="comment"><em>// добавяне на свойство</em></span>
            <span class="code">return</span> Reflect.set(trapTarget, key, value, receiver);
        }
    });

<span class="comment"><em>// добавяне на ново свойство</em></span>
proxy.count = 1;
console.log(proxy.count);       // 1
console.log(target.count);      // 1

<span class="comment"><em>// може да зададете име, защото то съществува в целта вече</em></span>
proxy.name = "proxy";
console.log(proxy.name);        // "proxy"
console.log(target.name);       // "proxy"

<span class="comment"><em>// хвърля грешка</em></span>
proxy.anotherName = "proxy";
        </pre>
      </dd>
    </dl>
    <p>Този пример дефинира
      <em>proxy trap</em>, който валидира стойността на всяко ново свойство добавено към
      <em>target</em>. Когато
      <em>proxy.count = 1</em> е изпълнено, се извиква
      <em>set trap</em>. Стойноста на
      <em>trapTarget</em> е равна на
      <em>target</em>,
      <em>key</em> е "count",
      <em>value</em> е 1 и
      <em>receiver</em> (не се използва в този пример) е
      <em>proxy</em>. Тъй като, не съществува свойство с име
      <em>count</em> в
      <em>target</em>,
      <em>proxy</em> валидира
      <em>value</em> с подаването и към
      <em>isNaN</em>. Ако резултата е
      <em>NaN</em>, тогава стойността на свойството не е номер и се хвърля грешка. Тъй като
      <em>count</em> е настроен на 1,
      <em>proxy</em> извиква
      <em>Reflect.set()</em> със същите четири аргумента, които са подадени на
      <em>trap</em>, за да добавите ново свойство.</p>
    <p>Когато
      <em>proxy.name</em> се задава със
      <em>string</em>, операцията завършва успешно. Тъй като,
      <em>target</em> вече има
      <em>name</em> свойство, което е пропуснато от проверката за валидиране, чрез използване на
      <em>trapTarget.hasOwnProperty()</em>. Това гарантира, че по-рано съществуващите стойности, които не са цифрови свойства
      все още се поддържат.</p>
    <p>Когато
      <em>proxy.anotherName</em> се задава със
      <em>string</em>, обаче, се хвърля грешка. Свойството
      <em>anotherName</em> не съществува в
      <em>target</em>, така че неговата стойност трябва да бъде валидирана. По време на проверката се хвърля грешка, защото "proxy"
      не е цифрова стойност.</p>
    <p>Като се има в предвид, че
      <em>set proxy trap</em> ви позволява да се намесите, когато се пишат свойства, то
      <em>get proxy trap</em> ви позволява да се намесите, когато се четат свойства.</p>
    <h3>Валидиране на обектна форма с използване на get Trap</h3>
    <p>Един от най-интересните и понякога объркващи аспекти на JavaScript е, когато четенето на несъществуващи свойства не хвърля
      грешка. Вместо това се използва
      <em>undefined</em> за стойност на свойството. Например:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> target = {};

console.log(target.name);       // undefined
        </pre>
      </dd>
    </dl>
    <p>В повечето други езици, при опит за четене на
      <em>target.name</em> се хвърля грешка, защото свойството не съществува. JavaScript, обаче използва стойността
      <em>undefined</em> за
      <em>target.name</em> свойството. Ако някога сте работили с голяма база код, вероятно сте виждали, как това поведение може
      да доведе до значителни проблеми, особено ако има правописна грешка в името на свойството. С
      <em>proxies</em>, можем да се спасим от този проблем, чрез валидиране на обектната форма.</p>
    <p>Една обектна форма е колекция от свойства и методи на разположение на обекта. JavaScript машината използва обектната
      форма за оптимизиране на кода и често създава класове за представяне на обектите. Ако може безопасно да се предположи,
      че един обект има същите свойства и методи, с които започва (поведението може се приложи с
      <em>Object.preventExtensions(), Object.seal()</em> или
      <em>Object.freeze()</em> методите), а след това хвърля грешка при опит за достъп до несъществуващи свойства, могат да бъдат
      полезни.
      <em>Proxies</em> правят валидирането на обектната форма лесно.</p>
    <p>Тъй като, валидирането на свойство трябва да се направи, когато едно свойство е само за четене, трябва да използвате
      <em>get trap. The get trap</em> се извиква всеки път, когато едно свойство се чете, дори ако това свойство не съществува
      в обекта. Има три аргумента, които се подават към
      <em>get trap</em>:</p>
    <dl>
      <dd>
        <ol>
          <li>
            <strong>trapTarget</strong> - обект, от който се чете свойството (
            <em>proxy target</em>).</li>
          <li>
            <strong>key</strong> - ключ за свойството (
            <em>string</em> или
            <em>simbol</em>) за четене.</li>
          <li>
            <strong>receiver</strong> - обекта, на който се извършва операцията (обикновено е
            <em>proxy</em>).</li>
        </ol>
      </dd>
    </dl>
    <p>Тези аргументи са огледален образ на тези за
      <em>set trap</em> аргументите, с една забелжима разлика. Няма
      <em>value</em> аргумент, защото
      <em>get trap</em> не пишат стойности.
      <em>Reflect.get()</em> метода приема същите три аргумента, като
      <em>get trap</em> и връща стойност по подразбиране за свойството.</p>
    <p>Можете да използвате
      <em>get trap</em> и
      <em>Reflect.get()</em> за хвърляне на грешка, ако свойството не съществува в целта:</p>
    <dl>
      <dd>
        <pre class="highlight-overflow">
<span class="code">let</span> proxy = new Proxy({}, {
        get(trapTarget, key, receiver) {
            <span class="code">if</span> (!(key <span class="code">in</span> receiver)) {
                <span class="code">throw new</span> TypeError("Property " + key + " doesn't exist.");
            }

            <span class="code">return</span> Reflect.get(trapTarget, key, receiver);
        }
    });

<span class="comment"><em>// добавянето на свойство все още работи</em></span>
proxy.name = "proxy";
console.log(proxy.name);            // "proxy"

<span class="comment"><em>// несъществуващи свойства хвърлят грешка</em></span>
console.log(proxy.nme);             <span class="comment"><em>// хвърля грешка</em></span>
          
        </pre>
      </dd>
    </dl>
    <p>В този пример,
      <em>get trap</em> прихваща операциите при четене на свойства. Оператора
      <em>in</em> се използва за да определи дали свойството вече съществува в
      <em>receiver</em>. Използваме
      <em>receiver</em> с
      <em>in</em> вместо
      <em>trapTarget</em>, в случай, че
      <em>receiver</em> е
      <em>proxy</em>, който има
      <em>has trap</em>, тип който ще покрием в следващия раздел. Използването на
      <em>trapTarget</em> ще заобиколи наличието на
      <em>has trap</em> и потенциално ще даде грешен резултат. Грешка се хвърля , ако свойството не съществува, в противен случай
      се използва поведението по подразбиране.</p>
    <p>Този код разрешава добавянето на нови свойства, като
      <em>proxy.name</em>, които се четат и пишат без никакъв проблем. Последният ред съдържа правописна грешка,
      <em>proxy.nme</em>, което вероятно трябва да бъде
      <em>proxy.name</em>. Това хвърля грешка, защото
      <em>nme</em> не съществува, като свойство.</p>
    <h3>Скриване на наличието на свойства, използвайки has Trap</h3>
    <p>Оператора
      <em>in</em> определя дали съществува свойство в даден обект и връща
      <em>true</em> ако има съвпадение с името или
      <em>simbol</em> на собствено или прототипно свойство. Например:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> target = {
    value: 42;
}

console.log("value" <span class="code">in</span> target);     // true
console.log("toString" <span class="code">in</span> target);  // true
          
        </pre>
      </dd>
    </dl>
    <p>И двата
      <em>value</em> и
      <em>toString</em> съществуват в обекта, така че и двата случая с
      <em>in</em> оператора връщат
      <em>true</em>. Свойството
      <em>value</em> е собствено, докато
      <em>toString</em> е прототипно свойство (наследено от
      <em>Object</em>).
      <em>Proxies</em> ви позволяват да прихванете тази операция и да върнете различна стойност за
      <em>in</em> с помощта на
      <em>has trap</em>.</p>
    <p>The
      <em>has trap</em> се извиква всеки път, когато се използва оператора
      <em>in</em>. Когато се извиква има два аргумента подадени към
      <em>has trap</em>:</p>
    <dl>
      <dd>
        <ol>
          <li>
            <strong>trapTarget</strong> - обект, от който се чете свойството (
            <em>proxy target</em>).</li>
          <li>
            <strong>key</strong> - ключ за свойството (
            <em>string</em> или
            <em>simbol</em>) за проверка.</li>
        </ol>
      </dd>
    </dl>
    <p>
      <em>Reflect.has()</em> метода приема тези аргументи и връща отговор по подразбиране за
      <em>in</em> оператора. Използването на
      <em>has trap</em> и
      <em>Reflect.has()</em> ви позволяват да промените поведението на
      <em>in</em> за някои свовойста, докато съвпаднат с поведението по подразбиране за другите. Например, да предположим, че
      искате да скриете свойството
      <em>value</em>, можете да го направите по следния начин:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> target = {
    name: "target",
    value: 42
};

<span class="code">let</span> proxy = <span class="code">new Proxy</span>(target, {
    has(trapTarget, key) {

        <span class="code">if</span> (key === "value") {
            <span class="code">return false</span>;
        } <span class="code">else</span> {
            <span class="code">return</span> Reflect.has(trapTarget, key);
        }
    }
});


console.log("value" <span class="code">in</span> proxy);      // false
console.log("name" <span class="code">in</span> proxy);       // true
console.log("toString" <span class="code">in</span> proxy);   // true
        </pre>
      </dd>
    </dl>
    <p>The
      <em>has trap</em> е за
      <em>proxy</em> проверките, за да се види дали
      <em>key</em> е "value", и ако е така връща
      <em>false</em>. В противен случай се използва поведение по подразбиране с
      <em>Reflect.has()</em> метода. Резултата е, че
      <em>in</em> оператора връща
      <em>false</em> за свойството
      <em>value</em> въпреки, че в действителност съществува в целта. Другите свойства
      <em>name</em> и
      <em>toString</em>, правилно връщат
      <em>true</em>, когато се използва
      <em>in</em> оператора.</p>
    <h3>Предотвратяване на заличаване на свойство с deleteProperty Trap</h3>
    <p>Оператора
      <em>delete</em> премахва свойство от един обект и при успех връща
      <em>true</em>, а при неуспех връща
      <em>false</em>. В
      <em>strict mode</em>,
      <em>delete</em> хвърля грешка, при опит за изтриване на
      <em>nonconfigurable</em> свойство, в
      <em>nonstrict mode</em>
      <em>delete</em> просто връща
      <em>false</em>. Ето един пример:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> target = {
    name: "target",
    value: 42
};

Object.defineProperty(target, "name", { configurable: <span class="code">false</span> });

console.log("value" <span class="code">in</span> target);     // true

<span class="code">let</span> result1 = <span class="code">delete</span> target.value;
console.log(result1);               // true

console.log("value" <span class="code">in</span> target);     // false

<span class="comment"><em>// Забележка: Следващия ред хвърля грешка в strict mode</em></span>
<span class="code">let</span> result2 = <span class="code">delete</span> target.name;
console.log(result2);               // false

console.log("name" <span class="code">in</span> target);      // true
        </pre>
      </dd>
    </dl>
    <p>Свойството
      <em>value</em> се изтрива с помощта на оператора
      <em>delete</em> и като резултат оператора
      <em>in</em> връща
      <em>false</em> при третото извикване на
      <em>console.log()</em>.
      <em>Nonconfigurable name</em> свойството не може да бъде изтрито, така че оператора
      <em>delete</em> просто връща
      <em>false</em> (ако този код се изпълнява в
      <em>strict mode</em>, ще бъде хвърлена грешка). Можем да променим това поведение с помощта на
      <em>deleteProperty trap</em> в
      <em>proxy</em>.</p>
    <p>The
      <em>deleteProperty trap</em> се извиква винаги, когато
      <em>delete</em> оператора се използва върху дадено обектно свойство. В
      <em>trap</em> се подават два аргумента:</p>
    <dl>
      <dd>
        <ol>
          <li>
            <strong>trapTarget</strong> - обект, от който трябва да се премахне свойството (
            <em>proxy target</em>).</li>
          <li>
            <strong>key</strong> - ключ за свойството (
            <em>string</em> или
            <em>simbol</em>) за изтриване.</li>
        </ol>
      </dd>
    </dl>
    <p>
      <em>Reflect.deleteProperty()</em> метода осигурява изпълнението по подразбиране на
      <em>deleteProperty trap</em> и приема същите два аргумента. Можете да комбинирате
      <em>Reflect.deleteProperty()</em> и
      <em>deleteProperty trap</em>, за да промените начина, по който
      <em>delete</em> оператора се държи. Например, можете да се гарантирате, че
      <em>value</em> свойството не може да бъде изтрито:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> target = {
    name: "target",
    value: 42
};

<span class="code">let</span> proxy = <span class="code">new Proxy</span>(target, {
    deleteProperty(trapTarget, key) {

        <span class="code">ìf</span> (key === "value") {
            <span class="code">return false</span>;
        } <span class="code">else</span> {
            <span class="code">return</span> Reflect.deleteProperty(trapTarget, key);
        }
    }
});

<span class="comment"><em>// опит за изтриване на proxy.value</em></span>

console.log("value" <span class="code">in</span> proxy);      // true

<span class="code">let</span> result1 = <span class="code">delete</span> proxy.value;
console.log(result1);               // false

console.log("value" <span class="code">in</span> proxy);      // true

<span class="comment"><em>// опит за изтриване на proxy.name</em></span>

console.log("name" <span class="code">in</span> proxy);       // true

<span class="code">let</span> result2 = <span class="code">delete</span> proxy.name;
console.log(result2);               // true

console.log("name" <span class="code">in</span> proxy);       // false
          
        </pre>
      </dd>
    </dl>
    <p>Този код е много подобен на
      <em>has trap</em> примера в това, че
      <em>deleteProperty trap</em> проверява за да види дали
      <em>key</em> е "value" и ако е така връща
      <em>false</em>. В противен случай се използва поведението по подразбиране, като се извиква
      <em>Reflect.deleteProperty()</em> метода. Свойството
      <em>value</em> не може да бъде изтрито чрез
      <em>proxy</em>, защото операцията е в
      <em>trapped</em>, но свойството
      <em>name</em> се премахва, както се очаква. Този подход е особено полезен, когато искате да защитите свойства от премахване,
      без да се предизвиква грешка в
      <em>strict mode</em>.</p>
    <h3>Prototype Proxy Traps</h3>
    <p>В
      <a href="./04_object_function.html">Глава 4</a>, учихме за ECMAScript 6
      <em>Object.setPrototypeOf()</em> метода, който се добавя за да допълни ECMAScript 5
      <em>Object.getPrototypeOf()</em> метода.
      <em>Proxies</em> позволяват прихващане на изпълнението на двата метода със
      <em>setPrototypeOf</em> и
      <em>getPrototypeOf traps</em>. И в двата случая метода на
      <em>Object</em> извиква
      <em>trap</em> върху съответното име на
      <em>proxy</em>, позволявайки ви да променяте поведението на методите. The
      <em>setPrototypeOf trap</em> получава тези аргументи:</p>
    <dl>
      <dd>
        <ol>
          <li>
            <strong>trapTarget</strong> - обекта, за който трябва да се създаде прототип (
            <em>proxy target</em>).</li>
          <li>
            <strong>proto</strong> - обекта, който трябва да се използва, като прототип.</li>
        </ol>
      </dd>
    </dl>
    <p>Това са едни и същи аргументи подадени към
      <em>Object.setPrototypeOf()</em> и
      <em>Reflect.setPrototypeOf()</em>. The
      <em>getPrototypeOf trap</em> получава само
      <em>trapTarget</em> аргумент, който е аргумента подаден към
      <em>Object.getPrototypeOf()</em> и
      <em>Reflect.setPrototypeOf()</em> методите.</p>
    <h4>Как работи Prototype Proxy Traps</h4>
    <p>Има някои ограничения за тези
      <em>traps</em>. Първо,
      <em>getPrototypeOf trap</em> трябва да върне обект или
      <em>null</em>, както и всички други резултати, връщащи грешка по време на работа. Проверката за връщане на стойност гарантира,
      че
      <em>Object.getPrototypeOf()</em> винаги ще върне очакваната стойност. По същия начин, върнатата стойност от
      <em>setPrototypeOf trap</em> трябва да бъде
      <em>false</em> ако операцията не успее. Когато
      <em>setPrototypeOf</em> връща
      <em>false, Object.setPrototypeOf()</em> хвърля грешка. Ако
      <em>setPrototypeOf</em> връща някаква стойност различна от
      <em>false</em>, тогава
      <em>Object.setPrototypeOf()</em> приема, че операцията е успяла.</p>
    <p>Следващия пример скрива прототипа на
      <em>proxy</em>, като винаги връща
      <em>null</em> и също така не позволява на прототипа да бъде променен:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> target = {};
<span class="code">let</span> proxy = <span class="code">new Proxy</span>(target, {
    getPrototypeOf(trapTarget) {
        <span class="code">return null</span>;
    },
    setPrototypeOf(trapTarget, proto) {
        <span class="code">return false</span>;
    }
});

<span class="code">let</span> targetProto = <span class="code">Object</span>.getPrototypeOf(target);
<span class="code">let</span> proxyProto = <span class="code">Object</span>.getPrototypeOf(proxy);

console.log(targetProto === <span class="code">Object</span>.prototype);      // true
console.log(proxyProto === <span class="code">Object</span>.prototype);       // false
console.log(proxyProto);                            // null

<span class="comment"><em>// succeeds (успех)</em></span>
<span class="code">Object</span>.setPrototypeOf(target, {});

<span class="comment"><em>// throws error</em></span>
<span class="code">Object</span>.setPrototypeOf(proxy, {});
        </pre>
      </dd>
    </dl>
    <p>Този код подчертава разликата между поведението на
      <em>target</em> и
      <em>proxy</em>. Докато
      <em>Object.getPrototypeOf()</em> връща стойност за
      <em>target</em>, той връща
      <em>null</em> за
      <em>proxy</em>, защото
      <em>getPrototypeOf trap</em> е извикан. По същия начин,
      <em>Object.setPrototypeOf()</em> успява, когато се използва за
      <em>target</em>, но хвърля грешка, когато се използва за
      <em>proxy</em> в
      <em>setPrototypeOf trap</em>.</p>
    <p>Ако искате да използвате поведение по подразбиране за тези два
      <em>traps</em>, можете да използвате съответните методи на
      <em>Reflect</em>. Например, този код изпълнява поведение по подразбиране за
      <em>getPrototypeOf</em> и
      <em>setPrototypeOf traps</em>:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> target = {};
<span class="code">let</span> proxy = <span class="code">new Proxy</span>(target, {
    getPrototypeOf(trapTarget) {
        <span class="code">return</span> Reflect.getPrototypeOf(trapTarget);
    },
    setPrototypeOf(trapTarget, proto) {
        <span class="code">return</span> Reflect.setPrototypeOf(trapTarget, proto);
    }
});

<span class="code">let</span> targetProto = <span class="code">Object</span>.getPrototypeOf(target);
<span class="code">let</span> proxyProto = <span class="code">Object</span>.getPrototypeOf(proxy);

console.log(targetProto === <span class="code">Object</span>.prototype);      // true
console.log(proxyProto === <span class="code">Object</span>.prototype);       // true

<span class="comment"><em>// успява</em></span>
<span class="code">Object</span>.setPrototypeOf(target, {});

<span class="comment"><em>// също успява</em></span>
<span class="code">Object</span>.setPrototypeOf(proxy, {});
            
          </pre>
      </dd>
    </dl>
    <p>В този пример можете да използвате взаимозаменяеми
      <em>target</em> и
      <em>proxy</em> и да получите същия резултат, защото на
      <em>getPrototypeOf</em> и
      <em>setPrototypeOf traps</em> им се подава да използват изпълнението по подразбиране. Важното в този пример е, че използвате
      <em>Reflect.getPrototypeOf()</em> и
      <em>Reflect.setPrototypeOf()</em> методите, вместо методите с едно и също име за
      <em>Object</em> поради някои важни разлики.</p>
    <h3>Защо два комплекта методи?</h3>
    <p>Най объркващия аспект на
      <em>Reflect.getPrototypeOf()</em> и
      <em>Reflect.setPrototypeOf()</em> е, че изглеждат подозрително подобни на
      <em>Object.getPrototypeOf()</em> и
      <em>Object.setPrototypeOf()</em>. Докато двете групи методи извършват подобни операции, има някои видими разлики между
      двете.
    </p>
    <p>Да започнем с,
      <em>Object.getPrototypeOf()</em> и
      <em>Object.setPrototypeOf()</em>, които са операции от по-високо ниво, което означава, че са създадени за използване от
      програмистите още от самото начало.
      <em>Reflect.getPrototypeOf()</em> и
      <em>Reflect.setPrototypeOf()</em> са операции от по-ниско ниво, като дават достъп на програмистите само за вътрешно ползване
      на [[GetPrototypeOf]] и [[SetPrototypeOf]] операциите. Метода
      <em>Reflect.getPrototypeOf()</em> е обвивка на вътрешната [[GetPrototypeOf]] операция (с някакъв вход за валидиране). Метода
      <em>Reflect.setPrototypeOf()</em> и [[SetPrototypeOf]] имат същата връзка. Съответните методи за
      <em>Object</em> също извикват [[GetPrototypeOf]] и [[SetPrototypeOf]], но изпълняват няколко стъпки, преди повикването
      и инспектират върнатата стойност, за да се определи как да се държат.</p>
    <p>
      <em>Reflect.getPrototypeOf()</em> метода хвърля грешка, ако аргумента му не е обект, докато
      <em>Object.getPrototypeOf()</em> първо коригира стойността в обект, преди извършване на операцията. Ако ви се наложи да
      подадете номер във всеки метод, ще получите различен резултат:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> result1 = <span class="code">Object</span>.getPrototypeOf(1);
console.log(result1 === <span class="code">Number</span>.prototype);  // true

<span class="comment"><em>// throws an error</em></span>
Reflect.getPrototypeOf(1);
          </pre>
      </dd>
    </dl>
    <p>
      <em>Object.getPrototypeOf()</em> метода ви позволява да извлечете прототип за цифрата 1, защото първо коригира стойността
      в
      <em>Number</em> обект и след това връща
      <em>Number.prototype. Reflect.getPrototypeOf()</em> метода не коригира стойността и тъй като 1 не е обект, той хвърля грешка.</p>
    <p>
      <em>Reflect.setPrototypeOf()</em> метода също има няколко разлики с
      <em>Object.setPrototypeOf()</em> метода. Първо,
      <em>Reflect.setPrototypeOf()</em> връща булева стойност, показваща дали операцията е успешна (
      <em>true</em> за успех,
      <em>false</em> за провал). Ако
      <em>Object.setPrototypeOf()</em> не успее, той хвърля грешка.</p>
    <p>Както видяхме по-рано, когато
      <em>setPrototypeOf proxy trap</em> върне
      <em>false</em>, той предизвиква
      <em>Object.setPrototypeOf()</em> да хвърли грешка.
      <em>Object.setPrototypeOf()</em> метода връща първия аргумент, като негова стойност и следователно не е подходящ за прилагане
      на поведение по подразбиране на
      <em>setPrototypeOf proxy trap</em>. Следният код демонстрира тези разлики:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> target1 = {};
<span class="code">let</span> result1 = <span class="code">Object</span>.setPrototypeOf(target1, {});
console.log(result1 === target1);                   // true

<span class="code">let</span> target2 = {};
<span class="code">let</span> result2 = Reflect.setPrototypeOf(target2, {});
console.log(result2 === target2);                   // false
console.log(result2);                               // true
          </pre>
      </dd>
    </dl>
    <p>В този пример,
      <em>Object.setPrototypeOf()</em> връща
      <em>target1</em>, като негова стойност, но
      <em>Reflect.setPrototypeOf()</em> връща
      <em>true</em>. Тази малка разлика е много важна. Вие ще видите още привидно дублиращи се методи на
      <em>Object</em> и
      <em>Reflect</em>, но никога не забравяйте да използвате
      <em>Reflect</em> метода вътре
      <em>proxy traps</em>.</p>
    <dl>
      <dd>
        <div class="info">
          <img src="./img/info.jpg" alt="info">
        </div>
        <strong>И двете групи методи ще наричаме
          <em>getPrototypeOf</em> и
          <em>setPrototypeOf proxy traps</em> когато ги използваме за
          <em>proxy</em>.</strong>
      </dd>
    </dl>
    <h3>Object Extensibility Traps</h3>
    <p>ECMAScript 5 добавя
      <em>object extensibility</em> модификация чрез
      <em>Object.preventExtensions()</em> и
      <em>Object.isExtensible()</em> методите и ECMAScript 6 позволява
      <em>proxies</em> да прихваща тези извиквания на методи към основните обекти чрез
      <em>preventExtensions</em> и
      <em>isExtensible traps</em>. И двата
      <em>traps</em> получават един аргумент
      <em>trapTarget</em>, който е обекта, върху който е извикан метода. The
      <em>isExtensible trap</em> трябва да върне булева стойност, показваща дали обекта е
      <em>extensible</em>, докато
      <em>preventExtensions trap</em> трабва да върне булева стойност, показваща дали операцията е успяла.</p>
    <p>Има също и
      <em>Reflect.preventExtensions()</em> и
      <em>Reflect.isExtensible()</em> методи за прилагане на поведение по подразбиране. И двата връщат булеви стойности, така
      че могат да се използват директно в съответните им
      <em>traps</em>.</p>
    <h4>Два основни примера</h4>
    <p>За да видите
      <em>object extensibility traps</em> в действие, да разгледаме следния код, който реализира поведението по подразбиране
      за
      <em>isExtensible</em> и
      <em>preventExtensions traps</em>:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> target = {};
<span class="code">let</span> proxy = <span class="code">new Proxy</span>(target, {
    isExtensible(trapTarget) {
        <span class="code">return</span> Reflect.isExtensible(trapTarget);
    },
    preventExtensions(trapTarget) {
        <span class="code">return</span> Reflect.preventExtensions(trapTarget);
    }
});


console.log(<span class="code">Object</span>.isExtensible(target));       // true
console.log(<span class="code">Object</span>.isExtensible(proxy));        // true

<span class="code">Object</span>.preventExtensions(proxy);

console.log(<span class="code">Object</span>.isExtensible(target));       // false
console.log(<span class="code">Object</span>.isExtensible(proxy));        // false
          </pre>
      </dd>
    </dl>
    <p>Този пример показва, че и двата
      <em>Object.preventExtensions()</em> и
      <em>Object.isExtensible()</em> правилно преминават от
      <em>proxy</em> към
      <em>target</em>. Можете разбира се, също да промените поведението. Например, ако не искате да позволите на
      <em>Object.preventExtensions()</em> да успее на вашето
      <em>proxy</em>, можете да върнете
      <em>false</em> от
      <em>preventExtensions trap</em>:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> target = {};
<span class="code">let</span> proxy = <span class="code">new Proxy</span>(target, {
    isExtensible(trapTarget) {
        <span class="code">return</span> Reflect.isExtensible(trapTarget);
    },
    preventExtensions(trapTarget) {
        <span class="code">return false;</span> 
    }
});


console.log(<span class="code">Object</span>.isExtensible(target));       // true
console.log(<span class="code">Object</span>.isExtensible(proxy));        // true

<span class="code">Object</span>.preventExtensions(proxy);

console.log(<span class="code">Object</span>.isExtensible(target));       // true
console.log(<span class="code">Object</span>.isExtensible(proxy));        // true
          </pre>
      </dd>
    </dl>
    <p>Тука, извикването към
      <em>Object.preventExtensions(proxy)</em> се игнорира ефективно, защото
      <em>preventExtensions trap</em> връща
      <em>false</em>. Операцията не се препраща към основния
      <em>target</em>, така че
      <em>Object.isExtensible()</em> връща
      <em>true</em>.</p>
    <h3>Duplicate Extensibility Methods</h3>
    <p>Може би, за пореден път забелязвате, че има привидно дублиращи се методи за
      <em>Object</em> и
      <em>Reflect</em>. В този случай, те са по-близки, от колкото не са. Методите
      <em>Object.isExtensible()</em> и
      <em>Reflect.isExtensible()</em> са сходни с изключение на, когато подадената стойност не е обект. В този случай,
      <em>Object.isExtensible()</em> винаги връща
      <em>false</em>, докато
      <em>Reflect.isExtensible()</em> хвърля грешка. Ето един пример затова поведение:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> result1 = <span class="code">Object</span>.isExtensible(2);
console.log(result1);                       // false

<span class="comment"><em>// throws error</em></span>
<span class="code">let</span> result2 = Reflect.isExtensible(2);
          </pre>
      </dd>
    </dl>
    <p>Това ограничение е подобно на разликата между
      <em>Object.getPrototypeOf()</em> и
      <em>Reflect.getPrototypeOf()</em>, тъй като функционалността на по-ниско ниво има по-строги проверки за грешки, от колкото
      на по-високо ниво.</p>
    <p> Методите
      <em>Object.preventExtensions()</em> и
      <em>Reflect.preventExtensions()</em> също са много сходни. Метода
      <em>Object.preventExtensions()</em> винаги връща стойността, която и е подадена като аргумент, дори ако не е обект. Метода
      <em>Reflect.preventExtensions()</em> от друга страна, хвърля грешка, ако аргумента не е обект; ако аргумента е обект
      <em>Reflect.preventExtensions()</em> връща
      <em>true</em>, когато операцията е успешна или
      <em>false</em> ако не е. Например:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> result1 = <span class="code">Object</span>.preventExtensions(2);
console.log(result1);                               // 2

<span class="code">let</span> target = {};
<span class="code">let</span> result2 = Reflect.preventExtensions(target);
console.log(result2);                               // true

// throws error
<span class="code">let</span> result3 = Reflect.preventExtensions(2);
          </pre>
      </dd>
    </dl>
    <p>Тука, на
      <em>Object.preventExtensions()</em> е подадена стойност 2, като той връща тази стойност въпреки, че не е обект. Метода
      <em>Reflect.preventExtensions()</em> връща
      <em>true</em>, когато и е подаден обект и хвърля грешка, когато и е подадено 2.</p>
    <h3>Property Descriptor Traps</h3>
    <p>Една от най-важните характеристики на ECMAScript 5 е възможността да се определят свойства-атрибути използвайки
      <em>Object.defineProperty()</em> метода. В предишните версии на JavaScript нямаше начин да се определи свойство за достъп,
      да се направи свойство само за четене или да се направи свойство
      <em>nonenumerable</em>. Всички те са възможни с използване на
      <em>Object.defineProperty()</em> метода и можете да изтеглите тези атрибути с използване на
      <em>Object.getOwnPropertyDescriptor()</em> метода.</p>
    <p>
      <em>Proxies</em> позволяват да се прихващат извикванията към
      <em>Object.defineProperty()</em> и
      <em>Object.getOwnPropertyDescriptor()</em> с помощта на
      <em>defineProperty</em> и
      <em>getOwnPropertyDescriptor traps</em>, съответно. The
      <em>defineProperty trap</em> получава следните аргументи:</p>
    <dl>
      <dd>
        <ol>
          <li>
            <strong>trapTarget</strong> - обекта, на който следва да бъде определено свойството (
            <em>proxy target</em>).</li>
          <li>
            <strong>key</strong>-
            <em>string</em> или
            <em>simbol</em> за свойството.</li>
          <li>
            <strong>descriptor</strong> -
            <em>descriptor</em> обект за свойството</li>
        </ol>
      </dd>
    </dl>
    <p>The
      <em>defineProperty trap</em> изисква от вас да върне
      <em>true</em>, ако операцията е успяла и
      <em>false</em> ако не е. The
      <em>getOwnPropertyDescriptor traps</em> получава само
      <em>trapTarget</em> и
      <em>key</em> и се очаква да върне
      <em>descriptor</em>. Съответно
      <em>Reflect.defineProperty()</em> и
      <em>Reflect.getOwnPropertyDescriptor()</em> методите приемат същите аргументи, каквито приема
      <em>proxy trap</em>. Ето един пример, който просто изпълнява поведение по подразбиране за всеки
      <em>trap</em>:</p>
    <dl>
      <dd>
        <pre class="highlight-overflow">
<span class="code">let</span> proxy = <span class="code">new Proxy</span>({}, {
    defineProperty(trapTarget, key, descriptor) {
        <span class="code">return</span> Reflect.defineProperty(trapTarget, key, descriptor);
    },
    getOwnPropertyDescriptor(trapTarget, key) {
        <span class="code">return</span> Reflect.getOwnPropertyDescriptor(trapTarget, key);
    }
});


<span class="code">Object</span>.defineProperty(proxy, "name", {
    value: "proxy"
});

console.log(proxy.name);            // "proxy"

<span class="code">let</span> descriptor = <span class="code">Object</span>.getOwnPropertyDescriptor(proxy, "name");

console.log(descriptor.value);      // "proxy"
          </pre>
      </dd>
    </dl>
    <p>Този код дефинира свойството "name" на
      <em>proxy</em> използвайки
      <em>Object.defineProperty()</em>. Свойството
      <em>descriptor</em> затова свойство се извлича с помощта на
      <em>Object.getOwnPropertyDescriptor()</em> метода.</p>
    <h3>Блокирване на Object.defineProperty()</h3>
    <p>The
      <em>defineProperty trap</em> изисква от вас да върне булева стойност за да покаже, че операцията е била успешна. Когато
      се връща
      <em>true, Object.defineProperty()</em> успява, както обикновено; когато се връща
      <em>false, Object.defineProperty()</em> хвърля грешка. Можете да използвате тази функция, за да ограничите вида на свойството,
      което може да бъде определено с помощта на
      <em>Object.defineProperty()</em> метода. Например, ако искате да предотвратите да бъдат определени
      <em>simbol</em> свойства, бихте могли да проверите дали ключа е
      <em>string</em> и да върне
      <em>false</em> ако не е. Например:</p>
    <dl>
      <dd>
        <pre class="highlight-overflow">
<span class="code">let</span> proxy = <span class="code">new Proxy</span>({}, {
    defineProperty(trapTarget, key, descriptor) {

        <span class="code">if</span> (<span class="code">typeof</span> key !== "string") {
            <span class="code">return false</span>;
        }

        <span class="code">return</span> Reflect.defineProperty(trapTarget, key, descriptor);
    }
});


<span class="code">Object</span>.defineProperty(proxy, "name", {
    value: "proxy"
});

console.log(proxy.name);                    // "proxy"

<span class="code">let</span> nameSymbol = Symbol("name");

// throws error
<span class="code">Object</span>.defineProperty(proxy, nameSymbol , {
    value: "proxy"
});
          </pre>
      </dd>
    </dl>
    <p>В този код,
      <em>defineProperty proxy trap</em> връща
      <em>false</em>, когато
      <em>key</em> е символ, в противен случай продължава с поведението по подразбиране. Когато
      <em>Object.defineProperty()</em> се извика с ключ "name", той успява защото ключът е
      <em>string</em>. Когато
      <em>Object.defineProperty()</em> се извика с
      <em>nameSymbol</em>, хвърля грешка, защото
      <em>definePropert trap</em> връща
      <em>false</em>.</p>
    <dl>
      <dd>
        <div class="info">
          <img src="./img/info.jpg" alt="info">
        </div>
        <strong>Може също така,
          <em>Object.defineProperty()</em> тихо да се провали, като върне
          <em>true</em> и да не извика
          <em>Reflect.defineProperty()</em>. Това ще подтисне грешката, докато всъщност не определя свойство.</strong>
      </dd>
    </dl>
    <h3>Descriptor Object Restrictions</h3>
    <p>За да осигури последователно поведение при използване на
      <em>Object.defineProperty()</em> и
      <em>Object.getOwnPropertyDescriptor()</em> методите,
      <em>descriptor</em> обектите подадени към
      <em>defineProperty trap</em> се нормализират. Обектите върнати от
      <em>getOwnPropertyDescriptor() trap</em> винаги сe валидират по същата причина.</p>
    <p>Без значение е какъв обект се подава, като трети аргумент на
      <em>Object.defineProperty()</em> метода, само свойствата
      <em>enumerable, configurable, value, writable, get</em> и
      <em>set</em> ще бъдат в обекта на
      <em>descriptor</em> подаден към
      <em>defineProperty trap</em>. Например:</p>
    <dl>
      <dd>
        <pre class="highlight-overflow">
<span class="code">let</span> proxy = <span class="code">new Proxy</span>({}, {
    defineProperty(trapTarget, key, descriptor) {
        console.log(descriptor.value);              // "proxy"
        console.log(descriptor.name);               // undefined

        <span class="code">return</span> Reflect.defineProperty(trapTarget, key, descriptor);
    }
})


<span class="code">Object</span>.defineProperty(proxy, "name", {
    value: "proxy",
    name: "custom"
});
          </pre>
      </dd>
    </dl>
    <p>Тука,
      <em>Object.defineProperty()</em> се извиква с нестандартното свойство
      <em>name</em>, като трети аргумент. Когато
      <em>defineProperty trap</em> се извика,
      <em>descriptor</em> обекта не разполага със свойство
      <em>name</em>, но има свойство
      <em>value</em>. Това е така, защото
      <em>descriptor</em> не е препратка към действителния трети аргумент на
      <em>Object.defineProperty()</em>, а по-скоро е нов обект, който съдържа само допустимите свойства.
      <em>Reflect.defineProperty()</em> метода, също така пренебрегва всякакви нестандартни свойства на
      <em>descriptor</em>.</p>
    <p>The
      <em>getOwnPropertyDescriptor trap</em> има малко по-различно ограничение, което изисква върнатата стойност да бъде
      <em>null, undefined</em> или
      <em>object</em>. Ако се връща обект, само
      <em>enumerable, configurable, value, writable, get</em> и
      <em>set</em> са позволени, като собствени свойства на обекта. Грешка се хвърля, ако се върне обект със собствено свойство,
      което не е разрешено, например:</p>
    <dl>
      <dd>
        <pre class="highlight-overflow">
<span class="code">let</span> proxy = <span class="code">new Proxy</span>({}, {
    getOwnPropertyDescriptor(trapTarget, key) {
        <span class="code">return</span> {
            name: "proxy";
        };
    }
});

// throws error
<span class="code">let</span> descriptor = <span class="code">Object</span>.getOwnPropertyDescriptor(proxy, "name");
            
          </pre>
      </dd>
    </dl>
    <p>Свойството
      <em>name</em> не е допустимо, като свойство на
      <em>descriptors</em>, така че, когато
      <em>Object.getOwnPropertyDescriptor()</em> се извика,
      <em>getOwnPropertyDescriptor</em> връща стойност, която предизвиква грешка. Това ограничение гарантира, че стойността върната
      от
      <em>Object.getOwnPropertyDescriptor()</em> винаги има надеждна структура, независимо от използването на
      <em>proxies</em>.</p>
    <h3>Дублиране на Descriptor методи</h3>
    <p>За пореден път, ECMAScript 6 има някои объркващо подобни методи, като
      <em>Object.defineProperty()</em> и
      <em>Object.getOwnPropertyDescriptor()</em>, които изглежда, че правят същото нещо, като
      <em>Reflect.defineProperty()</em> и
      <em>Reflect.getOwnPropertyDescriptor()</em> методите, съответно. Както и при другите двойки методи, обсъдени по-рано в
      тази глава, има някои фини но важни разлики.</p>
    <h4>Методите defineProperty ()</h4>
    <p>
      <em>Object.defineProperty()</em> и
      <em>Reflect.defineProperty()</em> методите са абсолютно същите с изключение на стойностите им за връщане.
      <em>Object.defineProperty()</em> метода връща първия аргумент, докато
      <em>Reflect.defineProperty()</em> връща
      <em>true</em> ако операцията е успешна и
      <em>false</em> ако не е. Например:</p>
    <dl>
      <dd>
        <pre class="highlight-overflow">
<span class="code">let</span> target = {};

<span class="code">let</span> result1 = <span class="code">Object</span>.defineProperty(target, "name", { value: "target "});

console.log(target === result1);        // true

<span class="code">let</span> result2 = Reflect.defineProperty(target, "name", { value: "reflect" });

console.log(result2);                   // true
          </pre>
      </dd>
    </dl>
    <p>Когато
      <em>Object.defineProperty()</em> се извика върху
      <em>target</em>, върнатата стойност е
      <em>target</em>. Когато
      <em>Reflect.defineProperty()</em> се извика върху
      <em>target</em>, върнатата стойност е
      <em>true</em>, което показва, че операцията е успяла. Тъй като,
      <em>defineProperty proxy trap</em> изисква да бъде върната булевата стойност, е по-добре да се използва
      <em>Reflect.defineProperty()</em> за да изпълни поведението по подразбиране, когато е необходимо.</p>
    <h4>Методите getOwnPropertyDescriptor ()</h4>
    <p>
      <em>Object.getOwnPropertyDescriptor()</em> метода коригира своя първи аргумент в обект, когато се подава примитивна стойност
      и след това продължава операцията. От друга страна
      <em>Reflect.getOwnPropertyDescriptor()</em> хвърля грешка ако първият аргумент е примитивна стойност. Ето един пример:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> descriptor1 = <span class="code">Object</span>.getOwnPropertyDescriptor(2, "name");
console.log(descriptor1);       // undefined

// throws an error
<span class="code">let</span> descriptor2 = Reflect.getOwnPropertyDescriptor(2, "name");
          </pre>
      </dd>
    </dl>
    <p>
      <em>Object.getOwnPropertyDescriptor()</em> метода връща
      <em>undefined</em>, защото коригира 2 в обект и този обект не разполага с
      <em>name</em> свойство. Това е стандартно поведение на метода, когато свойство с дадено име не е намерено в даден обект.
      Обаче, когато
      <em>Reflect.getOwnPropertyDescriptor()</em> се извика, незабавно се хвърля грешка, защото този метод не приема примитивни
      стойности за първи аргумент.</p>
    <h3>The ownKeys Trap</h3>
    <p>The
      <em>ownKeys proxy trap</em> прихваща вътрешния метод [[OwnPropertyKeys]] и позволява да се замени това поведение, като
      връща
      <em>array</em> от стойности. Този
      <em>array</em> се използва в четири метода:
      <em>Object.keys()</em>,
      <em>Object.getOwnPropertyNames(), Object.getOwnPropertySymbols()</em> и
      <em>Object.assign()</em> (
      <em>Object.assign()</em> метода използва
      <em>array</em> за да определи, кои свойства са за копиране).</p>
    <p>Поведението по подразбиране за
      <em>Object.keys()</em> се прилага от
      <em>Reflect.ownKeys()</em> метода и връща
      <em>array</em> с всички собствени ключове, включително
      <em>strings</em> и
      <em>symbols</em>.
      <em>Object.getOwnProperyNames()</em> и
      <em>Object.keys()</em>, филтрират символи от
      <em>array</em> и връщат резултата, докато
      <em>Object.getOwnPropertySymbols()</em> филтрира
      <em>strings</em> от
      <em>array</em> и връща резултата.
      <em>Object.assign()</em> метода използва
      <em>array</em>, както със
      <em>strings</em>, така и със
      <em>symbols</em>.</p>
    <p>The
      <em>ownKeys trap</em> получава един аргумент -
      <em>target</em> и винаги трябва да върне
      <em>array</em> или масиво-подобен обект (в противен случай хвърля грешка). С използването на
      <em>ownKeys trap</em> можете, например, да филтрирате определени ключови свойства, които не искате да се използват от
      <em>Object.keys()</em>,
      <em>Object.getOwnPropertyNames(), Object.getOwnPropertySymbols()</em> или
      <em>Object.assign()</em>. Да предположим, че вие не искате да се включат всички имена на свойства, които започват с долна
      черта на характера, което е обща нотация за означаване в JavaScript, показваща, че полето е частно. Можете да използвате
      <em>ownKeys trap</em> да филтрира тези ключове:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> proxy = <span class="code">new Proxy</span>({}, {
    ownKeys(trapTarget) {
        <span class="code">return</span> Reflect.ownKeys(trapTarget).filter(key => {
            <span class="code">return typeof</span> key !== "string" || key[0] !== "_";
        });
    }
});

<span class="code">let</span>nameSymbol = Symbol("name");

proxy.name = "proxy";
proxy._name = "private";
proxy[nameSymbol] = "symbol";

<span class="code">let</span> names = <span class="code">Object</span>.getOwnPropertyNames(proxy),
    symbols = <span class="code">Object</span>.getOwnPropertySymbols(proxy);

console.log(names.length);      // 1
console.log(names[0]);          // "proxy"

console.log(symbols.length);    // 1
console.log(symbols[0]);        // "Symbol(name)"
          </pre>
      </dd>
    </dl>
    <p>Този пример използва
      <em>ownKeys trap</em>, който първо извиква
      <em>Reflect.ownKeys()</em> за да получи списък по подразбиране на ключовете на целта. После,
      <em>filter()</em> метода се използва за филтриране на ключовете, които са
      <em>strings</em> и започват с долна черта. След това, се добавят три свойства на
      <em>proxy</em> обекта:
      <em>name, _name</em> и
      <em>nameSymbol</em>. Когато
      <em>Object.getOwnPropertyNames()</em> и
      <em>Object.keys()</em> се извикат върху
      <em>proxy</em>, само
      <em>name</em> свойството се връща. По същия начин, само
      <em>nameSymbol</em> се връща, когато
      <em>Object.getOwnPropertySymbols()</em> се извика върху
      <em>proxy</em>. Свойството
      <em>_name</em> не присъства в нито един резултат, тъй като е било филтрирано.</p>
    <p>Докато
      <em>ownKeys proxy trap</em> позволява да променяме върнатите ключовете от малък набор от операции, това не засяга по-често
      използваните операции, като
      <em>for-of</em> цикли или
      <em>Object.keys()</em> метода. Тези, които не могат да се променят с помощта на
      <em>proxy</em>.</p>
    <dl>
      <dd>
        <div class="info">
          <img src="./img/info.jpg" alt="info">
        </div>
        <strong>
          <em>ownKeys trap</em> също се отразява на
          <em>for-in</em> цикъла, като извиква
          <em>trap</em> за да определи кои ключове да използва вътре в цикъла.</strong>
      </dd>
    </dl>
    <h3>Функция Proxies с apply и construct traps</h3>
    <p>От всички
      <em>proxy traps</em>, само
      <em>apply</em> и
      <em>construct</em> изискват
      <em>proxy target</em> да бъде функция. Както научихме в
      <a href="./03_function.html">Глава 3</a> функциите имат два вътрешни метода, [[Call]] и [[Construct]], които се изпълняват, когато една функция
      се извика без или със оператора
      <em>new</em>. The
      <em>apply</em> и
      <em>construct traps</em> съответстват на тези вътрешни методи и ни позволяват да ги заменим. Kогато дадена функция се извиква
      без
      <em>new</em>,
      <em>apply trap</em> получава, а
      <em>Reflect.apply()</em> очаква следните аргументи:</p>
    <dl>
      <dd>
        <ol>
          <li>
            <strong>trapTarget</strong> - функцията се изпълнява (
            <em>proxy target</em>).</li>
          <li>
            <strong>thisArg</strong> - стойността на
            <em>this</em> вътре във функцията по време на извикване.</li>
          <li>
            <strong>argumentsList</strong> -
            <em>array</em> от аргументи подадени към функцията.</li>
        </ol>
      </dd>
    </dl>
    <p>The
      <em>construct trap</em>, който се извиква, когато функцията се изпълнява с помощта на
      <em>new</em>, получава следните аргументи:</p>
    <dl>
      <dd>
        <ol>
          <li>
            <strong>trapTarget</strong> - функцията се изпълнява (
            <em>proxy target</em>).</li>
          <li>
            <strong>argumentsList</strong> -
            <em>array</em> от аргументи подадени към функцията.</li>
        </ol>
      </dd>
    </dl>
    <p>
      <em>Reflect.construct()</em> метода приема тези два аргумента и има трети не задължителен аргумент,
      <em>newTarget</em>. Когато се дава, аргумента
      <em>newTarget</em> уточнява стойността на
      <em>new.target</em> вътре във функцията.</p>
    <p>Взети заедно,
      <em>apply</em> и
      <em>construct traps</em> напълно контролират поведението на всяка
      <em>proxy target</em> функция. За да имитирате поведение по подразбиране на функцията, можете да направите следното:</p>
    <dl>
      <dd>
        <pre class="highlight-overflow">
<span class="code">let</span> target = <span class="code">function</span>() { <span class="code">return</span> 42 },
    proxy = <span class="code">new Proxy</span>(target, {
        apply: <span class="code">function</span>(trapTarget, thisArg, argumentList) {
            <span class="code">return</span> Reflect.apply(trapTarget, thisArg, argumentList);
        },
        construct: <span class="code">function</span>(trapTarget, argumentList) {
            <span class="code">return</span> Reflect.construct(trapTarget, argumentList);
        }
    });

<span class="comment"><em>// a proxy with a function as its target looks like a function</em></span>
console.log(<span class="code">typeof</span> proxy);                  // "function"

console.log(proxy());                       // 42

<span class="code">var</span> instance = <span class="code">new</span> proxy();
console.log(instance <span class="code">instanceof</span> proxy);     // true
console.log(instance <span class="code">instanceof</span> target);    // true
          </pre>
      </dd>
    </dl>
    <p>Този пример има функция, която връща номера 42. The
      <em>proxy</em> за тази функция използва
      <em>apply</em> и
      <em>construct traps</em> да делегират това поведение на
      <em>Reflect.apply()</em> и
      <em>Reflect.construct()</em> методите, съответно. Крайният резултат е, че
      <em>proxy</em> функцията работи, точно като
      <em>target функция</em>, включително и идентифицираща се, като функция при използване на
      <em>typeof</em>. The
      <em>proxy</em> се извиква без
      <em>new</em> за да върне 42 и после се извиква с
      <em>new</em> за да създаде обект, наречен
      <em>instance</em>. Обекта
      <em>instance</em> се счита за инстанция на
      <em>proxy</em> и
      <em>target</em> едновременно, защото
      <em>instanceof</em> използва прототипната верига за да определи тази информация. Тъй като прототипната верига не се влияе
      от това
      <em>proxy</em>, то
      <em>proxy</em> и
      <em>target</em> изглежда имат същия прототип на JavaScript машината.</p>
    <h3>Валидиране на параметрите на функция</h3>
    <p>The
      <em>apply</em> и
      <em>construct traps</em> отварят много възможности за промяна на начина, по който функцията се изпълнява. Например, да
      предположим, че искате да потвърдите, че всички аргументи са от определен тип. Можете да проверите аргументите в
      <em>apply trap</em>:</p>
    <dl>
      <dd>
        <pre class="highlight-overflow">
<span class="comment"><em>// добавя заедно всички аргументи</em></span>
<span class="code">function</span> sum(...values) {
    <span class="code">return</span> values.reduce((previous, current) => previous + current, 0);
}

<span class="code">let</span> sumProxy = <span class="code">new Proxy</span>(sum, {
        apply: <span class="code">function</span>(trapTarget, thisArg, argumentList) {

            argumentList.forEach((arg) => {
                 <span class="code">if</span> ( <span class="code">typeof</span> arg !== "number") {
                     <span class="code">throw new</span> TypeError("All arguments must be numbers.");
                }
            });

             <span class="code">return</span> Reflect.apply(trapTarget, thisArg, argumentList);
        },
        construct: <span class="code">function</span>(trapTarget, argumentList) {
            <span class="code">throw new</span> TypeError("This function can't be called with new.");
        }
    });

console.log(sumProxy(1, 2, 3, 4));          // 10

<span class="comment"><em>// хвърля грешка</em></span>
console.log(sumProxy(1, "2", 3, 4));

<span class="comment"><em>// също хвърля грешка</em></span>
<span class="code">let</span> result = <span class="code">new</span> sumProxy();
          </pre>
      </dd>
    </dl>
    <p>Този пример използва
      <em>apply trap</em> за да гарантира, че всички аргументи са числа. Функцията
      <em>sum()</em> добавя всички аргументи, които са и подадени. Ако и се подаде не-номер стойност, функцията все пак ще изпълни
      операция, която може да доведе до неочаквани резултати. Чрез увиването на
      <em>sum()</em> в
      <em>proxy</em> извиквайки
      <em>sumProxy()</em>, този код прихваща извикванията на функции и гарантира, че всеки аргумент е номер, преди да позволи
      повикването да продължи. За да е сигурно, кода също използва
      <em>construct trap</em> за да гарантира, че функциите не могат да бъдат извикани с
      <em>new</em>.</p>
    <p>Можете също да направите обратното и да гарантирате, че дадена функция трябва да бъде извикана с
      <em>new</em> и да валидирате аргументите да бъдат числа:</p>
    <dl>
      <dd>
        <pre class="highlight-overflow">
<span class="code">function</span> Numbers(...values) {
    <span class="code">this</span>.values = values;
}

<span class="code">let</span> NumbersProxy = <span class="code">new Proxy</span>(Numbers, {

        apply: <span class="code">function</span>(trapTarget, thisArg, argumentList) {
            <span class="code">throw new</span> TypeError("This function must be called with new.");
        },

        construct: <span class="code">function</span>(trapTarget, argumentList) {
            argumentList.forEach((arg) => {
                <span class="code">if</span> (<span class="code">typeof</span> arg !== "number") {
                    <span class="code">throw new</span> TypeError("All arguments must be numbers.");
                }
            });

            <span class="code">return</span> Reflect.construct(trapTarget, argumentList);
        }
    });

<span class="code">let</span> instance = <span class="code">new</span> NumbersProxy(1, 2, 3, 4);
console.log(instance.values);               // [1,2,3,4]

// throws error
NumbersProxy(1, 2, 3, 4);
            
          </pre>
      </dd>
    </dl>
    <p>Тука,
      <em>apply trap</em> хвърля грешка, докато
      <em>construct trap</em> използва
      <em>Reflect.construct()</em> метода за валидиране на входа и връща нова инстанция. Разбира се можете да постигнете същото
      нещо без
      <em>proxies</em>, ако използвате
      <em>new.target</em>.</p>
    <h3>Извикване на конструктора без new</h3>
    <p>В
      <a href="./03_function.html">Глава 3</a> въведохме
      <em>new.target metaproperty</em>. Да преговорим,
      <em>new.target</em> е препратка към функция, която се извиква с
      <em>new</em>, което означава, че можете да разберете дали дадена функция се извиква с използване на
      <em>new</em> или не, чрез проверка на стойността на
      <em>new.target</em>, подобно на това:</p>
    <dl>
      <dd>
        <pre class="highlight-overflow">
<span class="code">function</span> Numbers(...values) {

    <span class="code">if</span> (<span class="code">typeof new</span>.target === "undefined") {
        <span class="code">throw new</span> TypeError("This function must be called with new.");
    }

    <span class="code">this</span>.values = values;
}

<span class="code">let</span> instance = <span class="code">new</span> Numbers(1, 2, 3, 4);
console.log(instance.values);               // [1,2,3,4]

// throws error
Numbers(1, 2, 3, 4);
            
          </pre>
      </dd>
    </dl>
    <p>Този пример хвърля грешка, когато
      <em>Numbers</em> се извиква без
      <em>new</em>, което е подобно на примера в секцията "Валидиране на параметрите на функция", но без използване на
      <em>proxy</em>. Писане на код, като този е много по-лесно, от колкото с използване на
      <em>proxy</em> и е за предпочитане, ако единствената ви цел е да предотвратите извикване на функция без
      <em>new</em>. Обаче, понякога нямате контрол над функцията, чието поведение трябва да се измени. В този случай използването
      на
      <em>proxy</em> има смисъл.</p>
    <p>Да предположим, че функцията
      <em>Numbers</em> дефинирана в кода не може да се променя. Вие знаете, че кода разчита на
      <em>new.target </em>и искате да избегнете тази проверка, като все още можете да извиквате функцията. Поведението при използване
      на
      <em>new</em> е вече дефинирано, така че просто можете да използвате
      <em>apply trap</em>:</p>
    <dl>
      <dd>
        <pre class="highlight-overflow">
<span class="code">function</span> Numbers(...values) {

    <span class="code">if</span> (<span class="code">typeof new</span>.target === "undefined") {
        <span class="code">throw new</span> TypeError("This function must be called with new.");
    }

    <span class="code">this</span>.values = values;
}


<span class="code">let</span> NumbersProxy = <span class="code">new Proxy</span>(Numbers, {
        apply: <span class="code">function</span>(trapTarget, thisArg, argumentsList) {
            <span class="code">return</span> Reflect.construct(trapTarget, argumentsList);
        }
    });


<span class="code">let</span> instance = NumbersProxy(1, 2, 3, 4);
console.log(instance.values);               // [1,2,3,4]
            
          </pre>
      </dd>
    </dl>
    <p>Функцията
      <em>NumbersProxy</em> ви позволява да извикате
      <em>Numbers</em> без да използвате
      <em>new</em> и тя да се държи така, все едно, че е използван
      <em>new</em>. За да направите това,
      <em>apply trap</em> извиква
      <em>Reflect.construct()</em> с аргументите подадени в
      <em>apply</em>. Правейки това означава, че
      <em>new.target</em> вътрешно в
      <em>Numbers</em> е равно на
      <em>Numbers</em> и следователно няма хвърли грешка. Въпреки, че това е един прост пример за модифициране на
      <em>new.target</em>, можете да го направите по-директен.</p>
    <h3>Overriding Abstract Base Class Constructors</h3>
    <p>Можете да отидете една стъпка напред и да посочите трети аргумент на
      <em>Reflect.construct()</em>, като специфична стойност за присвояване от
      <em>new.target</em>. Това е полезно, когато една функция проверява
      <em>new.target</em> срещу известна стойност, също като при създаването на абстрактен базов клас конструктор (обсъден в
      <a href="09_classes.html">Глава 9</a>). В абстрактния базов клас конструктор,
      <em>new.target</em> се очаква да бъде нещо различно от себе си в конструктора на класа, като в този пример:</p>
    <dl>
      <dd>
        <pre class="highlight-overflow">
<span class="code">class</span> AbstractNumbers {

    constructor(...values) {
        <span class="code">if</span> (<span class="code">new.target</span> === AbstractNumbers) {
            <span class="code">throw new</span> TypeError("This function must be inherited from.");
        }

        <span class="code">this</span>.values = values;
    }
}

<span class="code">class</span> Numbers <span class="code">extends</span> AbstractNumbers {}

<span class="code">let</span> instance = <span class="code">new</span> Numbers(1, 2, 3, 4);
console.log(instance.values);           // [1,2,3,4]

// throws error
<span class="code">new</span> AbstractNumbers(1, 2, 3, 4);
            
          </pre>
      </dd>
    </dl>
    <p>Когато
      <em>new AbstractNumbers()</em> се извика,
      <em>new.target</em> е равен на
      <em>AbstractNumbers</em> и се хвърля грешка. Извикването на
      <em>new Numbers()</em> все още работи, защото
      <em>new.targetis</em> е равен на
      <em>Numbers</em>. Можете да заобиколите това ограничение, чрез ръчно задаване на
      <em>new.target</em> с
      <em>proxy</em>:</p>
    <dl>
      <dd>
        <pre class="highlight-overflow">
<span class="code">class</span> AbstractNumbers {

    constructor(...values) {
        <span class="code">if</span> (<span class="code">new</span>.target === AbstractNumbers) {
            <span class="code">throw new </span>TypeError("This function must be inherited from.");
        }

        <span class="code">this</span>.values = values;
    }
}

<span class="code">let</span> AbstractNumbersProxy = <span class="code">new Proxy</span>(AbstractNumbers, {
        construct: function(trapTarget, argumentList) {
            <span class="code">return</span> Reflect.construct(trapTarget, argumentList, <span class="code">function</span>() {});
        }
    });


<span class="code">let</span> instance = <span class="code">new</span> AbstractNumbersProxy(1, 2, 3, 4);
console.log(instance.values);               // [1,2,3,4]
          </pre>
      </dd>
    </dl>
    <p>
      <em>AbstractNumbersProxy</em> използва
      <em>construct trap</em> за да прекъсне извикването към
      <em>new AbstractNumbersProxy()</em> метода. След това,
      <em>Reflect.construct()</em> метода се извиква с аргументи от
      <em>trap</em> и добавя празна функция, като аргумент. Тази празна функция се използва, като стойност на
      <em>new.target</em> във вътрешността на конструктора. Понеже
      <em>new.target</em> не е равен на
      <em>AbstractNumbers</em>, няма хвърлена грешка и конструктора се изпълнява напълно.</p>
    <h3>Изискуем клас конструктор</h3>
    <p>В
      <a href="09_classes.html">Глава 9</a> научихме, че клас конструктора винаги трябва да се извиква с
      <em>new</em>. Това се случва, защото вътрешния [[Call]] метод за клас конструктори е настроен да хвърли грешка. Но
      <em>proxies</em> могат да прихващат извикванията към [[Call]], което означава, можете да създадете ефективно изискуеми
      клас конструктори с помощта на
      <em>proxy</em>. Например, ако искате клас конструктора да работи без да използва
      <em>new</em>, можете да използвате
      <em>apply trap</em> да създаде нова инстанция. Ето един примерен код:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">class</span> Person {
    constructor(name) {
        <span class="code">this</span>.name = name;
    }
}

<span class="code">let</span> PersonProxy = <span class="code">new Proxy</span>(Person, {
        apply: <span class="code">function</span>(trapTarget, thisArg, argumentList) {
            <span class="code">return new </span>trapTarget(...argumentList);
        }
    });


<span class="code">let</span> me = PersonProxy("Nicholas");
console.log(me.name);                   // "Nicholas"
console.log(me <span class="code">instanceof</span> Person);      // true
console.log(me <span class="code">instanceof</span> PersonProxy); // true
            
          </pre>
      </dd>
    </dl>
    <p>Обекта
      <em>PersonProxy</em> е
      <em>proxy</em> на
      <em>Person</em> клас конструктора. Клас конструкторите са само функции, така че се държат като функции, когато се използват
      в
      <em>proxies</em>. The
      <em>apply trap</em> отменя поведението по подразбиране и вместо това връща нова инстанция на
      <em>trapTarget</em>, която е равна на
      <em>Person</em> (Аз използвах
      <em>trapTarget</em> за да покажа, че не е нужно ръчно да определяте класа). The
      <em>argumentList</em> се подава към
      <em>trapTarget</em> с помощта на оператора
      <em>spread</em>, за да подаде всеки аргумент по отделно. Извикването на
      <em>PersonProxy()</em> без използване на
      <em>new</em> връща инстанция на
      <em>Person</em>. Ако се опитаме да извикаме
      <em>Person()</em> без
      <em>new</em>, конструктора все още ще хвърли грешка. Създаване на изискуеми клас конструктори е нещо, което е възможно
      само с помощта на
      <em>proxies</em>.</p>
    <h3>Отмяна на Proxies</h3>
    <p>Обикновено,
      <em>proxy</em> не може да бъде разкачен от
      <em>target</em>, след като
      <em>proxy</em> вече е бил създаден. Всички примери до този момент в тази глава използват неотменими
      <em>proxies</em>. Въпреки това, може да има ситуации, когато да искаме да
      <em>revoke</em> (отменим)
      <em>proxy</em>, така че той вече да не може да се използва. Ще откриете, че най-полезно е да се отмени
      <em>proxy</em>, когато искате да се осигури обект чрез API за целите на сигурността и да поддържа възможността да се отреже
      достъпа до някои функции във някаква точка от времето.</p>
    <p>Отмяна на
      <em>proxies</em> се създават с помощта на метода
      <em>Proxy.revocable()</em>, който има същите аргументи, както
      <em>Proxy constructor - target object</em> и
      <em>proxy handler</em>. Върнатата стойност е обект със следните свойства:</p>
    <dl>
      <dd>
        <ol>
          <li>
            <strong>proxy</strong> - обекта
            <em>proxy</em>, който да бъде отменен</li>
          <li>
            <strong>revoke</strong> - функция извикваща
            <em>revoke</em> на
            <em>proxy</em>
          </li>
        </ol>
      </dd>
    </dl>
    <p>Когато функцията
      <em>revoke()</em> се извика, няма по-нататъшни операции, които могат да се извършат с
      <em>proxy</em>. Всеки опит за взаимодействие с
      <em>proxy object</em> ще предизвика
      <em>proxy trap</em> да хвърли грешка. Например:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> target = {
    name: "target"
};

<span class="code">let</span> { proxy, revoke } = <span class="code">Proxy</span>.revocable(target, {});

console.log(proxy.name);        // "target"

revoke();

// throws error
console.log(proxy.name);
          </pre>
      </dd>
    </dl>
    <p>Този пример създава отмяна на
      <em>proxy</em>. Той използва
      <em>destructuring</em> за да присвои
      <em>proxy</em> и
      <em>revoke</em> променливите към свойства със същото име на обекта върнат от
      <em>Proxy.revocable()</em> метода. След това,
      <em>proxy</em> обекта, може да се използва само, като неотменим
      <em>proxy</em> обект, така
      <em>proxy.name</em> връща "target", защото минава през
      <em>target.name</em>. След като, се извика функцията
      <em>revoke()</em>, обаче,
      <em>proxy</em> вече не функционира. Опита за достъп до
      <em>proxy.name</em> хвърля грешка, както и за всяка друга операция, която разчита на
      <em>proxy traps</em>.</p>
    <h3>Решаване на Array проблема</h3>
    <p>В началото на тази глава, аз обясних как програмистите не могат да имитират поведението на
      <em>array</em> в JavaScript преди ECMAScript 6.
      <em>Proxies</em> и
      <em>reflection API</em> ви позволяват да създадете обект, който се държи по същия начин, както вградения
      <em>Array</em>, когато се добавят и отстраняват свойства. За да опресните паметта си, ето един пример, показващ поведението,
      което
      <em>proxies</em> помагат да имитирате:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> colors = ["red", "green", "blue"];

console.log(colors.length);        // 3

colors[3] = "black";

console.log(colors.length);        // 4
console.log(colors[3]);            // "black"

colors.length = 2;

console.log(colors.length);         // 2
console.log(colors[3]);             // undefined
console.log(colors[2]);             // undefined
console.log(colors[1]);             // "green"
          </pre>
      </dd>
    </dl>
    <p>Има две особено важни поведения, които се забелязват в този пример:</p>
    <dl>
      <dd>
        <ol>
          <li>Свойството
            <em>length</em> се увеличава на 4, когато на
            <em>colors[3]</em> се задава стойност.</li>
          <li>Последните две позиции в
            <em>array</em> се изтриват, когато
            <em>length</em> свойството се определи на 2.</li>
        </ol>
      </dd>
    </dl>
    <p>Тези две поведения са единствените, които трябва да се имитират точно, за да се пресъздаде работата на вградените
      <em>arrays</em>. Следващите няколко точки описват, как да се направи един обект, който правилно да ги имитира.</p>
    <h3>Откриване на индексите на array</h3>
    <p>Имайте предвид, че определяне на цяло число, като свойство за ключове е специален случай за
      <em>arrays</em>, като те се третират по различен начин от ключовете не цяло число. Спецификацията на ECMAScript 6 дава
      инструкции затова, как да се определи дали свойството за ключове е индекс на
      <em>array</em>:</p>
    <dl>
      <dd style="color: cornflowerblue">
        <em>String</em> свойството
        <em>P</em> е индекс на
        <em>array</em>, ако и само ако
        <em>ToString(ToUint32(P))</em> е равно на
        <em>P</em> и
        <em>ToUint32(P)</em> не е равно на 2
        <sup>32</sup>-1.</dd>
    </dl>
    <p>Тази операция може да се приложи в JavaScript, както следва:</p>
    <dl>
      <dd>
        <pre class="highlight-overflow">
<span class="code">function</span> toUint32(value) {
  <span class="code">return Math.</span>floor(<span class="code">Math</span>.abs(<span class="code">Number</span>(value))) % <span class="code">Math</span>.pow(2, 32);
}

  <span class="code">function</span> isArrayIndex(key) {
  <span class="code">let</span> numericKey = toUint32(key);
  <span class="code">return String</span>(numericKey) == key && numericKey < (<span class="code">Math.</span>.pow(2, 32) - 1);
}  
          </pre>
      </dd>
    </dl>
    <p>Функцията
      <em>toUint32()</em> превръща дадена стойност в положително 32-битово цяло число, като се използва алгоритъма описан в спецификацията.
      Функцията
      <em>isArrayIndex()</em> първо преобразува ключа в
      <em>uint32</em> и след това изпълнява сравненията за да определи, дали ключът е индекс на
      <em>array</em> или не. С предоставянето на тези полезни функции, можете да започнете да прилагате един обект, който ще
      имитира вграден
      <em>array</em>.</p>
    <h4>Увеличаване на дължината при добавяне на нови елементи</h4>
    <p>Може би сте забелязали, че двете поведения на
      <em>array</em>, които описах разчитат на прехвърлянето на свойство. Това означава, че наистина само трябва да използвате
      <em>set proxy trap</em> да постигнете и двете поведения. За да започнете, ето един пример, който реализира първото от двете
      поведения чрез увеличаване на
      <em>length</em> свойството, когато се използва индекс на
      <em>array</em> по-голям от
      <em>length - 1</em>:</p>
    <dl>
      <dd>
        <pre class="highlight-overflow">
<span class="code">function</span> toUint32(value) {
  <span class="code">return Math.</span>floor(<span class="code">Math</span>.abs(<span class="code">Number</span>(value))) % <span class="code">Math</span>.pow(2, 32);
}

  <span class="code">function</span> isArrayIndex(key) {
  <span class="code">let</span> numericKey = toUint32(key);
  <span class="code">return String</span>(numericKey) == key && numericKey < (<span class="code">Math.</span>.pow(2, 32) - 1);
}

<span class="code">function</span> createMyArray(length=0) {
  <span class="code">return new Proxy</span>({ length }, {
    set(trapTarget, key, value) {

      <span class="code">let</span> currentLength = Reflect.get(trapTarget, "length");

      <span class="comment"><em>// специален случай</em></span>
      <span class="code">if</span> (isArrayIndex(key)) {
          <span class="code">let</span> numericKey = <span class="code">Number</span>(key);

          <span class="code">if</span> (numericKey >= currentLength) {
              Reflect.set(trapTarget, "length", numericKey + 1);
          }
      }

      <span class="comment"><em>// винаги прави това независимо от типа на ключа</em></span>
      <span class="code">return</span> Reflect.set(trapTarget, key, value);
    }
  });
}

<span class="code">let</span> colors = createMyArray(3);
console.log(colors.length);         // 3

colors[0] = "red";
colors[1] = "green";
colors[2] = "blue";

console.log(colors.length);         // 3

colors[3] = "black";

console.log(colors.length);         // 4
console.log(colors[3]);             // "black" 
          </pre>
      </dd>
    </dl>
    <p>Този пример използва
      <em>set proxy trap</em> за да се намеси при определянето на индекса на
      <em>array</em>. Ако ключът е индекс на
      <em>array</em>, то тогава се преобразува в число, защото ключовете винаги се подават, като
      <em>string</em>. След това, ако тази числова стойност е по-голяма или равна на текущото
      <em>length</em> свойството, тогава
      <em>length</em> свойството се актуализира, да бъде с едно повече от цифровия ключ (създаване на обект с позиция 3 означава,
      че
      <em>length</em> трябва да бъде 4). След това, поведението по подразбиране за създаване на свойство се използва направо
      в
      <em>Reflect.set()</em>, тъй като искате свойството да получи стойността, както е посочена.</p>
    <p>Първоначално потребителския
      <em>array</em> се създава с извикването на
      <em>createMyArray()</em> с дължина 3 и стойностите на тези три елемента се добавят веднага след това. Свойството
      <em>length</em> правилно остава 3, докато стойността "black" се присвои към позиция 3. В този момент
      <em>length</em> става на 4.</p>
    <p>След работата по първото поведение, е време да преминем към второто.</p>
    <h4>Изтриване на елементи за намаляване на дължината</h4>
    <p>Първото имитирано поведение на
      <em>array</em> се използва, само когато индекса на
      <em>array</em> е по-голям или равен на
      <em>length</em> свойството. Второто поведение прави обратното и премахва елементи от
      <em>array</em>, когато
      <em>length</em> свойството се настрои на по-малка стойност, от колкото преди това се съдържа. Това включва не само промяна
      на
      <em>length</em> свойството, но също и изтриване на всички елементи, които иначе биха могли да съществуват. Например ако
      един
      <em>array</em> с дължина 4, се настрои на дължина 2, елементите в позиции 2 и 3 се заличават. Можете да постигнете това
      вътре с
      <em>set proxy trap</em> заедно с първото поведение. Това отново е предишния пример с актуализация на
      <em>createMyArray</em> метода:</p>
    <dl>
      <dd>
        <pre class="highlight-overflow">
<span class="code">function</span> toUint32(value) {
  <span class="code">return Math.</span>floor(<span class="code">Math</span>.abs(<span class="code">Number</span>(value))) % <span class="code">Math</span>.pow(2, 32);
}

  <span class="code">function</span> isArrayIndex(key) {
  <span class="code">let</span> numericKey = toUint32(key);
  <span class="code">return String</span>(numericKey) == key && numericKey < (<span class="code">Math.</span>.pow(2, 32) - 1);
}

<span class="code">function</span> createMyArray(length=0) {
  <span class="code">return new Proxy</span>({ length }, {
    set(trapTarget, key, value) {

      <span class="code">let</span> currentLength = Reflect.get(trapTarget, "length");

      <span class="comment"><em>// специален случай</em></span>
      <span class="code">if</span> (isArrayIndex(key)) {
          <span class="code">let</span> numericKey = <span class="code">Number</span>(key);

          <span class="code">if</span> (numericKey >= currentLength) {
              Reflect.set(trapTarget, "length", numericKey + 1);
          }  
      } <span class="code">else if</span> (key === "length") {
          
          <span class="code">if</span> (value < currentLength) {
              <span class="code">for</span> (<span class="code">let</span> index = currentLength - 1; index >= value; index--) {
                        Reflect.deleteProperty(trapTarget, index);
              }
          }
        }
      
      <span class="comment"><em>// винаги прави това независимо от типа на ключа</em></span>
      <span class="code">return</span> Reflect.set(trapTarget, key, value);
    }
  });
}

<span class="code">let</span> colors = createMyArray(3);
console.log(colors.length);         // 3

colors[0] = "red";
colors[1] = "green";
colors[2] = "blue";
colors[3] = "black";

console.log(colors.length);         // 4

colors.length = 2;

console.log(colors.length);         // 2
console.log(colors[3]);             // undefined
console.log(colors[2]);             // undefined
console.log(colors[1]);             // "green"
console.log(colors[0]);             // "red"
          </pre>
      </dd>
    </dl>
    <p>The
      <em>set proxy trap</em> в този код, проверява дали
      <em>key</em> е "length", за да коригира останалата част на обекта правилно. Когато това се случи, текущата дължина първо
      се извлича с помощта на
      <em>Reflect.get()</em> и се сравнява с новата стойност. Ако новата стойност е по-малка от текущата дължина, тогава
      <em>for</em> цикъл изтрива всички свойства на целта и те вече не трябва да бъдат на разположение.
      <em>for</em> цикъла се движи назад по дължината на текущия
      <em>array</em> (
      <em>currentLength</em>) и изтрива всяко свойство, докато достигне до новата дължина на
      <em>array</em> (
      <em>value</em>).</p>
    <p>Този пример добавя четири цвята към
      <em>colors</em> и след това определя свойството
      <em>length</em> на 2. Това ефективно премахва елементите в позиции 2 и 3, така че те сега връщат
      <em>undefined</em>, при опит за достъп до тях. Свойството
      <em>length</em> е правилно настроено на 2 и елементите в позиции 0 и 1 все още са достъпни.</p>
    <p>С изпълнението на двете поведения лесно можете да създадете обект, който имитира поведението на вградените
      <em>arrays</em>. Но такава функция не е толкова желателна, от колкото създаването на клас за капсулиране на това поведение,
      така че следващата стъпка е да се приложи тази функционалност, като клас.</p>
    <h4>Изпълнение на MyArray Class</h4>
    <p>Най-простият начин за създаване на клас, който използва
      <em>proxy</em> е да дефинирате клас, както обикновено и след това да върнете
      <em>proxy</em> от конструктора. По този начин, върнатия обект ще бъде
      <em>proxy</em> вместо инстанцията на този клас. (Инстанцията е стойността на
      <em>this</em> вътре в конструктора.) Инстанцията става
      <em>target</em> на
      <em>proxy</em> и
      <em>proxy</em> се връща, като инстанция. Инстанцията ще бъде напълно самостоятелна и няма да можете да я достигате директно,
      ще имате достъп до нея косвено чрез
      <em>proxy</em>.</p>
    <p>Ето един прост пример за връщане на
      <em>proxy</em> от клас конструктор:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">class</span> Thing {
    constructor() {
        <span class="code">return new</span> Proxy(<span class="code">this</span>, {});
    }
}

<span class="code">let</span> myThing = <span class="code">new</span> Thing();
console.log(myThing <span class="code">instanceof</span> Thing);      // true
          </pre>
      </dd>
    </dl>
    <p>В този пример, класа
      <em>Thing</em> връща
      <em>proxy</em> от своя конструктор.
      <em>Target</em> на
      <em>proxy</em> е
      <em>this</em> и
      <em>proxy</em> се връща от конструктора. Това означава, че
      <em>myThing</em> всъщност е
      <em>proxy</em>, въпреки че е създаден с извикване на конструктора от
      <em>Thing</em>. Тъй като
      <em>proxies</em> подават своето поведение към техните
      <em>targets</em>,
      <em>myThing</em> все още се счита за инстанция на
      <em>Thing</em>, като
      <em>proxy</em> е напълно прозрачен за всеки, който използва
      <em>Thing</em> класа.</p>
    <p>Имайки това в предвид, създаването на потребителски клас
      <em>array</em>, използвайки
      <em>proxy</em> е относително ясно. Кодът е предимно същия, като кода в раздела "Изтриване на елементи за намаляване на
      дължина". Използва се същия
      <em>proxy</em> код, но този път това е вътре в клас конструктора. Ето пълния пример:</p>
    <dl>
      <dd>
        <pre class="highlight-overflow">
<span class="code">function</span> toUint32(value) {
  <span class="code">return Math.</span>floor(<span class="code">Math</span>.abs(<span class="code">Number</span>(value))) % <span class="code">Math</span>.pow(2, 32);
}

  <span class="code">function</span> isArrayIndex(key) {
  <span class="code">let</span> numericKey = toUint32(key);
  <span class="code">return String</span>(numericKey) == key && numericKey < (<span class="code">Math.</span>.pow(2, 32) - 1);
}

<span class="code">class</span> MyArray {
  <span class="code">constructor</span>(length=0) {
      <span class="code">this</span>.length = length;
      
      <span class="code">return new Proxy</span>(<span class="code">this</span>, { 
          set(trapTarget, key, value) {

            <span class="code">let</span> currentLength = Reflect.get(trapTarget, "length");

            <span class="comment"><em>// специален случай</em></span>
            <span class="code">if</span> (isArrayIndex(key)) {
                <span class="code">let</span> numericKey = <span class="code">Number</span>(key);

                <span class="code">if</span> (numericKey >= currentLength) {
                    Reflect.set(trapTarget, "length", numericKey + 1);
                }  
            } <span class="code">else if</span> (key === "length") {
          
                <span class="code">if</span> (value < currentLength) {
                    <span class="code">for</span> (<span class="code">let</span> index = currentLength - 1; index >= value; index--) {
                        Reflect.deleteProperty(trapTarget, index);
                    }
                }
            }
      
            <span class="comment"><em>// винаги прави това независимо от типа на ключа</em></span>
            <span class="code">return</span> Reflect.set(trapTarget, key, value);
        }
    });
  }
}

<span class="code">let</span> colors = <span class="code">new</span> MyArray(3);
console.log(colors <span class="code">instanceof</span> MyArray);     // true

console.log(colors.length);         // 3

colors[0] = "red";
colors[1] = "green";
colors[2] = "blue";
colors[3] = "black";

console.log(colors.length);         // 4

colors.length = 2;

console.log(colors.length);         // 2
console.log(colors[3]);             // undefined
console.log(colors[2]);             // undefined
console.log(colors[1]);             // "green"
console.log(colors[0]);             // "red"
          </pre>
      </dd>
    </dl>
    <p>Този код създава
      <em>MyArray</em> клас, който връща
      <em>proxy</em> от конструктора си. Свойството
      <em>length</em> се добавя в конструктора (като се инициализира със стойността, която се подава във или със стойност по
      подразбиране 0) и след това се създава
      <em>proxy</em> и се въръща. Това дава на променливата
      <em>colors</em> облик на точно копие на
      <em>MyArray</em> и изпълнява двете основни поведения за
      <em>arrays</em>.</p>
    <p>Въпреки, че връщането на
      <em>proxy</em> от клас конструктор е лесно, това не означава, че се създава ново
      <em>proxy</em> за всеки отделен случай. Има, обаче, един начин всички случаи да споделят едно
      <em>proxy</em>: можете да използвате
      <em>proxy</em>, като прототип.</p>
    <h3>Използване на
      <em>Proxy</em>, като Prototype</h3>
    <p>
      <em>Proxies</em> могат да бъдат използвани, като прототипи, но това е малко по-ангажиращо от предишните примери в тази
      глава. Когато
      <em>proxy</em> е прототип,
      <em>proxy traps</em> се извикват само, когато операцията е по подразбиране и обикновено продължава към прототипа, което
      ограничава възможностите на
      <em>proxy</em>, като прототип. Помислете за този пример:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> target = {};
<span class="code">let</span> newTarget = <span class="code">Object</span>.create(<span class="code">new</span> Proxy(target, {

    <span class="comment"><em>// никога не се извиква</em></span>
    defineProperty(trapTarget, name, descriptor) {

        <span class="comment"><em>// ще доведе до грешка, ако се извика</em></span>
        <span class="code">return false</span>;
    }
}));

<span class="code">Object</span>.defineProperty(newTarget, "name", {
    value: "newTarget"
});

console.log(newTarget.name);                    // "newTarget"
console.log(newTarget.hasOwnProperty("name"));  // true
          </pre>
      </dd>
    </dl>
    <p>Обекта
      <em>NewTarget</em> е създаден с
      <em>proxy</em>, като прототип. Правейки
      <em>target</em> на
      <em>proxy target</em>, ефективно прави
      <em>target</em> прототип на
      <em>newTarget</em>, защото
      <em>proxy</em> е прозрачен. Сега
      <em>proxy traps</em> ще бъдат извикани само ако операция на
      <em>newTarget</em> подаде операцията да се случи в
      <em>target</em>.</p>
    <p>Метода
      <em>Object.defineProperty()</em> се извиква в
      <em>newTarget</em> за да създадете собствено свойство, наречено
      <em>name</em>. Дефиниране на свойство върху обект не е операция, която обикновено продължава да е прототип на обекта, така
      че никога не се извиква
      <em>defineProperty trap</em> на
      <em>proxy</em> и свойството
      <em>name</em> се добавя към
      <em>newTarget</em>, като собствено свойство.</p>
    <p>Докато
      <em>proxies</em> са силно ограничени, когато се използват, като прототипи, има някои
      <em>traps</em>, които все още са полезни.</p>
    <h4>Използване на get trap в Prototype</h4>
    <p>Когато вътрешния [[Get]] метод се извика да чете свойство, операцията първо се оглежда за собствени свойства. Ако не
      намери собствено свойство с даденото име, след това операцията продължава към прототипа и търси свойството там. Процесът
      продължава докато няма никакви по-нататъшни прототипи за проверка.</p>
    <p>Благодарение на този процес, ако настроите
      <em>get proxy trap, trap</em> ще се извика в прототипа, когато собствено свойство с даденото име не съществува. Можете
      да използвате
      <em>get trap</em> да предотврати неочаквано поведение, като достъп до свойствата, които не можете да гарантирате, че съществуват.
      Просто създавате обект, който хвърля грешка, когато се опитвате да получите достъп до свойство, което не съществува:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> target = {};
<span class="code">let</span> thing = <span class="code">Object</span>.create(<span class="code">new</span> Proxy(target, {
    get(trapTarget, key, receiver) {
        <span class="code">throw new</span> ReferenceError(`${key} doesn't exist`);
    }
}));

thing.name = "thing";

console.log(thing.name);        // "thing"

<span class="comment"><em>// хвърля се грещка</em></span>
<span class="code">let</span> unknown = thing.unknown;
          </pre>
      </dd>
    </dl>
    <p>В този код
      <em>thing</em> обекта е създаден с
      <em>proxy</em>, като негов прототип. The
      <em>get trap</em> хвърля грешка, когато бъде извикан за да покаже, че даден ключ не съществува в
      <em>thing</em> обекта. Когато
      <em>thing.name</em> се чете, операцията никога не извиква
      <em>get trap</em> в прототипа, защото свойството съществува в
      <em>thing</em>. The
      <em>get trap</em> се извиква само, когато
      <em>thing.unknown</em>, който не съществува, е достъпен.</p>
    <p>Когато се изпълнява последния ред,
      <em>unknown</em> не е свойство на
      <em>thing</em>, така че операцията продължава в прототипа и
      <em>get trap</em> след това хвърля грешка. Този тип поведение може да бъде много полезен в JavaScript, където неизвестни
      свойства мълчаливо връщат
      <em>undefined</em>, вместо да хвърлят грешка (както се случва в други езици).</p>
    <p>Важно е да се разбере, че в този пример
      <em>trapTarget</em> и
      <em>receiver</em> са различни обекти. Когато
      <em>proxy</em> се използва, като прототип,
      <em>trapTarget</em> е самия обект прототип, докато
      <em>receiver</em> е инстанция на обекта. В този случай, това означава, че
      <em>trapTarget</em> е равен на
      <em>target</em> и
      <em>receiver</em> е равен на
      <em>thing</em>. Това ви позволява достъп, както до оригиналния обект на
      <em>proxy</em>, така и до обекта, в който операцията е трябвало да се осъществи.</p>
    <h4>Използване на set Trap в Prototype</h4>
    <p>Вътрешния [[Set]] метод също проверява за собствени свойства и след това продължава в прототипа, ако е необходимо. Когато
      присвоявате стойност на свойство на обект, стойността се присвоява на собствено свойство със същото име, ако съществува.
      Ако собствено свойство с даденото име не съществува, тогава операцията продължава в прототипа. Сложната част е, че
      въпреки че операцията на присвояване продължава в прототипа, присвояване на стойност на свойство ще създаде свойство
      на инстанцията (а не прототипа) по подразбиране, независимо дали съществува свойство с такова име в прототипа.</p>
    <p>За да получите по-добра представа, кога
      <em>set trap</em> ще бъде извикан в прототипа и кога няма. Разгледайте следния пример, който показва поведението по подразбиране:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> target = {};
<span class="code">let</span> thing = <span class="code">Object</span>.create(<span class="code">new</span> Proxy(target, {
    set(trapTarget, key, value, receiver) {
         <span class="code">return</span> Reflect.set(trapTarget, key, value, receiver);
    }
}));

console.log(thing.hasOwnProperty("name"));      // false

<span class="comment"><em>// задейства `set` proxy trap</em></span>
thing.name = "thing";

console.log(thing.name);                        // "thing"
console.log(thing.hasOwnProperty("name"));      // true

<span class="comment"><em>// не задейства `set` proxy trap</em></span>
thing.name = "boo";

console.log(thing.name);                        // "boo"
          </pre>
      </dd>
    </dl>
    <p>В този пример
      <em>target</em> започва без собствени свойства. The
      <em>thing</em> обекта има
      <em>proxy</em>, като негов прототип, който дефинира
      <em>set trap</em> за хване създаването на всякакви нови свойства. Когато
      <em>thing.name</em> присвоява "thing", като негова стойност,
      <em>set proxy trap</em> се извиква , защото
      <em>thing</em> не разполага със собствено свойство, наречено
      <em>name</em>. Вътре в
      <em>set trap, trapTarget</em> е равен на
      <em>target</em>, а
      <em>receiver</em> е равен на
      <em>thing</em>. Операцията в крайна сметка трябва да създаде ново свойство на
      <em>thing</em> и за щастие
      <em>Reflect.set()</em> изпълнява това поведение по подразбиране за вас, ако се подаде
      <em>receiver</em>, като четвърти аргумент.</p>
    <p>След като свойството
      <em>name</em> е създадено на
      <em>thing</em>, настройването на
      <em>thing.name</em> към друга стойност вече няма да извика
      <em>set proxy trap</em>. В този момент
      <em>name</em> е собствено свойство, така че [[Set]] операцията никога не продължава към прототипа.</p>
    <h4>Използване на has Trap в Prototype</h4>
    <p>Спомнете си, че
      <em>has trap</em> прихваща използването на
      <em>in</em> оператора в обекти. Операторът
      <em>in</em> първо търси за свойство на обект с това име. Ако собствено свойство с такова име не съществува, операцията
      продължава в прототипа. Ако няма собствено свойство в прототипа, тогава търсенето продължава по веригата от прототипи,
      докато свойството се установи или няма повече прототипи за търсене.</p>
    <p>The
      <em>has trap</em> се извиква последователно, само когато търсенето достигне
      <em>proxy</em> обекта в прототипната верига. Вие използвате
      <em>proxy</em>, като прототип, само когато няма собствено свойство с даденото име. За пример:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">let</span> target = {};
<span class="code">let</span> thing = <span class="code">Object</span>.create(<span class="code">new</span> Proxy(target, {
    has(trapTarget, key) {
         <span class="code">return</span> Reflect.has(trapTarget, key);
    }
}));

<span class="comment"><em>// задейства `has` proxy trap</em></span>
console.log("name" <span class="code">in</span> thing);                   // false

thing.name = "thing";

<span class="comment"><em>// не задейства `has` proxy trap</em></span>
console.log("name" <span class="code">in</span> thing);                   // true
          </pre>
      </dd>
    </dl>
    <p>Този код създава
      <em>has proxy trap</em> в прототипа на
      <em>thing</em>. The
      <em>has trap</em> не подава
      <em>receiver</em> обект, като
      <em>get</em> и
      <em>set traps</em>, защото търсенето в прототипа се случва автоматично, когато се използва оператора
      <em>in</em>. Вместо това,
      <em>has trap</em> трябва да работи само върху
      <em>trapTarget</em>, който е равен на
      <em>target</em>. Когато за първи път
      <em>in</em> оператора се използва в този пример,
      <em>has trap</em> се извиква, защото името на свойството не съществува, като собствено свойство в
      <em>thing</em>. Когато на
      <em>thing.name</em> е зададена стойност и след това
      <em>in</em> оператора се използва отново,
      <em>has trap</em> не се извиква, защото операцията спира след намирането на името на свойството в
      <em>thing</em>.</p>
    <p>Прототипните примери до този момент са центрирани около обекти, създадени с помощта на
      <em>Object.create()</em> метода. Но ако искате да създадете клас, който има
      <em>proxy</em>, като прототип, процесът е малко по-ангажиращ.</p>
    <h3>Proxies as Prototypes on Classes</h3>
    <p>Класове не могат директно да бъдат модифицирани за да използвате
      <em>proxy</em>, като прототип, защото техните
      <em>prototype</em> свойства са (
      <em>non-writable</em>) не са достъпни за писане. Можете обаче, да използвате малко заблуда за да създадете клас, който
      има
      <em>proxy</em>, като негов прототип, с помощта на наследяването. За да започнете, трябва да създадете дефиниция в ECMAScript
      5-стил, с помощта на функция конструктор. След това може да замените прототип да бъде
      <em>proxy</em>. Ето един пример:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">function</span> NoSuchProperty() {
    <span class="comment"><em>// празно</em></span>
}

NoSuchProperty.prototype = <span class="code">new Proxy</span>({}, {
    get(trapTarget, key, receiver) {
        <span class="code">throw new</span> ReferenceError(`${key} doesn't exist`);
    }
});

<span class="code">let</span> thing = <span class="code">new</span> NoSuchProperty();

<span class="comment"><em>// хвърля грешка заради `get` proxy trap</em></span> 
<span class="code">let</span> result = thing.name;
          </pre>
      </dd>
    </dl>
    <p>Функцията
      <em>NoSuchProperty</em> представлява основата, от която ще се наследи класа. Няма ограничения за прототипното свойство
      на функции, така че можете да го замените с
      <em>proxy</em>. The
      <em>get trap</em> се използва за да хвърли грешка, когато свойството не съществува. Обекта
      <em>thing</em> е създаден, като инстанция на
      <em>NoSuchProperty</em> и хвърля грешка, когато несъществуващо
      <em>name</em> свойство е достъпно.</p>
    <p>Следващата стъпка е да се създаде клас, който наследява от
      <em>NoSuchProperty</em>. Можете просто да използвате разширения синтаксис, обсъден в глава 9 за да въведете
      <em>proxy</em> в прототипната верига на класа, като това:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">function</span> NoSuchProperty() {
    <span class="comment"><em>// празно</em></span>
}

NoSuchProperty.prototype = <span class="code">new Proxy</span>({}, {
    get(trapTarget, key, receiver) {
        <span class="code">throw new</span> ReferenceError(`${key} doesn't exist`);
    }
});

<span class="code">class</span> Square <span class="code">extends</span> NoSuchProperty {
    constructor(length, width) {
        <span class="code">super</span>();
        <span class="code">this</span>.length = length;
        <span class="code">this</span>.width = width;
    }
}

<span class="code">let</span> shape = new Square(2, 6);

<span class="code">let</span> area1 = shape.length * shape.width;
console.log(area1);                         // 12

<span class="comment"><em>// хвърля се грешка, защото "wdth" не съществува</em></span>
<span class="code">let</span> area2 = shape.length * shape.wdth;
          </pre>
      </dd>
    </dl>
    <p>Класа
      <em>Square</em> наследява от
      <em>NoSuchProperty</em> и така
      <em>proxy</em> е в прототипната верига на
      <em>Square</em> класа . Обекта
      <em>shape</em> след това е създаден, като нова инстанция на
      <em>Square</em> и има две собствени свойства:
      <em>length</em> и
      <em>width</em>. Четенето на стойностите на тези свойства успява, защото
      <em>get proxy trap</em> никога не се извиква. Само когато свойство, което не съществува в
      <em>shape</em> е достъпно (
      <em>shape.wdth</em> е с очевидна правописна грешка),
      <em>get proxy trap</em> се задейства и хвърля грешка.</p>
    <p>Това доказва, че
      <em>proxy</em> е в прототипната верига на
      <em>shape</em>, но може да не е очевидно, че
      <em>proxy</em> не директен прототип на
      <em>shape</em>. В действителност
      <em>proxy</em> е няколко стъпки нагоре в прототипната верига на
      <em>shape</em>. Можете да видите това по-ясно, като леко променим предишния пример:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">function</span> NoSuchProperty() {
    <span class="comment"><em>// празно</em></span>
}

<span class="comment"><em>// съхранява референция към proxy, който ще бъде прототипът</em></span>
<span class="code">let</span> proxy = <span class="code">new Proxy</span>({}, {
    get(trapTarget, key, receiver) {
        <span class="code">throw new</span> ReferenceError(`${key} doesn't exist`);
    }
});

NoSuchProperty.prototype = proxy;

<span class="code">class</span> Square <span class="code">extends</span> NoSuchProperty {
    constructor(length, width) {
        <span class="code">super</span>();
        <span class="code">this</span>.length = length;
        <span class="code">this</span>.width = width;
    }
}

<span class="code">let</span> shape = new Square(2, 6);

<span class="code">let</span> shapeProto = <span class="code">Object</span>.getPrototypeOf(shape);

console.log(shapeProto === proxy);                  // false

<span class="code">let</span> secondLevelProto = <span class="code">Object</span>.getPrototypeOf(shapeProto);

console.log(secondLevelProto === proxy);            // true
          </pre>
      </dd>
    </dl>
    <p>Тази версия на кода съхранява
      <em>proxy</em> в променлива наречена
      <em>proxy</em>, така че лесно да се идентифицира по-късно. Прототипа на
      <em>shape</em> е
      <em>Shape.prototype</em>, което не е
      <em>proxy</em>. Но прототип на
      <em>Shape.prototype</em> е
      <em>proxy</em>, който е бил наследен от
      <em>NoSuchProperty</em>.</p>
    <p>Наследството добавя още една стъпка в прототипната верига и това има значение, защото операциите, които могат да доведат
      до извикване на
      <em>get proxy trap</em> трябва да минат през една допълнителна стъпка преди да стигнат до него. Ако има свойство в
      <em>Shape.prototype</em> това ще попречи
      <em>get proxy trap</em> да се извика, както в този пример:</p>
    <dl>
      <dd>
        <pre class="highlight">
<span class="code">function</span> NoSuchProperty() {
    <span class="comment"><em>// празно</em></span>
}

NoSuchProperty.prototype = <span class="code">new Proxy</span>({}, {
    get(trapTarget, key, receiver) {
        <span class="code">throw new</span> ReferenceError(`${key} doesn't exist`);
    }
});

<span class="code">class</span> Square <span class="code">extends</span> NoSuchProperty {
    constructor(length, width) {
        <span class="code">super</span>();
        <span class="code">this</span>.length = length;
        <span class="code">this</span>.width = width;
    }

    getArea() {
        <span class="code">return this</span>.length * <span class="code">this</span>.width;
    }
}

<span class="code">let</span> shape = new Square(2, 6);

<span class="code">let</span> area1 = shape.length * shape.width;
console.log(area1);                         // 12

<span class="code">let</span> area2 = shape.getArea();
console.log(area2);                         // 12

<span class="comment"><em>// хвърля се грешка, защото "wdth" не съществува</em></span>
<span class="code">let</span> area3 = shape.length * shape.wdth;
          </pre>
      </dd>
    </dl>
    <p>Тука, класа
      <em>Square</em> има
      <em>getArea()</em> метод. The
      <em>getArea()</em> автоматично се добавя, като метод към
      <em>Square.prototype</em>, така че когато
      <em>shape.getArea()</em> се извика, търсенето на метода
      <em>getArea()</em> започва в инстанцията на
      <em>shape</em> и след това продължава в неговия прототип. Тъй като,
      <em>getArea()</em> се намира в прототипа, търсенето спира и
      <em>proxy</em> никога не се извиква. Това всъщност е поведението, което искате в тази ситуация, тъй като не искате неправилно
      да се хвърли грешка, когато се извика
      <em>getArea()</em>.</p>
    <p>Въпреки, че това изисква малко повече допълнителен код, за създаване на клас с
      <em>proxy</em> в прототипната верига, може би си струва усилията, ако имате нужда от такава функционалност.</p>
    <h3>Обобщение</h3>
    <p>Преди ECMAScript 6, някои обекти (като
      <em>arrays</em>) показват не стандартно поведение, което програмистите не могат да възпроизведат.
      <em>Proxies</em> променят това. Те ви позволяват да дефинирате свое собствено не стандартно поведение за редица операции
      от ниско ниво в JavaScript, така че да можете да възпроизведете всички поведения на вградените в JavaScript обекти,
      чрез
      <em>proxy trap</em>. Тези
      <em>traps</em> се извикват зад кулисите, когато се извършват различни операции, например като използването на
      <em>in</em> оператора.</p>
    <p>
      <em>Reflection API</em> също е въведен в ECMAScript 6, за да позволи на програмистите да прилагат поведение по подразбиране
      за всеки
      <em>proxy trap</em>. Всеки
      <em>proxy trap</em> има съответния метод със същото име в
      <em>Reflect</em> обекта, друго ECMAScript 6 допълнение. С използването на комбинация от
      <em>proxy trap</em> и
      <em>reflection API</em> методи, е възможно да филтрирате някои операции, които да се държат различно само при определени
      условия.
    </p>
    <p>
      <em>Revocable proxies</em> са специални
      <em>proxies</em>, които могат да бъдат ефективно изключени, чрез функцията
      <em>revoke()</em>. Функцията
      <em>revoke()</em> прекратява всички функции на
      <em>proxy</em>, така че всеки опит за взаимодействие с
      <em>proxy</em> свойствата хвърля грешка след извикването на
      <em>revoke()</em>.
      <em>Revocable proxies</em> са важни за приложения за сигурност, където програмисти от трета страна могат да наложат достъп
      до определени обекти за определен период от време.</p>
    <p>Използването на
      <em>proxy</em> директно е най-мощният случай на използване, но можете да използвате
      <em>proxy</em> и като прототип на друг обект. В този случай вие сте силно ограничени в броя на
      <em>proxy traps</em>, които можете да използвате ефективно. Само
      <em>get, set</em> и
      <em> has proxy traps</em> могат винаги да се извикват на
      <em>proxy</em>, когато се използва като прототип, правейки случаите на употреба много по-малки.</p>
  </article>
  <nav>
    <a href="11_promises.html" title="previous chapter">◀</a>
    <a href="./index.html" title="cover">◆</a>
    <a href="./13_modules.html" title="next chapter">▶</a>
  </nav>
</body>

</html>