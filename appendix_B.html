<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Приложение B :: Understanding ECMAScript 6</title>
<link rel="stylesheet" href="font.css">
</head>
<body>
	<nav>
  <a href="./appendix_A.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
	</nav>
<header id="header" class="">
		<h1>Приложение B: Understanding ECMAScript 7 (2016)</h1>
		<p>Развитието на ECMAScript 6 отне около четири години, след което TC-39 реши, че такъв дълъг  процес на развитие е неустойчив. Вместо това, те ежегодно, циклично пускат нови издания, за да осигурят нови езикови функции, което ще направи развитието по-рано.</p>
        <p>По-чести издания означават, че всяка нова версия на ECMAScript трябва да има по-малко нови функции от ECMAScript 6. За да бележат тази промени, новите версии на спецификацията не се означават с номер, а вместо това се отнасят към годината, в която е публикувана спецификация. В резултат на това, ECMAScript 6 е известен също, като ECMAScript 2015 и ECMAScript 7 е официално признат, като ECMAScript 2016. Очаква се TC-39 да използва именуване на системата базирано на годината, за всички бъдещи издания на ECMAScript.</p>
        <p>ECMAScript 2016 приключи през март 2016 г. и съдържа само три допълнения към езика: нов математически оператор, нов метод за масиви и нова синтактична грешка. Всичките са включени в настоящото допълнение.</p>
	</header><!-- /header -->
    <article>
        <h3>The Exponentiation Operator</h3>
        <p>Единствената промяна в JavaScript синтаксисa, въведен в ECMAScript 2016 е <em>exponentiation operator</em> (оператор за степенуване), който е математическа операция, която прилага експонента върху база. JavaScript вече има <em>Math.pow()</em> метод за извършване на степенуване, но JavaScript също е един от малкото езици, които изискват метод, а не формалнен оператор. (И някои програмисти твърдят, че оператора е по-лесен за четене и разбиране.)</p>
        <p>Оператора за степенуване е с две звездички (**), където левият операнд е базата, а десния операнд е експонентата. Например:</p>
        <dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">let</span> result = 5 ** 2;

console.log(result);                        // 25
console.log(result === <span class="code">Math</span>.pow(5, 2));     // true
	 			</pre>
	 		</dd>
	 	</dl>
         <p>Този пример изчислява 5<sup>2</sup>, коeто е равно на 25. Можете да използвате <em>Math.pow()</em> за постигане на същия резултат.</p>
         <h4>Поръчкови операции</h4>
         <p>Оператора за степенуване има най-висок приоритет от всички бинарни оператори в JavaScript (унарните оператори имат по-висок приоритет от **). Това означава, че той се прилага първи за всяка сложна операция, както в този пример:</p>
         <dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">let</span> result = 2 * 5 ** 2;

console.log(result);                        // 50
	 			</pre>
	 		</dd>
	 	</dl>
         <p>Изчисляването на 5<sup>2</sup> се случва пръво. Получената стойност се умножава по 2 и крайния резултат е 50.</p>
         <h4>Operand Restriction</h4>
         <p>Оператора за степенуване има малко необичайно ограничение, което не присъства в другите оператори. Лявата страна на операцията за степенуване, не може да бъде унарен израз, освен ++ или --. Например това е невалиден синтаксис:</p>
         <dl>
	 		<dd>
	 			<pre class="highlight">
// syntax error
<span class="code">let</span> result = -5 ** 2;
	 			</pre>
	 		</dd>
	 	</dl>
         <p>В този пример -5 е синтактична грешка, защото редът на операциите е двусмислен. Не се разбира дали - се прилага само за 5 или за резултата на израза 5 ** 2. Забраната на унарните изрази от лявата страна на оператора за степенуване елиминира тази неяснота. За да се посочи ясно намерение, трябва да се включат скоби, около -5 или около 5 ** 2, както следва:</p>
         <dl>
	 		<dd>
	 			<pre class="highlight">
// ok
<span class="code">let</span> result1 = -(5 ** 2);    // equal to -25

// also ok
<span class="code">let</span> result2 = (-5) ** 2;    // equal to 25
	 			</pre>
	 		</dd>
	 	</dl>
         <p>Ако поставите скобите около израза, - се прилага към цялата работа. Когато скобите заобикалят -5, става ясно, че искате да повдигнете -5 на втората степен.</p>
         <p>Няма нужда от скоби, ако се използва ++ и -- от лявата страна на оператора за степенуване, защото двата оператора имат ясно дефинирано поведение на техните операнди. Префикс ++ или  -- променя операнда преди да се извършат всички други операции и версии на <em>postfix</em> прилагат някакви промени едва след оценка на целия израз. Случаи на използване на двата са безопасни от лявата страна на оператора, като този код показва:</p>
         <dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">let</span> num1 = 2,
    num2 = 2;

console.log(++num1 ** 2);       // 9
console.log(num1);              // 3

console.log(num2-- ** 2);       // 4
console.log(num2);              // 1
	 			</pre>
	 		</dd>
	 	</dl>
         <p>В този пример <em>num1</em> се увеличава преди оператора за степенуване да се приложи, така че <em>num1</em> става 3 и резултата от операцията е 9. За <em>num2</em> стойността остава 2 за операцията на степенуване и след това намалява стойността на 1.</p>
         <h3>Метода Array.prototype.includes()</h3>
         <p>Може би си спомняте, че ECMAScript 6 добави <em>String.prototype.includes()</em>, който проверява дали някои определени <em>substrings</em> съществуват в рамките на даден <em>string</em>. Първоначално ECMAScript 6 също щеше да  въведе <em>Array.prototype.includes()</em> метод, за да продължи тенденцията на третиране на <em>strings</em> и масиви по същия начин. Но спецификацията за <em>Array.prototype.includes()</em> не беше пълна в крайния срок за ECMAScript 6 и така <em>Array.prototype.includes()</em> се озова в ECMAScript 2016.</p>
         <h4>Как да използваме Array.prototype.includes()</h4>
         <p>Методът <em>Array.prototype.includes()</em> приема два аргумента: стойността за търсене и незадължителен индекс, от който да започне търсенето. Когато e подаден втория аргумент, <em>includes()</em> започва съвпадението от този индекс. (По подразбиране началния индекс е 0.) Върнатата стойност е <em>true</em>, ако стойността се намира вътре в масива и <em>false</em> ако не е. Например:</p>
         <dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">let</span> values = [1, 2, 3];

console.log(values.includes(1));        // true
console.log(values.includes(0));        // false

// start the search from index 2
console.log(values.includes(1, 2));     // false
	 			</pre>
	 		</dd>
	 	</dl>
         <p>Тука извикването на <em>values.includes()</em> връща <em>true</em> за стойност 1 и <em>false</em> за стойност 0, защото 0 не е в масива. Когато вторият аргумент се използва, за да започне търсенето от индекс 2 (който съдържа стойност 3), <em>values.includes()</em> метода връща <em>false</em>, защото числото 1 не е намерено между индекс 2 и края на масива.</p>
         <h4>Сравняване на стойност</h4>
         <p>Сравняването на стойност, извършвано от метода <em>includes(),</em> използва === оператора с едно изключение: NaN се счита за равно на NaN, въпреки че NaN === NaN дава резултат <em>false</em>. Това е различно от поведението на метода <em>indexOf()</em>, който строго използва === за сравнение. За да видите разликата, помислете върху този код:</p>
         <dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">let</span> values = [1, <span class="code">NaN</span>, 2];

console.log(values.indexOf(<span class="code">NaN</span>));       // -1
console.log(values.includes(<span class="code">NaN</span>));      // true
	 			</pre>
	 		</dd>
	 	</dl>
         <p>Метода <em>values.indexOf()</em>  връща -1 за NaN, въпреки че NaN се съдържа в масива. От друга страна <em>values.includes()</em> връща <em>true</em> за NaN, защото използва различна стойност за операторa за сравнение.</p>
         <dl>
	 		<dd><div class="worning">
					<img src="./img/worning.jpg" alt="worning">
       </div><strong>Когато искате да проверите за съществуването на само една стойност в масив, не е необходимо да се знае индекса, аз препоръчвам да използвате <em>includes()</em> поради разликата в това как се третира NaN от <em>includes()</em> и <em>indexOf()</em> методите. Ако трябва да знаете къде съществува дадена стойност в масива, тогава трябва да използвате метода <em>indexOf()</em>.</strong></dd>
	 	</dl>
		 <p>Друга особенност на това изпълнение е, че 0 и - 0 се считат за равни. В този случай поведението на <em>indexOf()</em> и <em>includes()</em> е същото:</p>
		 <dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">let</span> values = [1, +0, 2];

console.log(values.indexOf(-0));        // 1
console.log(values.includes(-0));       // true
	 			</pre>
	 		</dd>
	 	</dl>
		 <p>Тука, <em>indexOf()</em> и <em>includes()</em> намират 0, когато се подава - 0, защото двете стойности се считат за равни. Обърнете внимание, че това е различно от поведението на метода на <em>Object.is()</em>, който счита 0 и - 0 за различни стойности.</p>
		 <h3>Промяна на обхвата на функцията в Strict Mode</h3>
		 <p>Когато <em>strict mode</em> беше въведен в ECMAScript 5, езикът стана съвсем малко по-лесен, отколкото в ECMAScript 6. Въпреки това, във ECMAScript 6 все още е разрешено да укажете строг режим с помощта на "use strict" директивата или в глобалния обхват на действие (което ще направи целия код в <em>strict mode</em>) или в обхвата на функция (така само функцията ще работи в строг режим). Последното се оказа проблем в ECMAScript 6 поради по-сложния начин, по който параметрите може да се определят, по-конкретно, с преструктуриране и <em>default</em> стойности за параметър. За да разберем проблема, да разгледаме следния код:</p>
		 <dl>
	 		<dd>
	 			<pre class="highlight">
<span class="code">function</span> doSomething(first = <span class="code">this</span>) {
    "use strict";

    <span class="code">return</span> first;
}
	 			</pre>
	 		</dd>
	 	</dl>
		 <p>Тука, към името на параметъра <em>first</em> се присвоява стойност по подразбиране <em>this</em>. Каква стойност очаквате да бъде <em>first</em>? Спецификацията на ECMAScript 6 инструктира JavaScript машината в такива случаи да третира параметрите, като че работят в строг режим, така че <em>this</em> трябва да бъде равен на <em>undefined</em>. Въпреки това, изпълнението на параметри работещи в строг режим, когато "use strict" присъства вътре във функцията, се оказа доста трудно, защото стойностите за параметър по подразбиране могат да бъдат и функции. Тази трудност доведе до повечето JavaScript машини да не изпълняват такива функции (така <em>this</em> ще бъде равен на глобален обект).</p>
		 <p>В резултат от трудността на изпълнение ECMAScript 2016, направи незаконно да има "use strict" директива вътре във функция, чиито параметри са <em>destructured</em> или имат стойности по подразбиране. Разрешени са само прости списъци с параметри, тези които не съдържат <em>destructured</em> или стойности по подразбиране, когато "use strict" присъства в тялото на функция. Ето някои примери:</p>
		 <dl>
	 		<dd>
	 			<pre class="highlight">
// okay - using simple parameter list
<span class="code">function</span> okay(first, second) {
    "use strict";

    <span class="code">return</span> first;
}

// syntax error
<span class="code">function</span> notOkay1(first, second=first) {
    "use strict";

    <span class="code">return</span> first;
}

// syntax error
<span class="code">function</span> notOkay2({ first, second }) {
    "use strict";

    <span class="code">return</span> first;
}
	 			</pre>
	 		</dd>
	 	</dl>
		 <p>Можете да използвате "use strict" с прости списъци от параметри, поради което <em>okay()</em> работи, както бихте очаквали (също, както в ECMAScript 5). Функцията <em>notOkay1()</em> е синтактична грешка, защото вече не може да използвате "use strict" във функции с параметри, чийто стойности са по подразбиране. По същия начин <em>notOkay2()</em> функцията е синтактична грешка, защото не можете да използвате "use strict" във функция с <em>destructured</em> параметри.</p>
		 <p>Като цяло, тази промяна премахва една точка от объркване на JavaScript програмистите, както и проблемното изпълнение за JavaScript машините.</p>
    </article>
<nav>
  <a href="./appendix_A.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
</nav>
</body>
</html>
