<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>Приложение B :: Understanding ECMAScript 6</title>
	<link rel="stylesheet" href="font.css">
</head>

<body>
	<nav>
		<a href="./appendix_A.html" title="previous chapter">◀</a>
		<a href="./index.html" title="cover">◆</a>
	</nav>
	<header id="header" class="">
		<h1>Приложение B: Understanding ECMAScript 7 (2016)</h1>
		<p>Развитието на ECMAScript 6 отне около четири години, след което TC-39 реши, че такъв дълъг процес на развитие е неустойчив.
			Вместо това, те ежегодно, циклично пускат нови издания, за да осигурят нови езикови функции, което ще направи развитието
			по-рано.</p>
		<p>По-чести издания означават, че всяка нова версия на ECMAScript трябва да има по-малко нови функции, от колкото ECMAScript
			6. За да бележат тази промени, новите версии на спецификацията не се означават с номер, а вместо това се отнасят към годината,
			в която е публикувана спецификация. В резултат на това, ECMAScript 6 е известен също, като ECMAScript 2015 и ECMAScript
			7 е официално признат, като ECMAScript 2016. Очаква се TC-39 да използва това именуване на системата базирано на годината,
			за всички бъдещи издания на ECMAScript.</p>
		<p>ECMAScript 2016 приключи през март 2016 г. и съдържа само три допълнения към езика: нов математически оператор, нов метод
			за
			<em>arrays</em> и нова синтактична грешка. Всичките са включени в настоящото допълнение.</p>
	</header>
	<!-- /header -->
	<article>
		<h3>The Exponentiation Operator</h3>
		<p>Единствената промяна в JavaScript синтаксиса, въведен в ECMAScript 2016 е
			<em>exponentiation operator</em> (оператор за степенуване), който е математическа операция, която прилага експонента върху
			база. JavaScript вече има
			<em>Math.pow()</em> метод за извършване на степенуване, но JavaScript също е един от малкото езици, които изискват метод,
			а не формален оператор. (И някои програмисти твърдят, че оператора е по-лесен за четене и разбиране.)</p>
		<p>Оператора за степенуване е с две звездички (**), където левият оперант е базата, а десния оперант е експонентата. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> result = 5 ** 2;

console.log(result);                        // 25
console.log(result === <span class="code">Math</span>.pow(5, 2));     // true
	 			</pre>
			</dd>
		</dl>
		<p>Този пример изчислява 5
			<sup>2</sup>, което е равно на 25. Можете да използвате
			<em>Math.pow()</em> за постигане на същия резултат.</p>
		<h4>Поръчкови операции</h4>
		<p>Оператора за степенуване има най-висок приоритет от всички бинарни оператори в JavaScript (унарните оператори имат по-висок
			приоритет от **). Това означава, че той се прилага първи за всяка сложна операция, както в този пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> result = 2 * 5 ** 2;

console.log(result);                        // 50
	 			</pre>
			</dd>
		</dl>
		<p>Изчисляването на 5
			<sup>2</sup> се случва първо. Получената стойност се умножава по 2 и крайния резултат е 50.</p>
		<h4>Operand Restriction</h4>
		<p>Оператора за степенуване има малко необичайно ограничение, което не присъства в другите оператори. Лявата страна на операцията
			за степенуване, не може да бъде унарен израз, освен ++ или --. Например това е невалиден синтаксис:</p>
		<dl>
			<dd>
				<pre class="highlight">
// syntax error
<span class="code">let</span> result = -5 ** 2;
	 			</pre>
			</dd>
		</dl>
		<p>В този пример -5 е синтактична грешка, защото редът на операциите е двусмислен. Не се разбира дали - се прилага само за
			5 или за резултата на израза 5 ** 2. Забраната на унарни изрази от лявата страна на оператора за степенуване елиминира
			тази неяснота. За да се посочи ясно намерение, трябва да се включат скоби, около -5 или около 5 ** 2, както следва:</p>
		<dl>
			<dd>
				<pre class="highlight">
// ok
<span class="code">let</span> result1 = -(5 ** 2);    // equal to -25

// also ok
<span class="code">let</span> result2 = (-5) ** 2;    // equal to 25
	 			</pre>
			</dd>
		</dl>
		<p>Ако поставите скобите около израза, - се прилага към цялата работа. Когато скобите заобикалят -5, става ясно, че искате
			да повдигнете -5 на втората степен.</p>
		<p>Няма нужда от скоби, ако се използва ++ и -- от лявата страна на оператора за степенуване, защото двата оператора имат
			ясно дефинирано поведение на техните операнти. Префикс ++ или -- променя операнта преди да се извършат всички други операции
			и версии на
			<em>postfix</em> прилагат някакви промени едва след оценка на целия израз. Случаи на използване на двата са безопасни от лявата
			страна на оператора, като този код показва:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> num1 = 2,
    num2 = 2;

console.log(++num1 ** 2);       // 9
console.log(num1);              // 3

console.log(num2-- ** 2);       // 4
console.log(num2);              // 1
	 			</pre>
			</dd>
		</dl>
		<p>В този пример
			<em>num1</em> се увеличава преди оператора за степенуване да се приложи, така че
			<em>num1</em> става 3 и резултата от операцията е 9. За
			<em>num2</em> стойността остава 2 за операцията на степенуване и след това намалява стойността на 1.</p>
		<h3>Метода Array.prototype.includes()</h3>
		<p>Може би си спомняте, че ECMAScript 6 добави
			<em>String.prototype.includes()</em>, който проверява дали някои определени
			<em>substrings</em> съществуват в рамките на даден
			<em>string</em>. Първоначално ECMAScript 6 също искаше да въведе
			<em>Array.prototype.includes()</em> метод, за да продължи тенденцията на третиране на
			<em>strings</em> и
			<em>arrays</em> по същия начин. Но спецификацията за
			<em>Array.prototype.includes()</em> не беше пълна в крайния срок за ECMAScript 6 и така
			<em>Array.prototype.includes()</em> се озова в ECMAScript 2016.</p>
		<h4>Как да използваме Array.prototype.includes()</h4>
		<p>Методът
			<em>Array.prototype.includes()</em> приема два аргумента: стойността за търсене и незадължителен индекс, от който да започне
			търсенето. Когато e подаден втория аргумент,
			<em>includes()</em> започва съвпадението от този индекс. (По подразбиране началния индекс е 0.) Върнатата стойност е
			<em>true</em>, ако стойността се намира вътре в
			<em>array</em> и
			<em>false</em> ако не е. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> values = [1, 2, 3];

console.log(values.includes(1));        // true
console.log(values.includes(0));        // false

// start the search from index 2
console.log(values.includes(1, 2));     // false
	 			</pre>
			</dd>
		</dl>
		<p>Тука извикването на
			<em>values.includes()</em> връща
			<em>true</em> за стойност 1 и
			<em>false</em> за стойност 0, защото 0 не е в <em>array</em>. Когато вторият аргумент се използва, за да започне търсенето от индекс
			2 (който съдържа стойност 3),
			<em>values.includes()</em> метода връща
			<em>false</em>, защото числото 1 не е намерено между индекс 2 и края на <em>array</em>.</p>
		<h4>Сравняване на стойност</h4>
		<p>Сравняването на стойност, извършвано от метода
			<em>includes(),</em> използва === оператора с едно изключение: NaN се счита за равно на NaN, въпреки че NaN === NaN дава резултат
			<em>false</em>. Това е различно от поведението на метода
			<em>indexOf()</em>, който строго използва === за сравнение. За да видите разликата, помислете върху този код:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> values = [1, <span class="code">NaN</span>, 2];

console.log(values.indexOf(<span class="code">NaN</span>));       // -1
console.log(values.includes(<span class="code">NaN</span>));      // true
	 			</pre>
			</dd>
		</dl>
		<p>Метода
			<em>values.indexOf()</em> връща -1 за NaN, въпреки че NaN се съдържа в <em>array</em>. От друга страна
			<em>values.includes()</em> връща
			<em>true</em> за NaN, защото използва различна стойност за оператора за сравнение.</p>
		<dl>
			<dd>
				<div class="worning">
					<img src="./img/worning.jpg" alt="worning">
				</div>
				<strong>Когато искате да проверите за съществуването на само една стойност в <em>array</em>, не е необходимо да се знае индекса, аз препоръчвам
					да използвате
					<em>includes()</em> поради разликата в това как се третира NaN от
					<em>includes()</em> и
					<em>indexOf()</em> методите. Ако трябва да знаете къде съществува дадена стойност в <em>array</em>, тогава трябва да използвате
					метода
					<em>indexOf()</em>.</strong>
			</dd>
		</dl>
		<p>Друга особеност на това изпълнение е, че 0 и - 0 се считат за равни. В този случай поведението на
			<em>indexOf()</em> и
			<em>includes()</em> е едно и също:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> values = [1, +0, 2];

console.log(values.indexOf(-0));        // 1
console.log(values.includes(-0));       // true
	 			</pre>
			</dd>
		</dl>
		<p>Тука,
			<em>indexOf()</em> и
			<em>includes()</em> намират 0, когато се подава - 0, защото двете стойности се считат за равни. Обърнете внимание, че това
			е различно от поведението на метода на
			<em>Object.is()</em>, който счита 0 и - 0 за различни стойности.</p>
		<h3>Промяна на обхвата на функцията в Strict Mode</h3>
		<p>Когато
			<em>strict mode</em> беше въведен в ECMAScript 5, езикът стана съвсем малко по-лесен, отколкото в ECMAScript 6. Въпреки това,
			във ECMAScript 6 все още е разрешено да укажете стриктен режим с помощта на "use strict" директивата или в глобалния обхват
			на действие (което ще направи целия код в
			<em>strict mode</em>) или в обхвата на функция (така само функцията ще работи в
			<em>strict mode</em>). Последното се оказа проблем в ECMAScript 6 поради по-сложния начин, по който параметрите може да се
			определят, по-конкретно, с преструктуриране и
			<em>default</em> стойности за параметър. За да разберем проблема, да разгледаме следния код:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> doSomething(first = <span class="code">this</span>) {
    "use strict";

    <span class="code">return</span> first;
}
	 			</pre>
			</dd>
		</dl>
		<p>Тука, към името на параметъра
			<em>first</em> се присвоява стойност по подразбиране
			<em>this</em>. Каква стойност очаквате да бъде
			<em>first</em>? Спецификацията на ECMAScript 6 инструктира JavaScript машината в такива случаи да третира параметрите, като
			че работят в стриктен режим, така че
			<em>this</em> трябва да бъде равен на
			<em>undefined</em>. Въпреки това, изпълнението на параметри работещи в стриктен режим, когато "use strict" присъства вътре във
			функцията, се оказа доста трудно, защото стойностите за параметър по подразбиране могат да бъдат и функции. Тази трудност
			доведе до повечето JavaScript машини да не изпълняват такива функции (така
			<em>this</em> ще бъде равен на глобалния обект).</p>
		<p>В резултат от трудността на изпълнение ECMAScript 2016, направи незаконно да има "use strict" директива вътре във функция,
			чиито параметри са
			<em>destructured</em> или имат
			<em>default</em> стойности. Разрешени са само прости списъци с параметри, тези които не съдържат
			<em>destructured</em> или стойности по подразбиране, когато "use strict" присъства в тялото на функция. Ето някои примери:</p>
		<dl>
			<dd>
				<pre class="highlight">
// okay - using simple parameter list
<span class="code">function</span> okay(first, second) {
    "use strict";

    <span class="code">return</span> first;
}

// syntax error
<span class="code">function</span> notOkay1(first, second=first) {
    "use strict";

    <span class="code">return</span> first;
}

// syntax error
<span class="code">function</span> notOkay2({ first, second }) {
    "use strict";

    <span class="code">return</span> first;
}
	 			</pre>
			</dd>
		</dl>
		<p>Все още можете да използвате "use strict" с прости списъци от параметри, поради което
			<em>okay()</em> работи, както бихте очаквали (също, както в ECMAScript 5). Функцията
			<em>notOkay1()</em> е синтактична грешка, защото вече не може да използвате "use strict" във функции с
			<em>default</em> стойности на параметрите. По същия начин
			<em>notOkay2()</em> функцията е синтактична грешка, защото не можете да използвате "use strict" във функция с
			<em>destructured</em> параметри.</p>
		<p>Като цяло, тази промяна премахва една точка от объркване на JavaScript програмистите, както и проблемното изпълнение за
			JavaScript машините.</p>
	</article>
	<nav>
		<a href="./appendix_A.html" title="previous chapter">◀</a>
		<a href="./index.html" title="cover">◆</a>
	</nav>
</body>

</html>