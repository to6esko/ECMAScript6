<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Блок обвързвания :: Understanding ECMAScript 6</title>
    <link rel="stylesheet" href="font.css">
</head>

<body>
    <nav>
        <a href="./00_intro.html" title="previous chapter">◀</a>
        <a href="./index.html" title="cover">◆</a>
        <a href="./02_strings.html" title="next chapter">▶</a>
    </nav>
    <header>
        <h1>
            <div class="head-num">Глава 1</div>Как работят блок обвързванията</h1>
        <p>По традиция, начина по който декларациите на променливите работят е една трудна част от програмирането в JavaScript.
            В повечето С-базирани езици, променливите (или
            <em>bindings</em>) се създават на мястото, където се среща декларацията. В JavaScript, обаче, това не е така. Създаването
            на вашите променливи зависи всъщност от това, как сте ги декларирали и ECMAScript 6 предлага опции за по-лесен
            контрол на обхвата. Тази глава показва, защо класически
            <em>var</em> декларации могат да бъдат объркващи, въвежда блок-обвързвания в ECMAScript 6 и след това предлага някои
            добри практики за използването им.</p>
    </header>
    <article>
        <h3>Var декларации и Hoisting</h3>
        <p>Декларации на променливи използващи
            <em>var</em> се третират, ако са в горната част на функцията (или в глобалния обхват, ако са обявени извън функцията),
            независимо от това, къде се случва действителната декларация, като
            <em>hoisting</em>. За демонстрация на това, което
            <em>hoisting</em> прави, разгледайте следното определение на функция:</p>
        <dl>
            <dd>
                <pre class="highlight">
  <span class="code">function</span> getValue(condition) {
      <span class="code">if</span> (condition) {
          <span class="code">var</span> value = "blue";
          <span class="comment"><em>// друг код</em></span>
          <span class="code">return</span> value;
      } <span class="code">else</span> {
   <span class="comment"><em> // стойността съществува тук със стойност undefined  </em></span>                
          <span class="code">return null</span>;
      }
  <span class="comment"><em> // стойността съществува тук със стойност undefined  </em></span>                   
  }
        </pre>
            </dd>
        </dl>
        <p>Ако не сте запознати с JavaScript, тогава може би очаквате променливата стойност да бъде създадена само ако състоянието
            се оцени да е истина. В действителност стойността на променливата се създава независимо от това. Зад кулисите,
            двигателя на JavaScript променя
            <em>getValue</em> функцията да изглежда така:</p>
        <dl>
            <dd>
                <pre class="highlight">
<span class="code">function</span> getValue(condition) {
    <span class="code">var</span> value;
    <span class="code">if</span> (condition) {
        value = "blue";
        <span class="comment"><em>// друг код</em></span>
        <span class="code">return</span> value;
    } <span class="code">else</span> {
        <span class="code">return null</span>;
    }
}            
          </pre>
            </dd>
        </dl>
        <p>Обявяването на стойността е вдигнато (
            <em>hoisted</em>) на върха, докато инициализацията остава на същото място. Това означава, че променливата стойност
            все още е достъпна от вътрешността на
            <em>else</em> клаузата. Ако се разглежда от там, променливата ще има стойност
            <em>undefined</em>, защото тя не е инициализирана.</p>
        <p>Често е необходимо известно време на нови JavaScript програмисти да свикнат с
            <em>hoisting</em>, неразбирането на това уникално поведение може да доведе до причиняване на бъгове. Поради тази
            причина, ECMAScript 6 въвежда блок-ниво за определяне на възможностите на обхвата и да контролира малко по-мощно
            жизнения цикъл на една променлива.</p>
        <h3>Блокови декларации</h3>
        <p>Блок-ниво декларациите са тези, които декларират променливи, които са недостъпни извън дадения обхват на блока. Създаване
            на блок обхват:</p>
        <ol>
            <li>Вътре във функция</li>
            <li>Вътре във блок (посочен от { и } характери)</li>
        </ol>
        <p>Блок определяне на обхвата се отнася за работата на много С-базирани езици и въвеждането на блокови декларации в
            ECMAScript 6 има за цел да допринесе за същата гъвкавост (и еднаквост) на JavaScript.</p>
        <h3>Let декларации</h3>
        <p>Синтаксиса на
            <em>let</em> декларациите е същия, като синтаксиса на
            <em>var</em>. По принцип замяната на
            <em>var</em> с
            <em>let</em> при декларирането на променлива, ограничава обхвата на променливата само за текущия блок код (но има
            няколко други фини разлики, които ще обсъдим малко по-късно). Тъй като
            <em>let</em> декларациите не се издигат до върха на оградения блок, може би е добре винаги да поставяте декларациите
            в началото на блока, така че те да са на разположение за целия блок. </p>
        <p>Ето един пример:</p>
        <dl>
            <dd>
                <pre class="highlight">
<span class="code">function</span> getValue(condition) {
     <span class="code">if</span>(condition) {
      <span class="code">let</span> value = "blue";
     <span class="comment"><em>// друг код</em></span>
        <span class="code">return</span> value;
    } <span class="code">else</span> {
         <span class="comment"><em>// стойността не съществува тук</em></span>
         <span class="code">return null;</span>
    }
    <span class="comment"><em>// стойността не съществува тук</em></span>
}          
        </pre>
            </dd>
        </dl>
        <p> Тази версия на
            <em>getValue</em> функцията се държи много по-близо до това, което бихме очаквали в други С-базирани езици. Тъй като
            променливата стойност е обявена с използване на
            <em>let</em> вместо с
            <em>var</em>, декларацията не се издига до върха на дефиницията на функцията и променливата стойност е унищожена
            след изпълнение на
            <em>if</em> блока. Ако
            <em>if</em> състоянието се оцени на
            <em>false</em>, тогава стойността никога не се обявява или инициализира.</p>
        <h3>Не на повторното деклариране</h3>
        <p>Ако индентификатор вече е бил дефиниран в някакъв обхват и след това използваме идентификатора в
            <em>let</em> декларация вътре в този обхват, това причинява грешка и ще бъде изхвърлен. Например:</p>
        <dl>
            <dd>
                <pre class="highlight">
<span class="code">var</span> count = 30;
<span class="comment"><em>// синтактична грешка</em></span>
<span class="code">let</span> count = 40;
       </pre>
            </dd>
        </dl>
        <p>В този пример
            <em>count</em> е обявен два пъти: един път с
            <em>var</em> и един път с
            <em>let</em>. И понеже
            <em>let</em> предефинира идентификатор, който вече съществува в същия обхват,
            <em>let</em> декларацията ще хвърли грешка. От друга страна няма да се хвърли грешка, ако
            <em>let</em> декларацията създава нова променлива със същото име, като променлива в своя съдържащ обхват, както е
            показано в следния код:</p>
        <dl>
            <dd>
                <pre class="highlight">
<span class="code">var</span> count = 30;
<span class="comment"><em>// не хвърля грешка</em></span>
if (condition) {
<span class="code">let</span> count = 40;
<span class="comment"><em>// още код</em></span>
}	
       </pre>
            </dd>
        </dl>
        <p>Тази
            <em>let</em> декларация не хвърля грешка, тъй като създава нова променлива, наречена
            <em>count</em> в рамките на
            <em>if</em> твърдението, вместо да създаде
            <em>count</em> в заобикалящия го блок. Вътре в този
            <em>if</em> блок тази нова променлива е сянка на глобалната променлива
            <em>count</em> и прекратява достъпа до нея, когато изпълнението напусне блока.</p>
        <h3>Constant декларации</h3>
        <p>Можете също така да дефинирате променливи в ECMAScript 6 със
            <em>const</em> синтаксис на декларацията. Променливи декларации използвайки
            <em>const</em> се считат за
            <em>constants</em> (константи), което означава, че веднъж определени техните стойности не могат да бъдат променяни.
            Поради тази причина, всяка
            <em>const</em> променлива трябва да се инициализира с декларация, както е показано в този пример:</p>
        <dl>
            <dd>
                <pre class="highlight">
 <span class="comment"><em>// Валидна константа</em></span>
 <span class="code">const</span> maxItems = 30;
 <span class="comment"><em>// Синтактична грешка: липсва инициализация</em></span>
 <span class="code">const</span> name;      	
       </pre>
            </dd>
        </dl>
        <p>Променливата
            <em>maxItems</em> се инициализира, така че
            <em>const</em> декларацията трябва да работи без проблем. Променливата
            <em>name</em>, обаче предизвиква синтактична грешка, ако се опитате да стартирате програма съдържаща такъв код, защото
            <em>name</em> не е инициализирана.</p>
        <h4>Constants срещу let декларации</h4>
        <p>
            <em>Constants</em> също, като
            <em>let</em> са блокови декларации. Това означава, че
            <em>constants</em> се унищожават след изпълнение и излизане от блока, в който са декларирани и декларациите не са
            <em>hoisted</em>, както е показано в този пример:</p>
        <dl>
            <dd>
                <pre class="highlight">
<span class="code">if</span> (condition) {
    <span class="code">const</span> maxItems = 5;
    <span class="comment"><em>// още код</em></span>
}
<span class="comment"><em>// maxItems не е достъпна тук</em></span>
       </pre>
            </dd>
        </dl>
        <p>В този код, константата
            <em>maxItems</em> е обявена в рамките на
            <em>if</em> изявление. След като изявлението приключи,
            <em>maxItems</em> се унищожава и не е достъпна извън този блок.</p>
        <p>В друго сходство с
            <em>let, const</em> декларацията хвърля грешка, когато се прави с идентификатор на вече дефинирана променлива в същия
            обхват. Също няма значение, ако променливата е обявена използвайки
            <em>var</em> (за глобален или на функцията обхват) или
            <em>let</em> (за блок обхват). Например, да разгледаме този код:</p>
        <dl>
            <dd>
                <pre class="highlight">
<span class="code">var</span> message = "Hello!";
<span class="code">let</span> age = 25;
<span class="comment"><em>// Всеки от тях ще хвърли грешка</em></span>
<span class="code">const</span> message = "Goodbye!";
<span class="code">const</span> age = 30;
       </pre>
            </dd>
        </dl>
        <p>Само двете
            <em>const</em> декларации ще бъдат валидни, но като се има в предвид предишните
            <em>var</em> и
            <em>let</em> декларации, в този случай няма да работят по предназначение.</p>
        <p>Въпреки тези прилики, има една голяма разлика между
            <em>let</em> и
            <em>const</em>, която трябва да се помни. Всеки опит за присвояване на постоянна предварително дефинирана константа
            ще хвърли грешка и в двата - строг и не строг режим:</p>
        <dl>
            <dd>
                <pre class="highlight">
<span class="code">const</span> maxItems = 5;
maxItems = 6;      
<span class="comment"><em>//хвърля грешка</em></span>
       </pre>
            </dd>
        </dl>
        <p>По подобие на константите на други езици, на променливата
            <em>maxItems</em> не може да и бъде назначена нова стойност по-късно. Въпреки това, за разлика от константите на
            други езици, стойността притежавана от константа може да бъде модифицирана, ако е обект.</p>
        <h4>Деклариране на обеки с константи</h4>
        <p>
            <em>Const</em> декларацията предотвратява промяна на обвързването, а не на самата стойност. Това означава, че
            <em>const</em> декларациите на обекти не пречат на модификацията на тези обекти. Например:</p>
        <dl>
            <dd>
                <pre class="highlight"> 
<span class="code">const</span> person = {  
    name: "Nicholas"
};
<span class="comment"><em>//работи</em></span>
person.name = "Greg";
<span class="comment"><em>//хвърля грешка</em></span>
person = {
    name: "Greg"
};	
       </pre>
            </dd>
        </dl>
        <p>Тука обвързването на
            <em>person</em> е създадено с първоначална стойност на обект с едно свойство. Промяната с
            <em>person.name</em> е възможна, без да причинява грешка, защото се променя това, което
            <em>person</em> съдържа, а не променя самата стойност на
            <em>person</em>. Ако този код се опита да припише стойност на
            <em>person</em> (като по този начин се опита да промени постоянната величина) ще бъде хвърлена грешка. Тази тънкост,
            как константите работят с обекти е лесно да се разбере. Само запомнете:
            <em>const</em> предотвратява модификацията на обвързването, а не на модифицирането на обвързаната стойност.</p>
        <h3>
            <a name="TDZ"></a>Мъртва зона във времето</h3>
        <p>За разлика от
            <em>var</em> синтаксиса,
            <em>let</em> и
            <em>const</em> имат
            <em>no hoisting</em> характеристики. Променливи дефинирани с тях могат да бъдат достъпни едва след декларацията.
            Опитите да се използват, ще доведат до референтна грешка, дори ако се използват за обикновено безопасни операции,
            като
            <em>typeof</em> в това
            <em>if</em> изявление:</p>
        <dl>
            <dd>
                <pre class="highlight">
<span class="code">if</span> (condition) { 
    console.log(<span class="code">typeof</span> value);   <span class="comment"><em>// ReferenceError!</em></span>
    <span class="code">let</span> value = "blue";
}
       </pre>
            </dd>
        </dl>
        <p>Тука променливата стойност е дефинирана и инициализирана с
            <em>let</em>, но това твърдение никога не се изпълнява, тъй като предишния ред хвърля грешка. Проблема е, че стойността
            съществува в това, което JavaScript обществото нарича темпорална мъртва зона -
            <em>temporal dead zone</em>(TDZ). TDZ не е определена изрично в спецификациите на ECMAScript, но терминът често се
            използва, за да се опише поведението на
            <em>non-hoisting</em> на
            <em>let</em> и
            <em>const</em>. В този раздел има някои тънкости за разположение на декларациите в случаи на TDZ и въпреки, че показаните
            примери използват
            <em>let</em>, имайте в предвид, че същото се отнася и за
            <em>const</em>.</p>
        <p>Когато една JavaScript машина минава през настоящ блок и намира променлива декларация, той или я изкачва (за
            <em>var</em>) или я поставя в TDZ (за
            <em>let</em> и
            <em>const</em>). Всеки опит за достъп до променливата в резултат на TDZ е грешка по време на работа. Тази променлива
            се отстранява само от TDZ и следователно е безопасно да се използва след изпълнението, следвайки променливата
            декларация.</p>
        <p>Това е вярно, за всеки път, когато се опитате да използвате променлива декларация с
            <em>let</em>, преди да е била дефинирана. Както предишния пример демонстрира, това важи дори за нормално безопасни
            оператори, като
            <em>typeof</em>. Можете обаче да използвате
            <em>typeof</em> върху променлива извън блока, където тази променлива е обявена, макар че той може да не даде очакваните
            резултати. Помислете върху този код:</p>
        <dl>
            <dd>
                <pre class="highlight">
console.log(<span class="code">typeof</span> value); <span class="comment"><em>// "undefined"</em></span>

<span class="code">if</span> (condition) {  
    <span class="code">let</span> value = "blue";
}
       	</pre>
            </dd>
        </dl>
        <p>Променливата стойност не е в TDZ когато
            <em>typeof</em> операцията се изпълнява, защото това се случва извън блока, в който
            <em>value</em> е обявена. Това означава, че няма свързана стойност и
            <em>typeof</em> просто връща "
            <em>undefined</em>".</p>
        <p>TDZ е просто един уникален аспект на блок-обвързванията. Друг уникален аспект е свързан с употребата им във вътрешността
            на циклите.</p>
        <h3>Блок обвързаност в цикли</h3>
        <p>Може би една област, в която повечето програмисти искат да блокират блок обхвата на променливите е в рамките на циклите,
            където брояча на променливата е предназначен да се използва само в рамките на цикъла. Например, не е необичайно
            да се види такъв JavaScript код:</p>
        <dl>
            <dd>
                <pre class="highlight">
 <span class="code">for</span> (<span class="code">var</span> i=0; i < 10; i++) { 
    process(items[i]);
}
<span class="comment"><em>// i е все още достъпна тук</em></span>
console.log(i);           <span class="comment"><em>// 10</em></span>
       	</pre>
            </dd>
        </dl>
        <p>В други езици, където блок-нивото за определяне на обхвата е по подразбиране, този пример ще работи по предназначение
            и само
            <em>for</em> цикълът ще има достъп до
            <em>i</em> променливата. В JavaScript обаче, променливата
            <em>i</em> все още е достъпна след завършения цикъл, тъй като
            <em>var</em> декларацията я издига. Използвайки
            <em>let</em> в следния код ще даде очакваното поведение:</p>
        <dl>
            <dd>
                <pre class="highlight">
 <span class="code">for</span> (<span class="code">let</span> i=0; i < 10; i++) {   
    process(items[i]);
}
<span class="comment"><em>// i не е достъпна тук - хвърля грешка</em></span>
console.log(i);   		
       	</pre>
            </dd>
        </dl>
        <p>В този пример, променливата съществува само в рамките на
            <em>for</em> цикъла. След като цикълът е завършен, променливата се унищожава и вече не е достъпна другаде.</p>
        <h4>Функции в Loops</h4>
        <p>Характеристиките на
            <em>var</em> отдавна имат проблеми със създаване на функции вътре в цикъла, защото променливите на цикъла са достъпни
            извън обхвата на цикъла. Да разгледаме следния код:</p>
        <dl>
            <dd>
                <pre class="highlight">
<span class="code">var</span> funcs = [];
<span class="code">for</span> (<span class="code">var</span> i=0; i < 10; i++) {  
    funcs.push(<span class="code">function</span>() { 
    console.log(i); 
    });
}
funcs.forEach(<span class="code">function</span>(func) {
    func();     <span class="comment"><em>// извежда числото "10" десет пъти</em></span>
});
       	</pre>
            </dd>
        </dl>
        <p>Може би очаквате този код да отпечата цифрите от 0 до 9, но той извежда числото 10, десет пъти подред. Това е, защото
            <em>i</em> се споделя между всяка итерация на цикъла, което означава, че всички функции създадени вътре в цикъла
            имат препратка към една и съща променлива. Променливата
            <em>i</em> има стойност 10 при завършването на цикъла и
            <em>console.log(i)</em> извиква тази стойност за разпечатване всеки път.</p>
        <p>За да решат този проблем, програмистите използват
            <em>immediately-invoked function expressions</em> (IIFEs)(незабавно-изпълняващ се функционален израз) вътре в цикъла
            за итерациите, които да бъдат създадени за новото копие на променливата, както в този пример:</p>
        <dl>
            <dd>
                <pre class="highlight">
<span class="code">var</span> funcs = [];
<span class="code">for</span> (<span class="code">var</span> i=0; i < 10; i++) {
    funcs.push((<span class="code">function</span>(value) { 
        <span class="code">return function</span>() {  
            console.log(value);
        }
    }(i)));
}
funcs.forEach(<span class="code">function</span>(func) {
    func();     <span class="comment"><em>// изход 0, 1, 2, до 9</em></span>
});	
       	</pre>
            </dd>
        </dl>
        <p>Тази версия използва IIFE вътре в цикъла. Променливата
            <em>i</em> се подава на IIFE, което създава свое собствено копие и го съхранява, като стойност. Тази стойност се
            използва от функцията за итерацията и така извикана всяка функция връща очакваната стойност, като цикъла брои
            от 0 до 9. За щастие, блоковото обвързване с
            <em>let</em> и
            <em>const</em> в ECMAScript 6 може да опрости този цикъл.</p>
        <h4>
            <a name="Let декларации в Loops"></a>Let декларации в Loops</h4>
        <p>Декларацията
            <em>let</em> опростява цикъла, като ефективно имитира това, което IIFE прави в предишния пример. На всяка итерация,
            цикълът създава нова променлива и инициализира стойността на променливата със същото име от предната итерация.
            Това означава, че може да се пропусне напълно IIFE и да получим резултата, които очакваме:</p>
        <dl>
            <dd>
                <pre class="highlight">
<span class="code">var</span> funcs = [];
<span class="code">for</span> (<span class="code">let</span> i=0; i < 10; i++) { 
    funcs.push(<span class="code">function</span>() {   
        console.log(i);
    });
}
funcs.forEach(<span class="code">function</span>(func) {
    func();     <span class="comment"><em>// изход 0, 1, 2, до 9</em></span>
})	
       	</pre>
            </dd>
        </dl>
        <p>Този цикъл работи точно, както цикъла, който използва IIFE, но е може би малко по-чист. Декларацията
            <em>let</em> създава нова променлива
            <em>i</em> всеки път през цикъла, така че всяка функция създадена вътре в цикъла получава свое собствено копие на
            <em>i</em>. Всяко копие на
            <em>i</em> има стойност определена в началото на итерацията на цикъла, в която е била създадена. Същото важи и за
            <em>for-in</em> и
            <em>for-of</em> цикли, както е показано тук:</p>
        <dl>
            <dd>
                <pre class="highlight">
<span class="code">var</span> funcs = [],    
    object = {   
        a: <span class="code">true</span>, 
        b: <span class="code">true</span>, 
        c: <span class="code">true</span>
    };
<span class="code">for</span> (<span class="code">let</span> key <span class="code">in</span> object) { 
    funcs.push(<span class="code">function</span>() {
        console.log(key);
    });
}
funcs.forEach(<span class="code">function</span>(func) {
    func();     <span class="comment"><em>// изход "a", "b", "c"</em></span>
});
       	</pre>
            </dd>
        </dl>
        <p>В този пример,
            <em>for-in</em> цикъла показва същото поведение, както
            <em>for</em> цикъл. Всеки път през цикъла се създава ново
            <em>key</em> обвързване и така всяка функция има свое собствено копие на
            <em>key</em> променливата. Резултата е, че всяка функция извежда различна стойност. Ако беше използван
            <em>var</em> за деклариране на
            <em>key</em>, всички функции щяха да изкарат на изхода "c".</p>
        <dl>
            <dd>
                <div class="info">
                    <img src="./img/info.jpg" alt="info">
                </div>
                <strong>Важно е да се разбере, че поведението на
                    <em>let</em> декларациите в циклите е специално дефинирано поведение в спецификацията и не е непременно свързано
                    с
                    <em>non-hoisting</em> характеристиката на
                    <em>let</em>. Всъщност, първите реализации на
                    <em>let</em> не са имали този проблем, тъй като е добавен по-късно в процеса.</strong>
            </dd>
        </dl>
        <h4>Constant декларации в Loops</h4>
        <p>Спецификацията на ECMAScript 6 не забранява изрично
            <em>const</em> декларации в цикли. Въпреки това, съществуват различни поведения в зависимост от вида на цикъла, който
            използвате. За нормален
            <em>for</em> цикъл, може да използвате инициализация на
            <em>const</em>, но цикъла ще хвърли грешка, ако се опитате да промените стойността. На пример:</p>
        <dl>
            <dd>
                <pre class="highlight">
 <span class="code">var</span> funcs = [];
<span class="comment"><em>// хвърля грешка след една итерация</em></span>
<span class="code">for</span> (<span class="code">const</span> i=0; i < 10; i++) { 
    funcs.push(<span class="code">function</span>() {   
        console.log(i);
    });
}		
       	</pre>
            </dd>
        </dl>
        <p>В този код променливата
            <em>i</em> е декларирана, като константа. Първата итерация на цикъла, когато
            <em>i</em> е 0, се изпълнява успешно. Грешка се хвърля, когато
            <em>i++</em> се изпълни, защото това е опит да се промени константата. Като такава, може да използвате
            <em>const</em> за деклариране на променлива в инициализиране на цикъл, само ако не модифицирате тази променлива.</p>
        <p>От друга страна, когато се използва в
            <em>for-in</em> или в
            <em>for-of</em> цикъл,
            <em>const</em> променливата се държи също, като
            <em>let</em> променливата. Така че, кода по-долу не трябва да доведе до грешка:</p>
        <dl>
            <dd>
                <pre class="highlight">
<span class="code">var</span> funcs = [],
    object = {
        a: <span class="code">true</span>,
        b: <span class="code">true</span>,
        c: <span class="code">true</span>
    };
<span class="comment"><em>// не причинява грешка</em></span>
<span class="code">for</span>(<span class="code">const</span> key <span class="code">in</span> object) {
    funcs.push(<span class="code">function</span>() {
        console.log(key);
    });
}
funcs.forEach(<span class="code">function</span>(func) {
    func();     <span class="comment"><em>// изход "a", "b", "c"</em></span>
});		
       	</pre>
            </dd>
        </dl>
        <p>Този код функционира почти по същия начин, както във втория пример в раздела “Let декларации в Loops ”. Единствената
            разлика е, че стойността на
            <em>key</em> не може да бъде променена в рамките на цикъла. Циклите
            <em>for-in</em> и
            <em>for-of</em> работят с
            <em>const</em>, защото инициализацията на цикъла създава ново обвързване за всяка итерация през цикъла, а не се опитва
            да променя съществуващата стойност (както в случая с предишния пример, използвайки
            <em>for</em> вместо
            <em>for-in</em>).</p>
        <h3>Глобални блок обвързвания</h3>
        <p>Друг начин, по който
            <em>let</em> и
            <em>const</em> са различни от
            <em>var</em> е тяхното поведение в глобалния обхват. Когато
            <em>var</em> се използва в глобалния обхват, тя създава нова глобална променлива, която е собственост на глобалния
            обект (
            <em>window</em> в браузърите). Това означава, че може случайно да се презапише съществуващо глобално използване на
            <em>var</em>, както:</p>
        <dl>
            <dd>
                <pre class="highlight">
<span class="comment"><em>// в браузъра</em></span>
<span class="code">var</span> RegExp = "Hello!";
console.log(<span class="code">window.RegExp</span>);     
<span class="comment"><em> // "Hello!"</em></span>
<span class="code">var</span> ncz = "Hi!";
console.log(<span class="code">window</span>.ncz);        
<span class="comment"><em>// "Hi!"</em></span>   		
       	</pre>
            </dd>
        </dl>
        <p>Въпреки, че
            <em>RegExp</em> глобално се определя в
            <em>window</em>, не е безопасно да бъде заменен от
            <em>var</em> декларация. Този пример декларира нова глобална променлива
            <em>RegExp</em>, като презаписва оригинала. По същия начин, ncz се дефинира, като глобална променлива и веднага се
            определя, като свойство на
            <em>window</em>. Това е начина, по който JavaScript винаги е работил.</p>
        <p>Ако вместо това използвате
            <em>let</em> или
            <em>const</em> в глобалния обхват, новото обвързване е създадено в глобалния обхват, но свойството не е добавено
            в глобалния обект. Това също означава, че не може да се замени една глобална променлива използвайки
            <em>let</em> или
            <em>const</em>, може само да и се направи сянка. Ето един пример:</p>
        <dl>
            <dd>
                <pre class="highlight">
<span class="comment"><em>// в браузъра</em></span>
<span class="code">let</span> RegExp = "Hello!";
console.log(<span class="code">RegExp</span>);                    <span 
class="comment"><em>// "Hello"</em></span>
console.log(<span class="code">window.RegExp === RegExp</span>);  <span class="comment"><em>// false</em></span>
<span class="code">const</span> ncz = "Hi!";
console.log(ncz);                       <span class="comment"><em>// "Hi!"</em></span>
console.log("ncz" <span class="code">in</span> <span class="code">window</span>);           <span class="comment"><em>// fales</em></span>
       	</pre>
            </dd>
        </dl>
        <p>Тука, новата
            <em>let</em> декларация за
            <em>RegExp</em> създава обвързване със сянката на глобалния
            <em>RegExp</em>. Това означава, че
            <em>window.RegExp</em> и
            <em>RegExp</em> не са едни и същи, така че няма прекъсване на глобалния обхват. Също така,
            <em>const</em> декларацията за ncz създава обвързване но не създава свойство на глобалния обект. Тази възможност
            прави използването на
            <em>let</em> и
            <em>const</em> много по-безопасно в глобалния обхват, когато не искате да създадете свойства на глобалния обект.</p>
        <dl>
            <dd>
                <div class="info">
                    <img src="./img/info.jpg" alt="info">
                </div>
                <strong>Вие все още може да използвате
                    <em>var</em> в глобалния обхват, ако имате код, който трябва да е на разположение на глобалния обект. Това
                    е често срещано в браузъра, където искате да получите достъп до кода в цялата рамка или
                    <em>windows</em>.</strong>
            </dd>
        </dl>
        <h3>Най-добри практики за групово обвързване</h3>
        <p>Докато ECMAScript 6 е в процес на развитие, там е широко разпространено убеждението, че трябва да се използва
            <em>let</em> по подразбиране вместо
            <em>var</em> за деклариране на променливи. За много JavaScript програмисти,
            <em>let</em> се държи точно така, както са очаквали спрямо
            <em>var</em> и така пряката им подмяна има логически смисъл. В този случай, трябва да използвате
            <em>const</em> за променливите, за които е необходима защита от модификация.</p>
        <p>Обаче, тъй като все повече програмисти мигрират към ECMAScript 6, един алтернативен подход придоби популярност: използването
            на
            <em>const</em> по подразбиране е само, когато
            <em>let</em> знае за стойността, която трябва да се промени. Обосновката е, че повечето променливи не трябва да променят
            своята стойност след инициализацията, защото промените с неочаквани стойности са източник на грешки. Тази идея
            има значително количество привърженици и е обект на проучване за приемане в ECMAScript 6.</p>
    </article>
    <footer>
        <h3>Обобщение</h3>
        <p>Блок обвързването с
            <em>let</em> и
            <em>const</em> въвежда лексикално определяне на обхвата в JavaScript. Тези декларации не са
            <em>hoisted</em> и съществуват само в рамките на блока, където са декларирани. Това предполага поведение, което е
            по-скоро, както при другите езици и е по-малко вероятно да причини неволни грешки, понеже променливите сега могат
            да бъдат обявени точно там, където са необходими. Като страничен ефект, не може да получите достъп до променливите
            преди те да са обявени, дори за безопасни оператори, като
            <em>typeof</em>. Опита за достъп до блок обвързаности преди резултата от тяхната декларация води до грешка, която
            се дължи на наличието на обвързаност в тяхната темпорална мъртва зона (TDZ).</p>
        <p>В много случаи,
            <em>let</em> и
            <em>const</em> се държат по начин подобен на
            <em>var</em>, обаче това не е вярно за цикли. И за двете,
            <em>let</em> и
            <em>const</em>:
            <em>for-in</em> и
            <em>for-of</em> циклите създават нова обвързаност с всяка итерация на цикъла. Това означава, че функции създадени
            вътре в тялото на цикъла могат да получат достъп до стойностите на цикъл-обвързаностите, тъй като те са по време
            на текущата итерация, а не след последната итерация на цикъла, както би било с поведението на
            <em>var</em>. Същото се отнася за
            <em>let</em> декларации във
            <em>for</em> цикъл, докато използването на
            <em>const</em> декларации във
            <em>for</em> цикъл може да доведе до грешка.</p>
        <p>Сегашната най-добра практика за блок обвързване е да се използва
            <em>const</em> по подразбиране и използване на
            <em>let</em>, само когато знаем, че стойноста на променливата трябва да се промени. Това осигурява основно ниво на
            неизменчивост на кода, което може да помогне за предотвратяване на някои видове грешки.</p>
    </footer>
    <nav>
        <a href="./00_intro.html" title="previous chapter">◀</a>
        <a href="./index.html" title="cover">◆</a>
        <a href="./02_strings.html" title="next chapter">▶</a>
    </nav>

</body>

</html>