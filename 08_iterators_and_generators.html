<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Iterators и Generators :: Understanding ECMAScript 6</title>
	<link rel="stylesheet" href="font.css">
</head>
<body>
	<nav>
	<a href="./07_set_and_map.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="09_classes.html" title="next chapter">▶</a>
</nav>
	<header id="header" class="">
		<h1><div class="head-num">Глава 8</div>Iterators и Generators</h1>
		<p>Много програмни езици са се преориентирали от итерации върху данни с <em>for</em> цикли, които изискват инициализиране на променливи за проследяване на позицията в колекция, да използват итератор обекти, които програмно се връщат на следващия елемент в колекцията. Итераторите правят работата с колекции от данни по-лесна и ECMAScript 6 добавя итератори в JavaScript. При съчетаване с нови методи и видове колекции(като <em>set</em> и <em>map</em>), итераторите са ключови за ефективната обработка на данни и ще ги намерите в много части от езика. Има нов <em>for-of</em> цикъл, който работи с итератори, оператора <em>spread</em> (...), който използва итератори и дори итераторите правят асинхронното програмиране по-лесно.</p>
		<p>Тази глава обхваща много приложения на итератори, но на първо място е важно да разберем, защо итератори бяха добавени в JavaScript.</p>
	</header><!-- /header -->
	<article>
		<h3>Цикъл проблем</h3>
		<p>Ако някога сте писали JavaScript има шанс да сте писали код, който изглежда така:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">var</span> colors = ["red", "green", "blue"];

<span class="code">for</span> (<span class="code">var</span> i = 0, len < colors.length; i < len; i++) {
    console.log(colors[i]);
}
			</pre></dd>
		</dl>
		<p>Това е стандартен <em>for</em> цикъл, който създава променливата <em>i</em> за да следи индекса в <em>colors</em> масива. Стойността на <em>i</em> се увеличава всеки път в цикъла, ако тя не е по-голяма от дължината на масива (съхраняван в <em>len</em>).</p>
		<p> Това е един сравнително прост пример, сложността нараства, когато се правят вложени цикли и трябва да се следят няколко променливи. Тази допълнителна сложност може да доведе до грешки, а шаблонния характер на кода се поддава на повече грешки, тъй като подобен код се пише на няколко места. Това е проблема, който итераторите са предназначени да решат.</p>
		<h3>Какво са итераторите?</h3>
		<p>Итераторите са просто обекти със специфичен интерфейс, предназначен за повторение. Този интерфейс се състои от метод наречен <em>next()</em>, чийто резултат връща обект. Обекта резултат има две свойства, <em>value</em>, която е следващата стойност и <em>done</em>, който е булева стойност, която е <em>true</em>, когато няма повече стойности за връщане. Итератора поддържа вътрешен указател за местоположение в набора от стойности и с всяко извикване на <em>next()</em>, се връща на следващата подходяща стойност.</p>
		<p>Ако извикаме <em>next()</em>, след последната стойност, която е била върната, метода връща <em>done</em>, като <em>true</em> и <em>value</em> съдържаща върнатата стойност за итератора. Тази върната стойност, не се счита за част от набора с данни, а по-скоро, като последната част от свързани данни или <em>undefined</em>,  ако не съществуват такива данни. Върнатата стойност от итератора е подобна на върнатата стойност от функция в това, че е финален начин да предаде информация към извикващия.</p>
		<p>С това разбиране е сравнително лесно да се създаде итератор, използвайки ECMAScript 5, например:</p>
		<dl>
			<dd><pre class="highlight-overflow">
<span class="code">function</span> createIterator(items) {

    <span class="code">var</span> i = 0;

    <span class="code">return</span> {
        next: <span class="code">function</span>() {

            <span class="code">var</span> done = (i >= items.length);
            <span class="code">var</span> value = !done ? items[i++] : <span class="code">undefined</span>;

            <span class="code">return</span> {
                done: done,
                value: value
            };

        }
    };
}

<span class="code">var</span> iterator = createIterator([1, 2, 3]);

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: 2, done: false }"
console.log(iterator.next());           // "{ value: 3, done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"

<span class="comment"><em>// за всички по-нататъшни извиквания</em></span>
console.log(iterator.next());           // "{ value: undefined, done: true }"
			</pre></dd>
		</dl>
		<p>Функцията <em>createIterator()</em> връща обект с <em>next()</em> метод. Всеки път, когато метода се извика, се премества на следващата стойност в <em>items</em> масива се връща, като <em>value</em>. Когато <em>i</em> е 3, <em>items[i++]</em> връща <em>undefined</em> и <em>done</em> е <em>true</em>, което отговаря на последния специален случай за итератори в ECMAScript 6, където <em>next()</em> се извиква върху итератора, след като последното парче от данни е било използвано.</p>
		<p>Както показва този пример, писането на итератори, които се държат в съответствие с правилата, посочени в ECMAScript 6 е малко сложно.</p>
		<p>За щастие, ECMAScript 6 предвижда също генератори, които правят създаването итератор обекти много по-просто.</p>
		<h3>Какво е генератори</h3>
		<p>Генератора е функция, която връща итератор. Генератор функциите са обозначени чрез вмъкване на характер звезда (*) след ключовата дума <em>function</em> и използват новата ключова дума <em>yield</em>. Няма значение дали звездата е в непосредствена близост до <em>function</em> или има някакво празно пространство между тях, както в този пример:</p>
		<dl>
			<dd><pre class="highlight-overflow">
// generator
<span class="code">function</span> *createIterator() {
    <span class="code">yield</span> 1;
    <span class="code">yield</span> 2;
    <span class="code">yield</span> 3;
}
<span class="comment"><em>//генератора се извиква, като редовна функция, но се връща като итератор</em></span>
<span class="code">let</span> iterator = createIterator();

console.log(iterator.next().value);     // 1
console.log(iterator.next().value);     // 2
console.log(iterator.next().value);     // 3
			</pre></dd>
		</dl>
		<p>Звездата * преди <em>createIterator()</em> прави тази функция генератор. Ключовата дума <em>yield</em>, също нова за ECMAScript 6, определя стойностите в резултата, които итератор трябва да върне, когато <em>next()</em> е извикан в реда, в който трябва да се върнат. Итератора генериран в този пример има три различни стойности, които да върне с последователно извикване на <em>next()</em> метода: първо 1, след това 2 и нарая 3. Генератора получава извикване, като всяка друга функция, както е показано при създаването на <em>iterator</em>.</p>
		<p>Може би най-интересния аспект на генератор функцията е, че спира изпълнението след всяко <em>yield</em> изявление. Например, след като се изпълни <em>yield</em> 1 в този код, функцията не прави нищо друго, докато не се извика итератора на следващия <em>next()</em> метод. В този момент, се изпълнява <em>yield</em> 2. Тази способност да спира изпълнението по средата на една функция е изключително мощна и води до някои интересни приложения за генератор функции (обсъдени в раздела "Advanced Iterator Функционалност").</p>
		<p>Ключовата дума <em>yield</em> може да се използва с всяка стойност или израз, така че можем да напишем генератор функция, които добавят елементи на итератори, без изброяване на елементите един по един. Например, ето един начин, как бихте могли да използвате <em>yield</em> вътре в един <em>for</em> цикъл:</p>
		<dl>
			<dd><pre class="highlight-overflow">
<span class="code">function</span> *createIterator(items) {
    <span class="code">for</span> (<span class="code">let</span> i=0; i < items.length; i++) {
        <span class="code">yield</span> items[i];
    }
}

<span class="code">let</span> iterator = createIterator([1, 2, 3]);

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: 2, done: false }"
console.log(iterator.next());           // "{ value: 3, done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"

<span class="comment"><em>// за всички по-нататъшни извиквания</em></span>
console.log(iterator.next());           // "{ value: undefined, done: true }"
			</pre></dd>
		</dl>
		<p>Този пример, подава масив наречен <em>items</em> на <em>createIterator()</em> функцията генератор. Във вътрешността на функцията, <em>for</em> цикъл добива елементите от масива с прогреса на цикъла. Всеки път, където се среща <em>yield</em>, цикъла спира и всеки път, когато <em>next()</em> се извика върху итератора, цикъла продължава със следващия <em>yield</em>.</p>
		<p>Генератор функциите са важна характеристика на ECMAScript 6 и тъй като са само функции, те могат да се използват във всички подобни места. Останалата част от този раздел се фокусира върху други полезни начини да се пишат генератори.</p>
		<dl>
			<dd><div class="worning">
         <img src="./img/worning.jpg" alt="worning">
       </div><strong>Ключовата дума <em>yield</em> може да се използва само в рамките на генератори. Използването на <em>yield</em> на друго място е синтактична грешка, включително и при функции, които са вътре в генератори, като например:</strong></dd>
		
			<dd><pre class="highlight">
<span class="code">function</span> *createIterator(items) {
    items.forEach(<span class="code">function</span>(item) {
            //syntax error
            <span class="code">yield</span> item + 1;
	});
}       
			</pre></dd>
			<dd><div class="worning">
			 </div><strong>Въпреки че <em>yield</em> е технически вътре в <em>createIterator()</em>, този код е синтактична грешка, защото <em>yield</em> не може да пресече границите на функцията. По този начин, <em>yield</em> е подобен на <em>return</em>, в това, че вложената функция не може да върне стойност за своята съдържаща функция.</strong></div>
		</dl>
		<h3>Generator Function Expressions</h3>
		<p>Можете да използвате функция израз за да създадете генератор, като просто поставите характера звезда (*) между думата <em>function</em> и отварящите скоби.</p>
		<dl>
			<dd><pre class="highlight-overflow">
<span class="code">let</span> createIterator = <span class="code">function</span> *(items) {
    <span class="code">for</span> (<span class="code">let</span> i=0; i < items.length; i++) {
        <span class="code">yield</span> items[i];
    }
};

<span class="code">let</span> iterator = createIterator([1, 2, 3]);

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: 2, done: false }"
console.log(iterator.next());           // "{ value: 3, done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"

<span class="comment"><em>// за всички по-нататъшни извиквания</em></span>
console.log(iterator.next());           // "{ value: undefined, done: true }"
			</pre></dd>
		</dl>
		<p>В този код, <em>createIterator()</em> е по-скоро израз на генератор функция, от колкото декларация на функция. Тъй като израза на функцията е анонимен, звездата е между ключовата дума <em>function</em> и отварящите скоби. В противен случай, този пример ще е същия, като предишния вариант на <em>createIterator()</em>, който използва <em>for</em> цикъл.</p>
		<dl>
			<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Не е възможно да се създаде функция стрела, която да е генератор.</strong></dd>
		</dl>
		<h3>Методи на генератор обекта</h3>
		<p>Тъй като генераторите са само функции, те могат да бъдат добавени към обекти, по същия начин, както и другите функции. Например, можем да направим генератор в ECMAScript 5 обект, буквално с функция израз:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">var</span> o = {

    createIterator: <span class="code">function</span> *(items) {
        <span class="code">for</span> (<span class="code">let</span> i=0; i < items.length; i++) {
            <span class="code">yield</span> items[i];
        }
    }
};

<span class="code">let</span> iterator = o.createIterator([1, 2, 3]);
				
			</pre></dd>
		</dl>
		<p>Можем да използваме ECMAScript 6 метода за краткия запис, като поставим звезда (*) пред името на метода:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">var</span> o = {

    *createIterator(items) {
        <span class="code">for</span> (<span class="code">let</span> i=0; i < items.length; i++) {
            <span class="code">yield</span> items[i];
        }
    }
};

<span class="code">let</span> iterator = o.createIterator([1, 2, 3]);
			</pre></dd>
		</dl>
		<p>Този пример е функционално еквивалентен на предишния, като единствената разлика е в използването на синтаксиса. Тъй като <em>createIterator()</em> метода се дефинира с помощта на краткия запис без ключовата дума <em>function</em>, звездата се поставя непосредствено преди името на метода, макар че може да има празно пространство между звездата и метода.</p>
		<h3>Iterables и for-of</h3>
		<p>Тясно свързан с концепцията за итератори е <em>iterable</em> обект със <em>Symbol.iterator</em> свойство. <em>Well-known Symbol.iterator</em> определя функция, която връща итератор за дадения обект. Всички обекти колекции, включително масиви, <em>sets</em> и <em>maps</em>, както и <em>strings</em>, са <em>iterables</em> в ECMAScript 6 и така имат зададен итератор по подразбиране. <em>Iterables</em> са предназначени да бъдат използвани с новото допълнение в ECMAScript: <em>for-of</em> цикъл.</p>
		<dl>
			<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Всички итератори създадени от генератори са <em>iterables</em>, тъй като генераторите присвояват свойството <em>Symbol.iterator</em> по подразбиране.</strong></dd>
		</dl>
		<p>В началото на тази глава, споменах проблема с проследяването на индекс в един <em>for</em> цикъл. Итераторите са първата част от решението на този проблем. Цикъла <em>for-of</em> е втората част: той изцяло премахва необходимостта да се следи индекс в колекция, като ви оставя да се съсредоточите върху работата със съдържанието на колекцията.</p>
		<p>Цикъла <em>for-of</em> извиква <em>next()</em> върху <em>iterable</em> всеки път при изпълнението на цикъла и съхранява стойността на резултата в променлива. Цикъла продължава този процес, докато свойството <em>done</em> от върнатия обект е <em>true</em>. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> values = [1, 2, 3];

<span class="code">for</span> (<span class="code">let</span> num of values) {
    console.log(num);
}
			</pre></dd>
		</dl>
		<p>Този код извежда следното:</p>
		<dl>
			<dd><pre class="highlight">
				<p>1<br>2<br>3</p>
			</pre>
			</dd>
		</dl>
		<p>Цикъла <em>for-of</em> в този пример първо извиква <em>Symbol.iterator</em> метода върху <em>values</em> масива за извличане на итератор. (Извикването на <em>Symbol.iterator</em> се случва зад кулисите в самия двигател на JavaScript). После, се извиква <em>iterator.next()</em> и <em>value</em> свойството върху обекта на резултата и се чете в <em>num</em>. Така променливата <em>num</em> първо е 1, после 2 и на края 3. Когато <em>done</em> в обекта на резултата стане <em>true</em>, цикъла излиза, така че <em>num</em> никога няма да присвои стойността <em>undefined</em>.</p>
		<p>Предимството на <em>for-of</em> за разлика от традиционния <em>for</em> цикъл е, че  никога не трябва да следите индекса в колекцията. Цикъла <em>for-of</em> обикновено е по-малко склонен към грешки, защото има по-малко условия за следене. Запазването на традиционния <em>for</em> цикъл е за по-сложни условия на контрол.</p>
		<dl>
			<dd><div class="worning">
         <img src="./img/worning.jpg" alt="worning">
       </div><strong><em>for-of</em> изявлението ще хвърли грешка, когато се използва върху <em>non-iterable</em> обект, <em>null</em> или <em>undefined</em>.</strong></dd>
		</dl>
		<h3>Достъп до Default Iterator</h3>
		<p>Можете да използвате <em>Symbol.iterator</em>, за да получите достъп до <em>default</em> итератор на даден обект, като това:</p>
		<dl>
			<dd><pre class="highlight-overflow">
<span class="code">let</span> values = [1, 2, 3];
<span class="code">let</span> iterator = values[Symbol.iterator]();

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: 2, done: false }"
console.log(iterator.next());           // "{ value: 3, done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"
			</pre></dd>
		</dl>
		<p>Този код получава <em>default</em> итератор за <em>values</em> и използва това за обхождане на елементите в масива. Това е същия процес, който се случва зад кулисите, когато се използва <em>for-of</em> цикъл.</p>
		<p>Тъй като <em>Symbol.iterator</em> определя <em>default</em> итератор, можем да го използваме, за да разберем дали даден обект е <em>iterable</em>, както следва:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">function</span> isIterable(object) {
    <span class="code">return typeof</span> object[Symbol.iterator] === "function";
}

console.log(isIterable([1, 2, 3]));     // true
console.log(isIterable("Hello"));       // true
console.log(isIterable(<span class="code">new</span> Map()));     // true
console.log(isIterable(<span class="code">new</span> Set()));     // true
console.log(isIterable(<span class="code">new</span> WeakMap())); // false
console.log(isIterable(<span class="code">new</span> WeakSet())); // false
			</pre></dd>
		</dl>
		<p>Функцията <em>isIterable()</em> просто проверява дали съществува <em>default</em> итератор в обекта и дали е функция. Това е подобно на проверката, която <em>for-of</em> цикъла прави преди да се изпълни.</p>
		<p>До сега примерите в този раздел показват начини за използване <em>Symbol.iterator</em> с вградени <em>iterable</em> видове, но можете да използвате <em>Symbol.iterator</em> свойството да създадете свои собствени <em>iterables</em>.</p>
		<h3>Създаване на  Iterables</h3>
		<p>Програмно дефинирани обекти не са <em>iterable</em> по подразбиране но можем да ги направим <em>iterable</em> чрез създаване на <em>Symbol.iterator</em> свойство съдържащо генератор. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> collection = {
    items: [],
    *[Symbol.iterator]() {
        <span class="code">for</span> (<span class="code">let</span> item of <span class="code">this</span>.items) {
            <span class="code">yield</span> item;
        }
    }

};

collection.items.push(1);
collection.items.push(2);
collection.items.push(3)

<span class="code">for</span> (<span class="code">let</span> x of collection) {
    console.log(x);
}

// Output:
// 1
// 2
// 3
			</pre></dd>
		</dl>
		<p>Този код дефинира <em>default iterator</em> за обект наречен <em>collection</em>. <em>Default</em> итератор се създава от <em>Symbol.iterator</em> метода, който е генератор (обърнете внимание, че звездата все още идва преди името). Генератора след това  използва <em>for-of</em> за обхождане на стойностите в <em>this.items</em> и използва <em>yield</em> за да върне всяка една. Така че, вместо ръчни итерации да определят стойности за <em>default</em> итератора на <em>collection</em> за връщане, обекта <em>collection</em> разчита на <em>default</em> итератора на <em>this.items</em> да свърши работата.</p>
		<dl>
			<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>"Делегиране на генератори" по-късно в тази глава описва по-различен подход за използването на итератор на друг обект.</strong></dd>
		</dl>
		<p>До сега видяхме някои употреби на <em>default</em> итератори за масиви, но има много повече вградени итератори в ECMAScript 6 за да направи работата с колекции от данни по-лесна.</p>
		<h3>Вградени итератори</h3>
		<p>Итераторите са важна част от ECMAScript 6 и като такива, не е нужно да създавате свои собствени итератори за много вградени типове, които езика включва по подразбиране. Ще ви се наложи да създавате итератори, когато откриете, че няма такива вградени, които да обслужват целите ви, най-често при определяне на ваши собствени обекти или класове. В противен случай, можете да разчитате на вградените итератори да си свършат работата. Може би най-често срещаните употреби на итератори са тези, които работят с колекции. </p>
		<h3>Итератори за колекции</h3>
		<p>ECMAScript 6 има три вида обекти колекции: <em>arrays, maps</em> и <em>sets</em>. И трите имат едни и същи вградени итератори, които да ви помогнат да навигирате в тяхното съдържание.</p>
		<dl>
			<dd>
				<ul>
					<li><strong>entries() </strong>- връща итератор, чиито стойности са двойка ключ-стойност.</li>
					<li><strong>values() </strong>- връща итератор, чиито стойности са стойностите на колекцията.</li>
					<li><strong>keys() </strong>- връща итератор, чийто, стойности са ключовете, които се съдържат в колекцията.</li>
				</ul>
			</dd>
		</dl>
		<p>Можете да извлечете <em>iterator</em> за колекция, като извикате един от тези методи.</p>
		<h4>The entries() Iterator</h4>
		<p>Итератора <em>entries()</em> връща масив с два елемента и извиква <em>next()</em> всеки път. Дву-елементния масив представлява ключ и стойност за всеки елемент в колекцията. За масиви първият елемент е цифров индекс. За <em>sets</em> първия елемент е стойността (понеже стойността се удвоява, като ключ в <em>sets</em>). За <em>maps</em> първия елемент е ключа.</p>
		<p>Ето няколко примера, които използват този итератор:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> colors = [ "red", "green", "blue" ];
<span class="code">let</span> tracking = <span class="code">new</span> Set([1234, 5678, 9012]);
<span class="code">let</span> data = <span class="code">new</span> Map();

data.set("title", "Understanding ECMAScript 6");
data.set("format", "ebook");

<span class="code">for</span> (<span class="code">let</span> entry of colors.entries()) {
    console.log(entry);
}

<span class="code">for</span> (<span class="code">let</span> entry of tracking.entries()) {
    console.log(entry);
}

<span class="code">for</span> (<span class="code">let</span> entry of data.entries()) {
    console.log(entry);
}
			</pre></dd>
		</dl>
		<p>Извикването на <em>console.log()</em> извежда следното:</p>
			<dl>
				<dd><pre class="highlight">
					<p>[0, "red"] <br>[1, "green"] <br>[2, "blue"]<br>[1234, 1234]<br>[5678, 5678]<br>[9012, 9012]<br>["title", "Understanding ECMAScript 6"]<br>["format", "ebook"]</p>
				</pre>
				</dd>
			</dl>
			<p>Този код използва метода <em>entries()</em> върху всеки тип от колекцията за извличане на итератор и <em>for-of</em> за обхождане на елементите. От изхода на конзолата, можете да видите ключовете и стойностите, върнати по двойки за всеки елемент.</p>
			<h4>The values() Iterator</h4>
			<p>Итератора <em>values()</em> просто връща стойностите, като те се съхраняват в колекцията. Например:</p>
			<dl>
				<dd><pre class="highlight">
<span class="code">let</span> colors = [ "red", "green", "blue" ];
<span class="code">let</span> tracking = <span class="code">new</span> Set([1234, 5678, 9012]);
<span class="code">let</span> data = <span class="code">new</span> Map();

data.set("title", "Understanding ECMAScript 6");
data.set("format", "ebook");

<span class="code">for</span> (<span class="code">let</span> value of colors.values()) {
    console.log(value);
}

<span class="code">for</span><span class="code">for</span> (<span class="code">let</span> value of tracking.values()) {
    console.log(value);
}

<span class="code">for</span> (<span class="code">let</span> value of data.values()) {
    console.log(value);
} 
                </pre></dd>
			</dl>
			<p>Този пример извежда следното:</p>
			<dl>
				<dd><pre class="highlight">
					<p>"red"<br>"green"<br>"blue"<br> 1234<br> 5678<br> 9012<br>"Understanding ECMAScript 6"<br>"ebook"</p>
				</pre>
				</dd>
			</dl>
			<p>В този случай, използвайки <em>values()</em> връща точните данни, съдържащи се в колекцията без никаква информация за тяхното местоположение.</p>
			<h4>The keys() Iterator</h4>
			<p>Итератора <em>keys()</em> връща всеки ключ присъстващ в колекцията. За масиви, това е само цифровия ключ, той никога не връща други собствени свойства на масива. За <em>sets</em>, ключовете винаги са същите, като стойностите и така <em>keys()</em> и <em>values()</em> връщат същия итератор. За <em>maps</em>, това е всеки уникален ключ. Ето един пример:</p>
			<dl>
				<dd><pre class="highlight">
<span class="code">let</span> colors = [ "red", "green", "blue" ];
<span class="code">let</span> tracking = <span class="code">new</span> Set([1234, 5678, 9012]);
<span class="code">let</span> data = <span class="code">new</span> Map();

data.set("title", "Understanding ECMAScript 6");
data.set("format", "ebook");

<span class="code">for</span> (<span class="code">let</span> key of colors.keys()) {
    console.log(key);
}

<span class="code">for</span> (<span class="code">let</span> key of tracking.keys()) {
    console.log(key);
}

<span class="code">for</span> (<span class="code">let</span> key of data.keys()) {
    console.log(key);
}
				</pre></dd>
			</dl>
			<p>Този пример извежда следното:</p>
			<dl>
				<dd>
					<pre class="highlight">
					<p>0 <br>1 <br>2 <br>1234 <br>5678<br>9012 <br>"title"<br>"format"</p>
				</pre>
				</dd>
			</dl>
			<p>Итератора <em>keys()</em> извлича всеки ключ в <em>colors, tracking</em> и <em>data</em> и тези ключове са отпечатани от вътрешната страна на три <em>for-of</em> цикъла. За обект на масиви, се отпечатват само цифрови индекси, дори ако сте добавили имена на свойства в масива. Това е различно от начина, по който <em>for-in</em> цикъла работи с масиви, тъй като итерациите на <em>for-in</em> цикъла минават над свойствата, а не само върху цифровите индекси.</p>
			<h4>Default Iterators for Collection Types</h4>
			<p>Всеки тип колекция има <em>default</em> итератор, който се използва от <em>for-of</em> всеки път, когато итератора не е изрично посочен. Метода <em>values()</em> е итератора по подразбиране за <em>arrays</em> и <em>sets</em>, а метода <em>entries()</em> е итератор по подразбиране за <em>maps</em>. Тези настройки правят малко по-лесно използването на обекти колекции в <em>for-of</em>. Например, да видим следния пример:</p>
			<dl>
				<dd><pre class="highlight">
<span class="code">let</span> colors = [ "red", "green", "blue" ];
<span class="code">let</span> tracking = <span class="code">new</span> Set([1234, 5678, 9012]);
<span class="code">let</span> data = <span class="code">new</span> Map();

data.set("title", "Understanding ECMAScript 6");
data.set("format", "ebook");

<span class="comment"><em>//също, като използването на colors.values()</em></span>
<span class="code">for</span> (<span class="code">let</span> value of colors) {
    console.log(value);
}

<span class="comment"><em>//също, като използването на tracking.values()</em></span>
<span class="code">for</span> (<span class="code">let</span> num of tracking) {
    console.log(num);
}

<span class="comment"><em>//също, като използването на data.entries()</em></span>
<span class="code">for</span> (<span class="code">let</span> entry of data) {
    console.log(entry);
}
				</pre></dd>
			</dl>
			<p>Няма посочен итератор, така че ще се използват функциите на итератор по подразбиране. Итераторите по подразбиране за масиви, комплекти и карти са предназначени да отразяват как се инициализират тези обекти, така че този код извежда следното:</p>
			<dl>
				<dd>
					<pre class="highlight">
					<p>"red"<br>"green"<br>"blue"<br>1234 <br>5678 <br>9012 <br>["title", "Understanding ECMAScript 6"]<br>["format", "ebook"]</p>
				</pre>
				</dd>
			</dl>
			<p>Така масиви и <em>sets</em> връщат техните стойности по подразбиране, докато <em>maps</em> връща същия формат - масив, който може да бъде прехвърлен в <em>Map</em> конструктора. <em>Weak sets</em> и <em>weak maps</em> от друга страна, нямат вградени итератори. Управлението на <em>weak</em> референции означава, че няма начин да се знае точно колко стойности са в тези колекции, което също означава, че няма начин да се обхождат.</p>

            <div class="aside">
		<h3>Destructuring и for-of цикли</h3>
		<p>Поведението на <em>default</em> конструктора за <em>maps</em> също е полезно, когато се използва в <em>for-of</em> цикли с <em>destructuring</em>, като в този пример:</p>
		<pre class="highlight">
<span class="code">let</span> data = <span class="code">new</span> Map();

data.set("title", "Understanding ECMAScript 6");
data.set("format", "ebook");

<span class="comment"><em>// също, като използването на data.entries()</em></span>
<span class="code">for</span> (<span class="code">let</span> [key, value] of data) {
    console.log(key + "=" + value);
}
				</pre>
		<p>Цикъла <em>for-of</em> в този пример, използва <em>destructuring</em> на масив, за присвояване <em>key</em> и <em>value</em> за всеки запис в <em>map</em>. По този начин можете лесно да работите с ключове и стойности едновременно без да се налага да получавате достъп до масива с двата елемента. Използването на <em>destructured</em> на масив в <em>map</em> прави <em>for-of</em> цикъла еднакво полезен, както за <em>maps</em>, така и за <em>arrays</em> и <em>sets</em>.</p>
		</div>
			<h3>String итератори</h3>
			<p>Започвайки с ECMAScript 5, JavaScript <em>strings</em> бавно се развиват да бъдат масиво-подобни. Например, ECMAScript 5 официално стандартизират скоби нотацията за достъп до символите в <em>string</em> (<em>text[0]</em> за да получим първия символ). За съжаление скоби нотацията работи върху кодови единици, вместо характери, така че не може да се използва за достъп до двубайтови характери правилно. Както този пример показва:</p>
			<dl>
				<dd><pre class="highlight">
<span class="code">var</span> message = "A ð ®• B";

<span class="code">for</span> (<span class="code">let</span> i=0; i < message.length; i++) {
    console.log(message[i]);
}
				</pre></dd>
			</dl>
			<p>Този код използва скоби нотация и <em>length</em> свойство за обхождане и отпечатване на <em>string</em>, съдържащ Unicode характери. Изходът е малко неочаквано:</p>
			<dl>
				<dd>
					<pre class="highlight">
					<p>A <br>(blank)<br>(blank)<br>(blank)<br>(blank)<br>B</p>
				</pre>
				</dd>
			</dl>
			<p>Тъй като, двубитовите характери се третират, като две отделни кодови единици, има четири празни реда между А и В в продукцията.</p>
			<p>За щастие, ECMAScript 6 има за цел да поддържа напълно Unicode (виж <a href="./02_strings.html">Глава 2</a>) и <em>default</em> итератор за <em>string</em> е опит да се реши проблема със <em>string</em> итерацията. Като такъв, <em>default</em> итератор за <em>string</em> работи върху характери, а не върху кодови единици. Промяната на този пример, да използва <em>default</em> итератор за <em>string</em> с <em>for-of</em> цикъл има по-добър резултат. Ето и промения код:</p>
			<dl>
				<dd><pre class="highlight">
<span class="code">var</span> message = "A ð ®• B";

<span class="code">for</span> (<span class="code">let</span> c of message) {
    console.log(c);
}
				</pre></dd>
			</dl>
			<p>Този код извежда следното:</p>
			<dl>
				<dd>
					<pre class="highlight">
					<p>A <br>(blank)<br>ð ®• <br>(blank)<br>B</p>
				</pre>
				</dd>
			</dl>
			<p>Този изход е повече в съответствие с това, което очакваме, когато се работи с характери, цикъла успешно отпечатва Unicode характери, както и всички останали.</p>
			<h3>NodeList итератори</h3>
			<p>В Document Object Model (DOM), е типа NodeList, който представлява колекция от елементи в даден документ. За тези, които пишат JavaScript да се изпълнява в уеб-барузъри, разбирането на разликата между NodeList обекти и масиви, винаги е била малко трудна. И двата използват <em>length</em> свойство за да посочи броя на елементите и двата използват скоби нотация за достъп до отделните елементи. Обаче, вътрешно NodeList и масиви се държат съвсем различно и това довежда до голямо объркване.</p>
			<p>С добавянето на <em>default</em> итератори в ECMAScript 6, DOM определението за NodeList (включено в спецификацията на HTML, а не само в ECMAScript 6) включва <em>default</em> итератор, който се държи по същия начин, както <em>default</em> итератора за масиви. Това означава, че можете да използвате NodeList в <em>for-of</em> цикъл или на всяко друго място, което използва <em>default</em> итератор върху даден обект. Например:</p>
			<dl>
				<dd><pre class="highlight">
<span class="code">var</span> divs = document.getElementsByTagName("div");

<span class="code">for</span> (<span class="code">let</span> div of divs) {
    console.log(div.id);
}
				</pre></dd>
			</dl>
			<p>Този код използва <em>getElementsByTagName()</em> метода за извличане на  NodeList , който представлява съвкупност от всички &ltdiv&gt елементи в документа. Цикъла <em>for-of</em> с итерации минава над всеки елемент и извежда техните ID номера ефективно, правейки кода да изглежда също, както при стандартен масив.</p>
			<h3>Оператора Spread и Non-Array Iterables</h3>
			<p>В <a href="./07_set_and_map.html">Глава 7</a>, видяхме как оператора <em>spread (...)</em>, може да се използва за конвентиране на <em>set</em> в масив. Например:</p>
			<dl>
				<dd><pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> Set([1, 2, 3, 3, 3, 4, 5]),
    array = [...set];

console.log(array);            // [1,2,3,4,5]
				</pre></dd>
			</dl>
			<p>Този код използва оператора <em>spread</em> вътре в масива за да го попълни със стойности от <em>set</em>. Оператора <em>spread</em> работи на всички <em>iterables</em> и използва <em>default</em> итератор за да определи кои стойности да включи. Всички стойности се четат от итератора и след това се вкарват в масива в реда, по който се връщат от итератора. Този пример работи, защото <em>sets</em> е <em>iterables</em>, но може да работи еднакво добре на всеки <em>iterable</em>. Ето още един пример:</p>
			<dl>
				<dd><pre class="highlight">
<span class="code">let</span> map = <span class="code">new</span> Map([ ["name", "Nicholas"], ["age", 25]]),
    array = [...map];

console.log(array);     // [ ["name", "Nicholas"], ["age", 25]]
				</pre></dd>
			</dl>
			<p>Тука, <em>map</em> се конвертира в масив от масиви с помощта на оператора <em>spread</em>. Тъй като <em>default</em> итератора за <em>maps</em> връща двойки ключ-стойност, резултата на масива прилича на масива, който се подава на <em>new Map()</em>.</p>
			<p>Няма ограничения, колко пъти може да използвате оператора <em>spread</em> и можете да го използвате навсякъде, където искате и да вмъкнете няколко елемента от <em>iterable</em>. Тези елементи просто ще се появят в новия масив на мястото на оператора <em>spread</em>. Например:</p>
			<dl>
				<dd><pre class="highlight">
<span class="code">let</span> smallNumbers = [1, 2, 3],
    bigNumbers = [100, 101, 102],
    allNumbers = [0, ...smallNumbers, ...bigNumbers];

console.log(allNumbers.length);     // 7
console.log(allNumbers);    // [0, 1, 2, 3, 100, 101, 102]
				</pre></dd>
			</dl>
			<p>Тука, оператора <em>spread</em> се използва за създаване на <em>allNumbers</em> от стойностите на <em>smallNumbers</em> и <em>bigNumbers</em>. Стойностите са поставени в <em>allNumbers</em> в реда, по който са вкарани в масивите, когато <em>allNumbers</em> се създава: 0 е на първо място, следвана от стойностите на <em>smallNumbers</em>, следвани от стойностите на <em>bigNumbers</em>. Имайте в предвид, че  оригиналните масиви са непроменени, само техните стойности са копирани в <em>allNumbers</em>.</p>
			<p>Тъй като, оператора <em>spread</em> може да се използва на всеки <em>iterable</em>, това е най-лесният начин за конвертиране <em>iterable</em> в масив. Можете да конвертирате <em>strings</em> в масив от характери (а не кодови единици) и <em>NodeList</em> обекти в браузъра в масив от разклонения.</p>
			<p>Сега знаете основите на това, как работят итераторите, включително на <em>for-of</em> и оператора <em>spread</em> и е време да разгледаме някои от по-сложните приложения на итератори.</p>
			<h3>Напреднала Iterator функционалност</h3>
			<p>Можете да постигнете много с основните функции на итераторите и удобството за тяхното създаване използвайки генератори. Въпреки това, итераторите са много по-мощни, когато се използват за задачи различни от просто повторение на колекция от стойности. По време на разработването на ECMAScript 6, многото появили се уникални идеи и модели, са причина за добавянето на по-голяма функционалност. Някои от тези допълнения са едва доловими, но когато се използват заедно, можем да постигнем някои интересни взаимодействия.</p>
			<h3>Подаване на параметри към итераторите</h3>
			<p>В тази глава видяхме, че итераторите могат да  подават стойности чрез <em>next()</em> метода или използвайки <em>yield</em> на генератора. Но също така е възможно да подаваме аргументи към итератора чрез <em>next()</em> метода. Когато един аргумент се подава към <em>next()</em> метода, той става стойност на <em>yield</em> изявлението вътре в генератора. Например:</p>
			<dl>
				<dd><pre class="highlight-overflow">
<span class="code">function</span> *createIterator() {
    <span class="code">let</span> first = <span class="code">yield</span> 1;
    <span class="code">let</span> second = <span class="code">yield</span> first + 2;       // 4 + 2
    <span class="code">yield</span> second + 3;                   // 5 + 3
}

<span class="code">let</span> iterator = createIterator();

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next(4));          // "{ value: 6, done: false }"
console.log(iterator.next(5));          // "{ value: 8, done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"
				</pre></dd>
			</dl>
			<p>Първото извикване на <em>next()</em> е специален случай, където всеки аргумент подаден към него се губи. Тъй като аргументите подадени към <em>next()</em> стават стойността върната от <em>yield</em>, трябва да намерим начин за достъп до този аргумент преди първия <em>yield</em> във функцията на генератора. Това не е възможно, така че няма причина да подаваме аргумент при първото извикване на <em>next()</em>.</p>
			<p>При второто извикване на <em>next()</em>, стойността 4 се подава, като аргумент. 4 е присвоена от първата променлива вътре във функцията на генератора. В <em>yield</em> изявлението е включено прехъврляне от дясната страна на израза за оценяване от първото извикване на <em>next()</em> и от лявата страна се оценява второто извикване на <em>next()</em> преди функцията да продължи да се изпълнява. Тъй като, към второто извикване на <em>next()</em> е подадено 4, тази стойност се определя на <em>first</em> и след това изпълнението продължава.</p>
			<p>Втория <em>yield</em> използва резултата на първия <em>yield</em> и добавя две, което означава, че връща стойност шест. Когато <em>next()</em> се извика трети път, се подава стойността 5, като аргумент. Тази стойност се присвоява от променливата <em>second</em> и след това се използва в третото <em>yield</em> изявление, за да върне осем.</p>
			<p>Малко по-лесно е да се мисли за това, което се случва, като се вземе в предвид кой код се изпълнява всеки път, когато изпълнението продължава вътре във функцията на генератора. Фигура 6-1 използва цветове, за да покаже кода, който се изпълнява преди <em>yielding</em>.</p>
			<dl>
				<dd><pre class="highlight">
<span class="code">function</span> *createIterator(){
	<span style="background: yellow">next()</span>       <span style="background: aqua">let first =</span><span style="background: yellow">yield 1;</span>
	<span style="background: aqua">next(4)</span>      <span style="background: pink">let second =</span><span style="background: aqua">yield first + 2;</span>
	<span style="background: pink">next(5)</span>      <span style="background: pink">yield second + 3;</span>
}				</pre></dd>
			</dl>
			<p>Фигура 6-1: Изпълнение на кода вътре в генератора.</p>
			<p>Жълтия цвят представлява първото извикване на <em>next()</em> и целия код, който се изпълнява в рамките на генератора, като резултат. Зеления цвят представлява извикването на <em>next(4)</em> и кода който се изпълнява.  Розовия цвят представлява извикването на <em>next(5)</em> и кода, който се изпълнява, като резултат. Най-сложната част е кода от дясната страна на всеки израз, изпълнението и спирането преди изпълнението на лявата страна. Това прави дебъгването на генератори малко по-ангажиращо, от колкото на редовни функции.</p>
			<p>До сега видяхме, че <em>yield</em> може да действа, като <em>return</em>, когато се подаде стойност към <em>next()</em>. Все пак, това не е само трик при изпълнението вътре в генератора. Можем също така да накараме итератора да хвърля грешки.</p>
			<h3>Хвърляне на грешки в итераторите</h3>
			<p>Не само е възможно да подаваме данни в итераторите, а също така е възможно да подаваме условия за грешки. Итераторите могат да изберат да приложат <em>throw()</em> метод, който възлага на итератора да хвърли грешка, когато се задейства отново. Това е важна възможност за асинхронното програмиране, но също така и гъвкавост вътре в генератори, където искаме да бъде в състояние да се имитират двете стойности за връщане и хвърляне на грешки (двата начина за излизане от функция). Вие може да подадете обект за грешка към <em>throw()</em>, която трябва да бъде хвърлена, докато итератора продължава обработката. Например:</p>
			<dl>
				<dd><pre class="highlight-overflow">
<span class="code">function</span> *createIterator() {
    <span class="code">let</span> first = <span class="code">yield</span> 1;
    <span class="code">let</span> second = <span class="code">yield</span> first + 2;       <span class="comment"><em>// yield 4 + 2, след това хвърля грешка</em></span>
    <span class="code">yield</span> second + 3;                   <span class="comment"><em>// никога не се изпълнява</em></span>
}

<span class="code">let</span> iterator = createIterator();

console.log(iterator.next());                   // "{ value: 1, done: false }"
console.log(iterator.next(4));                  // "{ value: 6, done: false }"
console.log(iterator.<span class="code">throw</span>(<span class="code">new Error</span>("Boom"))); <span class="comment"><em>// грешка хвърлена от генератора</em></span>
				</pre></dd>
			</dl>
			<p>В този пример, първите два <em>yield</em> израза се оценяват, като нормални, но когато се извика <em>throw()</em> е хвърлена грешка преди да се оцени  втория <em>let second</em>. Това на практика спира изпълнението на кода, подобно на директно хвърляне на грешка. Единствената разлика е мястото, където се хвърля грешката. Фигура 6-2 показва кой код се изпълнява на всяка стъпка.</p>
			<dl>
				<dd><pre class="highlight">
<span class="code">function</span> *createIterator(){
	<span style="background: yellow">next()</span>                <span style = "background: aqua">let first =</span><span style="background: yellow">yield 1;</span>
	<span style="background: aqua">next(4)</span>               let second<span style = "background: red">*</span><span style="background: aqua">yield first + 2;</span>
	<span style="background: red">throw(new Error());</span>   yield + 3;
}				</pre></dd>
			</dl>
			<p>Фигура 6-2: Хвърляне на грешка вътре в генератора.</p>
			<p>В тази фигура, червеният цвят представлява кода, който се изпълнява, когато се извика <em>throw()</em> и червената звезда показва приблизително, кога грешката е хвърлена вътре в генератора. Първите две <em>yield</em> изявления се изпълняват и когато <em>throw()</em> се извика, грешката се хвърля преди изпълнението на някакъв друг код.</p>
			<p>Знаейки това, можем да уловим такава грешка вътре в генератора, с помоща на <em>try-catch</em> блок, като:</p>
			<dl>
				<dd><pre class="highlight-overflow">
<span class="code">function</span> *createIterator() {
    <span class="code">let</span> first = <span class="code">yield</span> 1;
    <span class="code">let</span> second;

    <span class="code">try</span> {
        second = <span class="code">yield</span> first + 2;       <span class="comment"><em>// yield 4 + 2, след това хвърля грешка</em></span>
    } <span class="code">catch</span> (ex) {
        second = 6;                     <span class="comment"><em> // на грешката е присвоена различна стойност</em></span>
    }
    <span class="code">yield</span> second + 3;
}

<span class="code">let</span> iterator = createIterator();

console.log(iterator.next());                   // "{ value: 1, done: false }"
console.log(iterator.next(4));                  // "{ value: 6, done: false }"
console.log(iterator.<span class="code">throw</span>(<span class="code">new Error</span>("Boom"))); // "{ value: 9, done: false }"
console.log(iterator.next());            // "{ value: undefined, done: true }"
				</pre></dd>
			</dl>
			<p>В този пример, <em>try-catch</em> блока се увива около второто <em>yield</em> изявление. Докато този <em>yield</em> се изпълнява без грешка, грешката се хвърля преди някаква стойност да може да бъде присвоена на <em>second</em>, така че, <em>catch</em> блока му присвоява стойност шест. Изпълнението продължава към следващия <em>yield</em> и връща девет.</p>
			<p>Също ще забележите, че се случва нещо интересно - <em>throw()</em> метода връща стойност подобна на тази върната от <em>next()</em>. Защото, грешката е уловена във вътршността на генератора и изпълнението на кода  продължава към следващия <em>yield</em> и връща съответната стойност 9.</p>
			<p>Това помага да се мисли за <em>next()</em> и <em>throw()</em>, като две инструкции за итератора: <em>next()</em> метода инструктира итератора да продължи изпълнението (евентуално с дадената стойност), а <em>throw()</em> инструктира итератора да продължи изпълнението с хвърляне на грешка. Какво се случва след тази точка, зависи от кода вътре в генератора.</p>
			<p>Методите за контрол на изпълнението <em>next()</em> и <em>throw()</em> вътре в генератора са с използване на <em>yield</em>, но може също да използваме <em>return</em> изявлението. Въпреки, че то работи малко по-различно, от колкото в обикновените функции, както ще видим в следващия раздел.</p>
			<h3>Return изявление на генератор</h3>
			<p>Тъй като генераторите са функции, можем да използваме <em>return</em> изявление за да излезем по-рано и да зададем сойност за връщане за последното извикване на <em>next()</em> метода. В повечето примери, които видяхме в тази глава, последното извикване на <em>next()</em> върху итератора връща <em>undefined</em>. Възможно е да посочим алтернативна стойност, чрез използване на <em>return</em>, както бихме направили във всяка друга функция. В генератора, <em>return</em> показва, че цялата обработка е приключила,  така че <em>done</em> свойството е настроено на <em>true</em> и стойността, ако предвидена, се връща във <em>value</em> полето. Ето един пример, който излиза рано използвайки <em>return</em>:</p>
			<dl>
				<dd><pre class="highlight-overflow">
<span class="code">function</span> *createIterator() {
    <span class="code">yield</span> 1;
   <span class="code">return</span>;
    <span class="code">yield</span> 2;
    <span class="code">yield</span> 3;
}

<span class="code">let</span> iterator = createIterator();

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"
				</pre></dd>
			</dl>
			<p>В този код генератора има <em>yield</em> изявление последвано от <em>return</em> изявление. <em>Return</em> показва, че няма да идват повече стойности и останалата част от <em>yield</em> изявленията не се изпълнява (те са недостижими).</p>
			<p>Можем също така да определим стойност за връщане, която да се покаже във <em>value</em> полето на върнатия обект . Например:</p>
			<dl>
				<dd><pre class="highlight-overflow">
<span class="code">function</span> *createIterator() {
    <span class="code">yield</span> 1;
    <span class="code">return</span> 42;
}

<span class="code">let</span> iterator = createIterator();

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: 42, done: true }"
console.log(iterator.next());           // "{ value: undefined, done: true }"
				</pre></dd>
			</dl>
			<p>Тука, върнатата стойност е 42 във <em>value</em> полето от второто извикване на <em>next()</em> (което е първия път, когато <em>done</em> е <em>true</em>). Третото извикване на <em>next()</em> връща обект, чието <em>value</em> свойство отново е <em>undefined</em>. Всяка стойност посочена с <em>return</em> е достъпна само един път във върнатия обект, преди <em>value</em> полето да върне <em>undefined</em>.</p>
			<dl>
				<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Оператора <em>spread</em> и <em>for-of</em> цикъла, игнорират всяка стойност определена от <em>return</em> изявлението. Веднага след като видят, че done е <em>true</em>, те спират без да прочетат стойността.</strong></dd>
			</dl>
			<p>Стойности за връщане на итератора са полезни, когато се делегират генератори.</p>
			<h3>Делегиране на генератори</h3>
			<p>В някои случаи е полезно да се комбинират стойностите от два итератора в един. Генератори могат да се делегират към други генератори, използвайки общата специална форма на <em>yield</em> със звезда (*). Както с дефиницията на генератор, няма значение къде се поставя звездата, стига да е между ключовата дума <em>yield</em> и името на функцията генератор. Например:</p>
			<dl>
				<dd><pre class="highlight-overflow">
<span class="code">function</span> *createNumberIterator() {
    <span class="code">yield</span> 1;
    <span class="code">yield</span> 2;
}

<span class="code">function</span> *createColorIterator() {
    <span class="code">yield</span> "red";
    <span class="code">yield</span> "green";
}

<span class="code">function</span> *createCombinedIterator() {
    <span class="code">yield</span> *createNumberIterator();
    <span class="code">yield</span> *createColorIterator();
    <span class="code">yield</span> true;
}

<span class="code">var</span> iterator = createCombinedIterator();

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: 2, done: false }"
console.log(iterator.next());           // "{ value: "red", done: false }"
console.log(iterator.next());           // "{ value: "green", done: false }"
console.log(iterator.next());           // "{ value: true, done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"
				</pre></dd>
			</dl>
			<p>В този пример, генератора <em>createCombinedIterator()</em> делегира първо <em>createNumberIterator()</em> и след това <em>createColorIterator()</em>. Итератора за връщане е един последователен итератор, който ще произведе всички стойности. Всяко извикване на <em>next()</em> се делегира на подходящ итератор, докато итераторите създадени от <em>createNumberIterator()</em> и <em>createColorIterator()</em> са празни. След финала <em>yield</em> се изпълнява, за да се върне <em>true</em>.</p>
			<p>Делегирането на генератори също ни позволява да използваме генератор за връщане на стойности. Това е най-лесният начин за достъп до такива стойности за връщане и може да бъде полезно при изпълнение на сложни задачи. Например:</p>
			<dl>
				<dd><pre class="highlight-overflow">
<span class="code">function</span> *createNumberIterator() {
    <span class="code">yield</span> 1;
    <span class="code">yield</span> 2;
    <span class="code">return</span> 3;
}

<span class="code">function</span> *createRepeatingIterator(count) {
    <span class="code">for</span> (<span class="code">let</span> i=0; i < count; i++) {
        <span class="code">yield</span> "repeat";
    }
}

<span class="code">function</span> *createCombinedIterator() {
    <span class="code">let</span> result = <span class="code">yield</span> *createNumberIterator();
    <span class="code">yield</span> *createRepeatingIterator(result);
}

<span class="code">var</span> iterator = createCombinedIterator();

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: 2, done: false }"
console.log(iterator.next());           // "{ value: "repeat", done: false }"
console.log(iterator.next());           // "{ value: "repeat", done: false }"
console.log(iterator.next());           // "{ value: "repeat", done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"
				</pre></dd>
			</dl>
			<p>Тука, генератора <em>createCombinedIterator()</em> делегира <em>createNumberIterator()</em> и подава стойността за връщане към <em>result</em>. Тъй като <em>createNumberIterator()</em> съдържа <em>return</em> 3, върнатата стойност е 3.  Променливата <em>result</em> се подава към <em>createRepeatingIterator()</em>, като аргумент, който показва, колко пъти да се приложи <em>yield</em> върху този <em>string</em> (в този случай 3 пъти).</p>
			<p>Забележете, че стойността 3 не е изход от всяко извикване на <em>next()</em> метода, тя съществува единствено във вътрешността на <em>createCombinedIterator()</em> генератора. Възможно е да се изведе тази стойност с добавяне на друго <em>yield</em> изявление, като този пример:</p>
			<dl>
				<dd><pre class="highlight-overflow">
<span class="code">function</span> *createNumberIterator() {
    <span class="code">yield</span> 1;
    <span class="code">yield</span> 2;
    <span class="code">return</span> 3;
}

<span class="code">function</span> *createRepeatingIterator(count) {
    <span class="code">for</span> (<span class="code">let</span> i=0; i < count; i++) {
        <span class="code">yield</span> "repeat";
    }
}

<span class="code">function</span> *createCombinedIterator() {
    <span class="code">let</span> result = <span class="code">yield</span> *createNumberIterator();
    <span class="code">yield</span> result;
    <span class="code">yield</span> *createRepeatingIterator(result);
}

<span class="code">var</span> iterator = createCombinedIterator();

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: 2, done: false }"
console.log(iterator.next());           // "{ value: 3, done: false }"
console.log(iterator.next());           // "{ value: "repeat", done: false }"
console.log(iterator.next());           // "{ value: "repeat", done: false }"
console.log(iterator.next());           // "{ value: "repeat", done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"
				</pre></dd>
			</dl>
			<p>В този код, допълнителното <em>yield</em> изявление изрично извежда върнатата стойност от <em>createNumberIterator()</em>.</p>
			<p>Делегирания генератор използвайки стойността за връщане е много мощен пример, който дава възможност за много интересни възможности, особено когато се използва в асинхронни операции.</p>
			<dl>
				<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Можете да използвате <em>yield *</em> директно върху <em>strings</em>, също като <em>yield * "hello"</em> и <em>default</em> итератора за <em>string</em> ще бъде използван.</strong></dd>
			</dl>
			<h3>Асинхронен task runner</h3>
			<p>Много от вълнението около генератори е пряко свързано с използването им в асинхронното програмиране. Асинхронното програмиране в JavaScript е нож с две остриета: много е лесно да се правят  прости неща, докато сложните неща остават една поръчка в организацията на кода. Тъй като, генераторите позволяват ефективно да се слага пауза по средата на изпълнението на кода, това отваря много възможности, тъй като се отнася до асинхронна обработка.</p>
			<p>Традиционният начин за извършване на асинхронни операции е да се извика функция, която има обратно извикване. Например, помислете за четене на файл от диск в Node.js:</p>
			<dl>
				<dd><pre class="highlight">
<span class="code">let</span> fs = require("fs");

fs.readFile("config.json", <span class="code">function</span>(err, contents) {
   <span class="code">if</span>(err) {
        <span class="code">throw</span> err;
    }

    doSomethingWith(contents);
    console.log("Done");
});
				</pre></dd>
			</dl>
			<p>Метода <em>fs.readFile()</em> се извиква с името на файла за четене и функция за обратно извикване. Когато операцията приключи, се извиква функцията за обратно извикване. Обратното извикване проверява дали има грешка и ако няма процеса се връща на <em>contents</em>. Това работи добре, когато имате малък ограничен брой асинхронни задачи за извършване, но се усложнява, когато трябва да влагате още обратни извиквания или последователна поредица от асинхронни задачи. Това е мястото, където генераторите и <em>yield</em> са полезни.</p>
			<h3>A Simple Task Runner</h3>
			<p>Понеже <em>yield</em> спира изпълнението и чака следващия метод <em>next()</em> да бъде извикан преди да започне отново, това осигурява начин за изпълнение на асинхронни повиквания, без управление на обратните извиквания. За да започнете ви трябва функция, която да извика генератор и да стартира итератора, също като:</p>
			<dl>
				<dd><pre class="highlight">
<span class="code">function</span> run(taskDef) {

    <span class="comment"><em>//създаване на итератор, предоставен на друго място</em></span>
    <span class="code">let</span> task = taskDef();

    <span class="comment"><em>//стартиране на task</em></span>
    <span class="code">let</span> result = task.next();

    <span class="comment"><em>//рекурсивна функция, която държи извикванията към next()</em></span>
    <span class="code">function</span> step() {

        <span class="comment"><em> // ако има още нещо за правене</em></span>
        <span class="code">if</span> (!result.done) {
            result = task.next();
            step();
        }
    }

    <span class="comment"><em>//старт на процеса</em></span>
    step();

}
				</pre></dd>
			</dl>
			<p>Функцията <em>run()</em> приема дефиницията на задачата (функцията генератор), като аргумент. Тя призовава генератора да създаде итератор и го съхранява в <em>task</em>. Променливата <em>task</em> е извън функцията, така че да може да бъде достъпна от други функции (причина, която ще стане ясна по-късно в този раздел). Първото извикване към <em>next()</em> стартира итератора и резултата се съхранява за по-нататъшна употреба. Функцията <em>step()</em> проверява дали <em>result.done</em> е <em>false</em> и ако е така извиква <em>next()</em> преди рекурсивно да извика себе си. Всяко извикване към <em>next()</em> съхранява върнатата стойност в <em>result</em>, така тази променлива се презаписва и винаги ще съдържа актуална информация. Първоначалното извикване на <em>step()</em> стартира процеса за търсене на <em>result.done</em> променливата, за да види дали има още нещо за правене.</p>
			<p>Това изпълнение на <em>run()</em>, може да работи с генератор съдържащ множество <em>yield</em> изявления, също като:</p>
			<dl>
				<dd><pre class="highlight">
run(<span class="code">function</span>*() {
    console.log(1);
    <span class="code">yield</span>;
    console.log(2);
    <span class="code"><span class="code">yield</span></span>;
    console.log(3);
});
				</pre></dd>
			</dl>
			<p>Този пример просто извежда три номера на конзолата, което просто показва, че всички извиквания към <em>next()</em> се правят. Понеже, само получаване на номера няколко пъти не е нещо полезно, следващата стъпка е да се подават стойности във и извън итератора.</p>
			<h3>Task Running с данни</h3>
			<p>Най-лесният начин за подаване на данни е чрез подаване на стойността определена от <em>yield</em> на следващото извикване на <em>next()</em> метода. За да направим това, само трябва да подадем <em>result.value</em>, както в този код:</p>
			<dl>
				<dd><pre class="highlight">
<span class="code">function</span> run(taskDef) {

    <span class="comment"><em>//създаване на итератор, предоставен на друго място</em></span>
    <span class="code">let</span> task = taskDef();

    <span class="comment"><em>//стартиране на task</em></span>
    <span class="code">let</span> result = task.next();

    <span class="comment"><em>//рекурсивна функция, която държи извикванията към next()</em></span>
    <span class="code">function</span> step() {

        <span class="comment"><em> // ако има още нещо за правене</em></span>
        <span class="code">if</span> (!result.done) {
            result = task.next(result.value);
            step();
        }
    }

    <span class="comment"><em>//старт на процеса</em></span>
    step();

}	
				</pre></dd>
			</dl>
			<p>С тази промяна, когато <em>result.value</em> се подава на <em>next()</em>, като аргумент вече е възможно да се подават данни между <em>yield</em> извикванията, както в този пример:</p>
			<dl>
				<dd><pre class="highlight">
run(<span class="code">function</span>*() {
    <span class="code">let</span> value = <span class="code">yield</span> 1;
    console.log(value);         // 1

    value = <span class="code">yield</span> value + 3;
    console.log(value);         // 4
}); 
            </pre></dd>
			</dl>
			<p>Този пример извежда две стойности на конзолата: 1 и 4. Стойността  1 идва от <em>yield</em> 1, като 1 се прехвърля обратно към променливата <em>value</em>.  4 се изчислява чрез добавяне на 3 към <em>value</em> и подава този резултат обратно към <em>value</em>. Сега, когато потока от данни между извикванията на <em>yield</em> е осъществен, трябва само една малка промяна, за да се даде възможност за асинхронни извиквания.</p>
			<h3>Асинхронен task runner</h3>
			<p>В предишния пример подаваме статични данни назад и напред между <em>yield</em> извикванията, но очакване на асинхронен процес е малко по-различно. <em>Task runner</em> трябва да знае за обратните извиквания и как да ги използва. И тъй като <em>yield</em> изразите подават техните стойности в <em>task runner</em>, това означава, че всяко извикване на функция трябва да върне стойност, която по някакъв начин показва, че е асинхронна операция, която <em>task runner</em> трябва да изчака.</p>
			<p>Ето един начин за сигнализиране, че стойността е асинхронна операция:</p>
			<dl>
				<dd><pre class="highlight">
<span class="code">function</span> fetchData() {
    <span class="code">return function</span>(callback) {
        callback(<span class="code">null</span>, "Hi!");
    };
}
				</pre></dd>
			</dl>
			<p>За целите на този пример, всяка функция трябва да се извика с <em>task runner</em>, който ще върне функция, която изпълнява обратното извикване. Функцията <em>fetchData()</em> връща функция, която приема функцията за обратно извикване, като аргумент. Когато върнатата функция се извика, тя изпълнява функцията за обратно извикване с едно парче данни (<em>string</em> "Hi!"). Аргумента <em>callback</em> трябва да дойде от <em>task runner</em>, за да се гарантира, че това извикване правилно взаимодейства с основния итератор. Докато функцията <em>fetchData()</em> е синхронна, може лесно да се удължи и да стане асинхронна, чрез извикване на обратното извикване с леко закъснение, като например:</p>
			<dl>
				<dd><pre class="highlight">
<span class="code">function</span> fetchData() {
    <span class="code">return function</span>(callback) {
        setTimeout(<span class="code">function</span>() {
            callback(<span class="code">null</span>, "Hi!");
        }, 50);
    };
}           
            </pre></dd>
			</dl>
			<p>Тази версия на <em>fetchData()</em> въвежда 50ms закъснение преди да се извика обратното извикване, което показва, че този модел работи еднакво добре, както за синхронен така и за асинхронен код. Просто трябва да се уверите, че всяка функция, която трябва да се извика с помощта на <em>yield</em> следва същия този модел.</p>
			<p>С добро разбиране на това, как една функция сигнализира, че това е асинхронен процес, можете да промените <em>task runner</em> да вземе този факт в предвид. Винаги <em>result.value</em> е функция и <em>task runner</em> ще я изпълни, вместо просто да подаде тази стойност в <em>next()</em> метода. Това е актуализирания код:</p>
			<dl>
				<dd><pre class="highlight">
<span class="code">function</span> run(taskDef) {

    <span class="comment"><em>// създаване на итератор, предоставен на друго място</em></span>
    <span class="code">let</span> task = taskDef();

    <span class="comment"><em>// стартиране на task</em></span>
    <span class="code">let</span> result = task.next();

   <span class="comment"><em>// рекурсивна функция, която държи извикванията към next()</em></span>
    <span class="code">function</span> step() {

        <span class="comment"><em>// ако има още нещо за правене</em></span>
        <span class="code">if</span> (!result.done) {
            <span class="code">if</span> (<span class="code">typeof</span> result.value === "function") {
                result.value(<span class="code">function</span>(err, data) {
                    <span class="code">if</span>(err) {
                        result = task.<span class="code">throw</span>(err);
                        <span class="code">return</span>;
                    }

                    result = task.next(data);
                    step();
                });
            } <span class="code">else</span> {
                result = task.next(result.value);
                step();
            }

        }
    }

        <span class="comment"><em>// старт на процеса</em></span>
    step();

}
				</pre></dd>
			</dl>
			<p>Когато <em>result.value</em> е функция (проверено с === оператора), тя се извиква с функцията за обратно извикване. Тази функция за обратно извикване следва конвенцията на Node.js за подаване на всяка възможна грешка, като първи аргумент (err) и резултатът, като втори аргумент. Ако се открие грешка се извиква <em>task.throw()</em> с обекта за грешка, вместо <em>task.next()</em>, така грешката е хвърлена на правилното място. Ако няма грешка, тогава данните се подават в <em>task.next()</em> и резултата се записва. След това, се извиква <em>step()</em>, за да продължи процеса. Когато <em>result.value</em> не е функция, тя се прехвърля директно в <em>next()</em> метода.</p>
			<p>Тази нова версия на <em>task runner</em> е готова за всички асинхронни задачи. За да се четат данни от файл в Node.js, вие трябва да създадете обвивка около <em>fs.readFile()</em>, която връща функция подобна на функцията <em>fetchData()</em> от по-рано в тази секция. Например:</p>
			<dl>
				<dd><pre class="highlight">
<span class="code">let</span> fs = require("fs");

<span class="code">function</span> readFile(filename) {
    <span class="code">return function</span>(callback) {
        fs.readFile(filename, callback);
    };
}
				</pre></dd>
			</dl>
			<p>Метода <em>readFile()</em> приема един аргумент, името на файла и връща функция, която извиква обратното извикване. Обратното извикване се подава директно към <em>fs.readFile()</em>, която ще го изпълни обратното извикване при завършване. След това може да стартирате задачата с помощта на <em>yield</em>, както следва:</p>
			<dl>
				<dd><pre class="highlight">
run(<span class="code">function</span>*() {
    <span class="code">let</span> contents = <span class="code">yield</span> readFile("config.json");
    doSomethingWith(contents);
    console.log("Done");
});
				</pre></dd>
			</dl>
			<p>Този код, извършва асинхронната операция на <em>readFile()</em> без да прави никакви обратни извиквания. Освен <em>yield</em>, кода изглежда по същия начин, както синхронния код. Докато всички функции изпълняващи асинхронни операции, отговарят на един и същи интерфейс, можете да напишете логика, която се чете като синхронен код.</p>
			<p>Разбира се има недостатъци на модела, използван в тези примери, а именно, че не винаги може да сме сигурни, че една функция, която връща функция е асинхронна. За сега, обаче е важно само да разберете теорията зад <em>task running</em>. Има по-мощни начини за правене на асинхронна задача за планиране с помощта на <em>promises</em> (обещания), които ще бъдат обхванати по-подробно в <a href="11_promises.html">Глава 11</a>.</p>
	</article>
	<footer>
		<h3>Обобщение</h3>
		<p>Итераторите са важна част от ECMAScript 6 и са в основата на няколко важни части от езика. На повърхността итераторите предоставят лесен начин да се върне последователност от стойности с помощта на просто API. Въпреки това, има далеч по-сложни начини за използване на итератори в ECMAScript 6</p>
		<p><em>Symbol.iterator</em> се използва за определяне на итератори по подразбиране за обекти. Както вградените обекти, така и дефинираните от програмисти обекти могат да използват този символ, за да се осигури метод, който връща итератор. Когато <em>Symbol.iterator</em> се предостави на  обект, той се счита за <em>iterable</em>.</p>
		<p>Цикъла <em>for-of</em> използва <em>iterables</em> за да върне поредица от стойности в един цикъл. Това прави използването на <em>for-of</em> цикли по-лесно в сравнение с традиционните <em>for</em> цикли, защото вече няма нужда да следите стойности и контрол, когато цикъла завършва. Цикъла <em>for-of</em> автоматично чете всички стойности от итератора и когато там няма повече излиза.</p>
		<p>За да бъде по-лесно използването на <em>for-of</em>, много стойности в ECMAScript 6 имат <em>default</em> итератори. Всички типове колекции, <em>arrays</em>, <em>maps</em> и <em>sets</em> имат итератори, предназначени за лесен достъп до съдържанието им. <em>Strings</em> също имат <em>default</em> итератори, за лесно обхождане на характерите в <em>string</em> (вместо кодови единици).</p>
		<p>Оператора <em>spread</em> работи с всички <em>iterable</em> и прави лесно конвертирането на <em>iterables</em> в масиви. Той прави това чрез четене на стойности от итератора и ги поставя индивидуално в масив.</p>
		<p>Генераторите са специален тип функция, която автоматично създава итератор, когато се извика. Тези функции са обозначени в началото с (*) и използват ключовата дума <em>yield</em> за да посочат коя стойност да се върне със следващото извикване на <em>next()</em> метода.</p>
		<p>Делегирането на генератори влияе добре за капсулиране на поведението на итераторите, като дава възможност за повторното използване на съществуващи генератори в нови такива. Това се прави, като се използва <em>yield *</em> вместо само <em>yield</em>, което позволява създаването на итератор, който връща стойности от множество итератори.</p>
		<p>Може би най-интересния и вълнуващ аспект на генераторите и итераторите е възможността за създаване на по-чист вид асинхронен код. Вместо да се налага използването на обратни извиквания навсякъде, може да настроите кода, който изглежда синхронно, но в действителност използва <em>yield</em>, да изчака асинхронните операции да завършат.</p>
	</footer>
	<nav>
	<a href="./07_set_and_map.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="09_classes.html" title="next chapter">▶</a>
</nav>
</body>
</html>