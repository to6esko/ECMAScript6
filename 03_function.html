<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Funciton :: Understanding ECMAScript 6</title>
	<link rel="stylesheet" href="font.css">
</head>

<body>
	<nav>
		<a href="./02_strings.html" title="previous chapter">◀</a>
		<a href="./index.html" title="cover">◆</a>
		<a href="./04_object_function.html" title="next chapter">▶</a>
	</nav>

	<header id="header" class="">
		<h1>
			<div class="head-num">Глава 3</div>Функции</h1>
		<p>Функциите са важна част от всеки език за програмиране, преди ECMAScript 6 функциите в JavaScript не са се променили много,
			от както е създаден езика. Това остави нерешени проблеми и поведение, които лесно правят грешки и често изискват повече
			код, само за постигане на основно поведение.</p>
		<p>В ECMAScript 6 функциите правят голяма крачка напред, като се вземат в предвид годините на жалби и молби от програмистите
			на JavaScript. Резултата е редица постепенни подобрения върху ECMAScript 5 функциите, които правят програмирането на JavaScript
			с по-малко грешки и по-мощно.</p>
	</header>
	<!-- /header -->
	<article>
		<h3>Функции със стойности по подразбиране на параметрите</h3>
		<p>Функциите в JavaScript са уникални с това, че позволяват произволен брой подадени параметри, независимо от броя на параметрите
			обявени в дефиницията на функцията. Това позволява да се дефинират функции, които могат да се справят с различни номера
			на параметри, често само с попълване на стойности по подразбиране, когато параметри не са предвидени. В този раздел се
			обяснява, как параметрите по подразбиране работят преди и след ECMAScript 6, заедно с важна информация относно обекта
			на аргументите, използвайки изрази, като параметри и друга TDZ.</p>
		<h3>Симулиране на стойности по подразбиране на параметрите в ECMAScript 5</h3>
		<p>В ECMAScript 5 и по-рано, най-вероятно се е използвал следният модел за създаване на функции с
			<em>default</em> стойности на параметрите:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> makeRequest(url, timeout, callback) {				
    timeout = timeout || 2000;
    callback = callback || <span class="code">function</span>() {};
    <span class="comment"><em>// останалата част от функцията</em></span>
}
                </pre>
			</dd>
		</dl>
		<p>В този пример,
			<em>timeout</em> и
			<em>callback</em> са всъщност по избор, тъй като са им дадени
			<em>default</em> стойности, ако не е предвиден параметър. Логическия оператор или (||) винаги се връща на втория операнд,
			когато първия е
			<em>falsе</em>. Тъй наречените функционални параметри, които не са изрично предвидени, са настроени на
			<em>undefined</em>, логическия оператор или (||), често се използва за осигуряване на стойности по подразбиране за липсващи
			параметри. Има един недостатък на този подход, обаче, в който валидна стойност за
			<em>timeout</em> може да е 0, което ще се замести с 2000, защото 0 е
			<em>falsе</em>.</p>
		<p>В този случай, по-безопасно е да се провери вида на аргумента, използвайки
			<em>typeof</em>, като в примера:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">function</span> makeRequest(url, timeout, callback) {
  timeout = (<span class="code">typeof</span> timeout !== "undefined") ? timeout : 2000;
  callback = (<span class="code">typeof</span> callback !== "undefined") ? callback : function() {};
    <span class="comment"><em>// останалата част от функцията</em></span>
}
            </pre>
			</dd>
		</dl>
		<p>Макар, че този подход е по-безопасен, той все още изисква доста допълнителен код за много основни операции. Популярни JavaScript
			библиотеки са пълни с подобни модели, понеже това представлява общ модел.</p>
		<h3>
			<em>Default</em> стойности на параметрите в ECMAScript 6</h3>
		<p>ECMAScript 6 прави по-лесно осигуряването на стойности за параметрите чрез предоставяне на инициализации, които се използват,
			когато параметъра не е официално подаден. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> makeRequest(url, timeout = 2000, 
callback = <span class="code">function</span>() {}) {
    <span class="comment"><em>// останалата част от функцията</em></span>
}		
				</pre>
			</dd>
		</dl>
		<p>Тази функция само очаква първия параметър винаги да бъде приет. Другите два параметъра имат
			<em>default</em> стойности, което прави тялото на функцията, много по-малко, защото не е нужно да се добавя всеки код за проверка
			на липсващата стойност.</p>
		<p>Когато
			<em>makeRequest()</em> се извиква с всичките три параметъра,
			<em>default</em> не се използват. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="comment"><em>// използва default timeout и callback</em></span>
makeRequest("/foo");

<span class="comment"><em>// използва default callback</em></span>
makeRequest("/foo", 500);

<span class="comment"><em>// не използва  default</em></span>
makeRequest("/foo", 500, <span class="code">function</span>(body) {
    doSomething(body);
});			
				</pre>
			</dd>
		</dl>
		<p>ECMAScript 6 счита
			<em>url</em> за задължителен, ето защо "/foo" е подаден във всички три извиквания на
			<em>makeRequest()</em>. Двата параметъра със
			<em>default</em> стойности не се считат за задължителни.</p>
		<p>Възможно е да се определят
			<em>default</em> стойности за всички аргументи, включително и тези, които се появяват преди аргументите без
			<em>default</em> стойности в декларацията на функцията. Например, това е добре:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> makeRequest(url, timeout = 2000, callback) {
    <span class="comment"><em>// останалата част от функцията</em></span>
}		
				</pre>
			</dd>
		</dl>
		<p>В този случай,
			<em>default</em> стойността на
			<em>timeout</em> ще бъде използвана само в случай ако няма втори аргумент или ако втория аргумент е изрично приет, като
			<em>undefined</em>, както в този пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="comment"><em>// използва default timeout</em></span>
makeRequest("/foo", <span class="code">undefined</span>, <span class="code">function</span>(body) {
    doSomething(body);
});

<span class="comment"><em>// използва default timeout</em></span>
makeRequest("/foo");

<span class="comment"><em>// не използва default timeout</em></span>
makeRequest("/foo", <span class="code">null</span>, <span class="code">function</span>(body) {
    doSomething(body);
});			
				</pre>
			</dd>
		</dl>
		<p>В случай на
			<em>default</em> стойности на параметрите, стойност от
			<em>null</em>, се счита за валидна, което означава, че при третото извикване на
			<em>makeRequest()</em>,
			<em>default</em> стойността на
			<em>timeout</em> няма да се използва.</p>
		<h3>Как
			<em>default</em> стойностите на параметрите се отразяват на обекта на аргументите</h3>
		<p>Само имайте в предвид, че поведението на
			<em>arguments</em> обекта е различно, когато са налице
			<em>default</em> стойности на параметрите. В ECMAScript 5 при
			<em>nonstrict mode</em>,
			<em>arguments</em> обекта се отразява на промените в обявените параметри на функцията. Ето част от код, който илюстрира как
			работи това:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> mixArgs(first, second) {
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
    first = "c";
    second = "d";
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
}
mixArgs("a", "b");
				</pre>
			</dd>
		</dl>
		<p>Това е изхода:</p>
		<dl>
			<dd>
				<pre class="highlight">
			<p>true<br>true <br>true<br>true</p>
			    </pre>
			</dd>
		</dl>
		<p>
			<em>arguments</em> обекта винаги се актуализира в
			<em>nonstrict mode</em> за да отрази промените в обявените параметри. По този начин, на
			<em>first</em> и
			<em>second</em> са възложени нови стойности
			<em>arguments[0]</em> и
			<em>arguments[1]</em>, които се актуализират съответно, което кара всички === сравнения да решат вярно.</p>
		<p>В ECMAScript 5 при
			<em>strict mode</em>, обаче, се елиминира този объркващ аспект на
			<em>arguments</em> обекта. В
			<em>strict mode</em>,
			<em>arguments</em> обекта не отразява промените в обявените параметри. Ето отново
			<em>mixArgs()</em> функцията, но в
			<em>strict mode</em>:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> mixArgs(first, second) {
    "use strict";
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
    first = "c";
    second = "d"
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
}
mixArgs("a", "b");
				</pre>
			</dd>
		</dl>
		<p>Извикването на
			<em>mixArgs()</em> извежда:</p>
		<dl>
			<dd>
				<pre class="highlight">
			<p>true<br>true <br>falsе<br>falsе</p>
			    </pre>
			</dd>
		</dl>
		<p>Този път смяната на
			<em>first</em> и
			<em>second</em> няма ефект върху
			<em>arguments</em>, така че продукцията се държи нормално, както сме очаквали.</p>
		<p>В
			<em>arguments</em> обекта на функция използваща ECMAScript 6, стойностите по подразбиране на параметрите, обаче, винаги се
			държат по същия начин, както ECMAScript 5 в
			<em>strict mode</em>, независимо дали функцията работи в
			<em>strict mode</em>. Наличието на
			<em>default</em> стойности на параметрите задейства
			<em>arguments</em> обекта да остане откъснат от обявените параметри. Това е малка но важна подробност, защото е начин, по
			който
			<em>arguments</em> обекта може да се използва. Помислете за следното:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="comment"><em>// не е в strict mode</em></span>
<span class="code">function</span> mixArgs(first, second = "b") {
    console.log(arguments.length);
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
    first = "c";
    second = "d"
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
}
mixArgs("a");	
			    </pre>
			</dd>
		</dl>
		<p>Това е изхода:</p>
		<dl>
			<dd>
				<pre class="highlight">
			<p>1<br>true <br>falsе<br>falsе<br>falsе</p>
			    </pre>
			</dd>
		</dl>
		<p>В този пример,
			<em>arguments.length</em> е 1 защото само един аргумент е подаден в
			<em>mixArgs()</em>. Това също означава, че
			<em>arguments[1]</em> е
			<em>undefined</em>, което е най-очакваното поведение, когато само един аргумент е подаден към функцията. Това означава, че
			<em>first</em> е равен на
			<em>arguments[0]</em>. Промяната на
			<em>first</em> и
			<em>second</em> няма никакъв ефект върху
			<em>arguments</em>. Това се случва, както при
			<em>nonstrict</em>, така и при
			<em>strict mode</em>, така че, може да разчитате
			<em>arguments</em> да отразяват винаги първоначалното състояние на повикване.</p>
		<h3>Default Parameter Expressions</h3>
		<p>Може би най-интересната особеност на
			<em>default</em> стойностите на параметрите, е че
			<em>default</em> стойността не е необходимо да бъде примитивна стойност. Можете, например, да изпълните функция за извличане
			на
			<em>default</em> стойността от параметъра, като тази:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> getValue() {
    <span class="code">return</span> 5;
}
<span class="code">function</span> add(first, second = getValue()) {
    <span class="code">return</span> first + second;
}
console.log(add(1, 1));     // 2
console.log(add(1));        // 6	
				</pre>
			</dd>
		</dl>
		<p>Тук, ако последният аргумент не е предвиден, се извиква функцията
			<em>getValue()</em> за да изтеглим правилната
			<em>default</em> стойност. Имайте в предвид, че
			<em>getValue()</em> се извиква само, когато
			<em>add()</em> се извиква без втори параметър, но не и когато декларацията на функцията е първия разбор. Това означава, че
			ако
			<em>getValue()</em> е написана по различен начин, може потенциално да върне различна стойност. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> value = 5;
<span class="code">function</span> getValue() {
    <span class="code">return</span> value++;
}
<span class="code">function</span> add(first, second = getValue()) {
    <span class="code">return</span> first + second;
}
console.log(add(1, 1));     // 2
console.log(add(1));        // 6
console.log(add(1));        // 7	
				</pre>
			</dd>
		</dl>
		<p>В този пример,
			<em>value</em> започва, като пет и постепенно се увеличава всеки път, когато
			<em>getValue()</em> се извиква. Първото извикване на
			<em>add(1)</em> връща 6, второто извикване на
			<em>add(1)</em> връща 7, защото
			<em>value</em> се увеличава. Тъй като,
			<em>default</em> стойността за
			<em>second</em> се изчислява само, когато функцията се извика, промени на тази стойност могат да се направят по всяко време.</p>
		<dl>
			<dd>
				<div class="worning">
					<img src="./img/worning.jpg" alt="worning">
				</div>
				<strong>Бъдете внимателни, когато използвате функция извикана, като
					<em>default</em> стойност на параметри. Ако сте пропуснали скобите, като
					<em>second = getValue</em> в последния пример, вие подавате референция към функцията, а не резултата от нейното извикване.</strong>
			</dd>
		</dl>
		<p>Това поведение довежда до друга интересна възможност. Можем да използваме предшестващият
			<em>default</em> параметър, като по-късен параметър. Ето един пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> add(first, second = first) {
    <span class="code">return</span> first + second;
}
console.log(add(1, 1));     // 2
console.log(add(1));        // 2				
				</pre>
			</dd>
		</dl>
		<p>В този код, на параметъра
			<em>second</em> е дадена
			<em>default</em> стойност на
			<em>first</em>, което означава, че се подава само един аргумент, давайки на двата аргумента една и съща стойност. Така
			<em>add(1, 1)</em> ще връща 2 само, когато
			<em>add(1)</em> връща 2. Вземайки тази крачка на пред, може да се подаде
			<em>first</em>, за да получим стойността на
			<em>second</em>, както следва:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> getValue(value) {
    <span class="code">return</span> value + 5;
}
<span class="code">function</span> add(first, second = getValue(first)) {
    <span class="code">return</span> first + second;
}
console.log(add(1, 1));     // 2
console.log(add(1));        // 7	
				</pre>
			</dd>
		</dl>
		<p>Този пример, определя
			<em>second</em> да е равно на стойността върната от
			<em>getValue(first)</em>, така че докато
			<em>add(1, 1)</em> все още връща 2,
			<em>add(1)</em> връща 7 (1 + 6).</p>
		<p>Способноста за референтни параметри от
			<em>default</em> параметри работи само за предшестващите аргументи, така че по-ранните аргументи нямат достъп до по-късните
			аргументи. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> add(first = second, second) {
    <span class="code">return</span> first + second;
}
console.log(add(1, 1));     // 2
console.log(add(1));        <span class="comment"><em>// хвърля грешка</em></span>	
				</pre>
			</dd>
		</dl>
		<p>Извикването на
			<em>add(1)</em> хвърля грешка, защото
			<em>second</em> е дефиниран след
			<em>first</em> и следователно е недостъпна, като
			<em>default</em> стойност. За да се разбере, защо това се случва е важно да се преразгледат темпоралните мъртви зони.</p>
		<h3>
			<em>Default</em> стойности на параметрите в темпоралните мъртви зони</h3>
		<p>
			<a href="./01_block.html">Глава 1</a> въведе темпоралната мъртва зона (TDZ), която се отнася до
			<em>let</em> и
			<em>const</em> и
			<em>default</em> стойностите на параметрите също имат TDZ, където параметрите не могат да бъдат достъпни. Подобно на
			<em>let</em> декларацията, всеки параметър създава нов идентификатор на свързване, който не може да бъде ползван преди инициализацията
			без да хвърля грешка. Инициализацията на параметъра се случва, когато се извиква функцията с подаване на стойност за параметъра
			или с помощта на
			<em>default</em> стойност на параметъра.</p>
		<p>За да получим
			<em>default</em> стойност на параметъра в TDZ, нека отново помислим върху този пример от “Default Parameter Expressions”:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> getValue(value) {  
    <span class="code">return</span> value + 5;
}
<span class="code">function</span> add(first, second = getValue(first)) {
    <span class="code">return</span> first + second;
}
console.log(add(1, 1));     // 2
console.log(add(1));        // 7	
				</pre>
			</dd>
		</dl>
		<p>Извикването на
			<em>add(1, 1)</em> и
			<em>add(1)</em> ефективно изпълнява следния код за създаване на
			<em>first</em> и
			<em>second</em> стойности на параметрите:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="comment"><em>// JavaScript representation of call to add(1, 1)</em></span>
<span class="code">let</span> first = 1;
<span class="code">let</span> second = 1;
<span class="comment"><em>// JavaScript representation of call to add(1)</em></span>
<span class="code">let</span> first = 1;
<span class="code">let</span> second = getValue(first);
				</pre>
			</dd>
		</dl>
		<p>Когато функцията
			<em>add()</em> се изпълнява за първи път, обвързването на
			<em>first</em> и
			<em>second</em> се добавя към специфични параметри на TDZ (подобно на това, както се държи
			<em>let</em>). Така, че
			<em>second</em> може да се инициализира със стойността на
			<em>first</em>, защото
			<em>first</em> винаги се инициализира по това време, докато обратното не е вярно. Сега помислете за тази пренаписана
			<em>add()</em> функция:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> add(first = second, second) {
    <span class="code">return</span> first + second;
}
console.log(add(1, 1));         // 2
console.log(add(<span class="code">undefined</span>, 1)); <span class="comment"><em>// хвърля грешка</em></span>	
				</pre>
			</dd>
		</dl>
		<p>Извикванията на
			<em>add(1, 1)</em> и
			<em>add(undefined, 1)</em> в този пример, ще разгледаме зад кулисите на кода:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="comment"><em>// JavaScript representation of call to add(1, 1)</em></span>
<span class="code">let</span> first = 1;
<span class="code">let</span> second = 1;
<span class="comment"><em>// JavaScript representation of call to add(undefined, 1)</em></span>
<span class="code">let</span> first = second;
<span class="code">let</span> second = 1;
				</pre>
			</dd>
		</dl>
		<p>В този пример, извикването на
			<em>add(undefined, 1)</em> хвърля грешка, защото
			<em>second</em> все още не е инициализиран, когато
			<em>first</em> се инициализира. В този момент,
			<em>second</em> е в TDZ и всички препратки към
			<em>second</em> хвърлят грешка. Това е отражение на поведението на
			<em>let</em> обвързванията в
			<a href="./01_block.html">Глава 1</a>.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Параметрите на функции имат свой собствен обхват и тяхна собствена TDZ , която е отделно от обхвата на тялото на функцията.
					Това означава, че
					<em>default</em> стойността на параметъра не може да получи достъп до всички променливи, декларирани във вътрешността на
					функцията.</strong>
			</dd>
		</dl>
		<h3>Работа с анонимни параметри</h3>
		<p>Досега параметрите в тази глава са само за гарантираните параметри, които са посочени в дефиницията на функцията. Обаче,
			функциите в JavaScript не ограничават броя на параметрите, които могат да бъдат подадени спрямо броя на дефинираните параметри.
			Винаги може да се мине с по-малко или повече параметри, от колкото официално е определено.
			<em>Default</em> стойностите на параметрите правят ясно, кога дадена функция може да приеме по-малко параметри и ECMAScript
			6 иска да оправи проблема с подаване на повече параметри от дефинираните.</p>
		<h3>Анонимни параметри в ECMAScript 5</h3>
		<p>В началото, JavaScript предоставя на
			<em>arguments</em> обекта начин да се инспектира, за да се представят всички параметри на функциите, които са подадени без
			непременно определяне на всеки параметър по отделно . Докато инспектирането на
			<em>arguments</em> работи добре в повечето случаи, този обект може да работи малко по-тромаво. Например, да разгледаме този
			код, който инспектира
			<em>arguments</em> обекта:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> pick(object) {
    <span class="code">let</span> result = <span class="code">Object</span>.create(<span class="code">null</span>);
    <span class="comment"><em>// започва от втория</em></span>
    <span class="code">for</span> (<span class="code">let</span> i = 1, len = arguments.length; i < len; i++) {
        result[arguments[i]] = object[arguments[i]];
    }
    <span class="code">return</span> result;
}
<span class="code">let</span> book = {
    title: "Understanding ECMAScript 6",
    author: "Nicholas C. Zakas",
    year: 2015
};
<span class="code">let</span> bookData = pick(book, "author", "year");
console.log(bookData.author);   // "Nicholas C. Zakas"
console.log(bookData.year);     // 2015	
				</pre>
			</dd>
		</dl>
		<p>Тази функция имитира
			<em>pick()</em> метода от Underscore.js библиотеката, която връща копие на даден обект с някои специфични свойства на под-множества
			от оригиналния обект. Този пример дефинира само един аргумент и очаква първият аргумент да бъде обект, от който се копират
			свойства. Всеки друг аргумент е име на свойство, което трябва да се копира в резултата.</p>
		<p>Има няколко неща, които трябва да се отбележат за тази
			<em>pick()</em> функция. Първо, никак не е ясно, че функцията може да се справи с повече от един параметър. Може да се дефинират
			още няколко параметъра, но те винаги ще се оказват недостатъчни да покажат, че тази функция може да взема произволен брой
			параметри. Второ, понеже първият параметър е назован и се използва директно, когато търсим свойства за копиране трябва
			да започнем в
			<em>arguments</em> обекта от индекс 1 вместо от 0. Спомнете си за използването на подходящи индекси за
			<em>arguments</em>, които не е задължително да са трудни, но това е още едно нещо за следене.</p>
		<p>ECMAScript 6 въвежда
			<em>rest</em> (останали) параметри за да ви помогне с тези въпроси.</p>
		<h3 id="rest">Rest параметри</h3>
		<p>
			<em>Rest</em> параметрите са отбелязани с три точки (...) предшестващи името на параметъра. Това име става
			<em>Array</em> съдържащ останалата част от параметрите, подадени към функцията, която е мястото, от където името “rest" параметри
			произлиза. Например,
			<em>pick()</em> може да бъде пренаписана с използването на
			<em>rest</em> параметри, като тези:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> pick(object, ...keys) {
    <span class="code">let</span> result = <span class="code">Object</span>.create(<span class="code">null</span>);
    <span class="code">for</span> (<span class="code">let</span> i = 0, len = keys.length; i < len; i++) {
        result[keys[i]] = object[keys[i]];
    }
    <span class="code">return</span> result;
}	
				</pre>
			</dd>
		</dl>
		<p>В тази версия на функцията,
			<em>keys</em> е
			<em>rest</em> параметър, който съдържа всички параметри, подадени след обекта (за разлика от
			<em>arguments</em>, които съдържа всички параметри включително и първия). Това означава, че можете да обхождате
			<em>keys</em> от началото до края без да се притеснявате. Като бонус, можете да кажете на разглежданата функция да се справи
			с произволен брой параметри</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>
					<em>Rest</em> параметрите не влияят на
					<em>length</em> свойството на функцията, което показва броя на имената на параметрите за функцията. Стойността на
					<em>length</em> за
					<em>pick()</em> в този пример е 1, защото само
					<em>object</em> се брои към тази стойност.</strong>
			</dd>
		</dl>
		<h3>Ограничения на Rest параметрите </h3>
		<p>Има две ограничения за
			<em>rest</em> параметрите. Първото ограничение е, че може да има само един
			<em>rest</em> параметър и
			<em>rest</em> параметъра трябва да бъде последен. Например, този код не работи:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="comment"><em>// Syntax error:Не може да има параметър след rest параметъра</em></span>
<span class="code">function</span> pick(object, ...keys, last) {
    <span class="code">let</span> result = <span class="code">Object</span>.create(<span class="code">null</span>);
    <span class="code">for</span> (<span class="code">let</span> i = 0, len = keys.length; i < len; i++) {
        result[keys[i]] = object[keys[i]];
    }
    <span class="code">return</span> result;
}	
				</pre>
			</dd>
		</dl>
		<p>Тука параметъра
			<em>last</em> е след
			<em>rest</em> параметъра
			<em>keys</em>, което е причина за синтактична грешка.</p>
		<p>Второто ограничение е, че
			<em>rest</em> параметрите не могат да се използват в обекти, като буквални
			<em>setter</em>. Това означава, че този код също ще предизвика синтактична грешка.</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> object = {
    <span class="comment"><em>// Syntax error: Не може да се използва rest параметър в setter</em></span>
    set(...value) {
        <span class="comment"><em>// направи нещо</em></span>
    }
};	
				</pre>
			</dd>
		</dl>
		<p>Това ограничение съществува, защото
			<em>object literal setters</em> са ограничени до един аргумент.
			<em>Rest</em> параметрите по дефиниция са безкраен брой аргументи, така че не се допускат в този контекст.</p>
		<h3>Как Rest параметрите влияят на аргументите на обекта</h3>
		<p>
			<em>Rest</em> параметрите са предназначени да заменят
			<em>arguments</em> в ECMAScript. Първоначално ECMAScript 4 премахва
			<em>arguments</em> и добавя
			<em>rest</em> параметри, за да даде възможност на неограничен брой аргументи да бъдат подадени към функции. ECMAScript 4 никога
			не се появява, но тази идея се съдържа и въвежда отново в ECMAScript 6 въпреки, че
			<em>arguments</em> не са отстранени от езика.</p>
		<p>
			<em>arguments</em> обекта, работи заедно с
			<em>rest</em> параметрите чрез отразяване на аргументите, които са подадени към функцията, когато се извиква, както е показано
			в тази програма:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> checkArgs(...args) {
    console.log(args.length);
    console.log(arguments.length);
    console.log(args[0], arguments[0]);
    console.log(args[1], arguments[1]);
}
checkArgs("a", "b");	
				</pre>
			</dd>
		</dl>
		<p>Извикването на
			<em>checkArgs()</em> извежда:</p>
		<dl>
			<dd>
				<pre class="highlight">
			<p>2<br>2<br>a a<br>b b</p>
			    </pre>
			</dd>
		</dl>
		<p>
			<em>arguments</em> обекта винаги правилно отразява параметрите, които са подадени в една функция, независимо от използването
			на
			<em>rest</em> параметри.</p>
		<p>Това е всичко, което трябва да знаете за
			<em>rest</em> параметрите за да започнете да ги използвате.</p>
		<h3>Повишени възможности на Function конструктора</h3>
		<p>
			<em>Function</em> конструктора е рядко използвана част от JavaScript, която ви позволява динамично да създавате нова функция.
			Аргументите на конструктора са параметри и тяло на функцията, всички като
			<em>strings</em>. Ето един пример:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow"><span class="code">var</span> add = <span class="code">new Function</span>("first", "second", "return first + second");

console.log(add(1, 1));     // 2
					
				</pre>
			</dd>
		</dl>
		<p>ECMAScript 6 увеличава възможностите на
			<em>Function</em> конструктора да позволява
			<em>default</em> и
			<em>rest</em> параметри. Вие трябва само да добавите знак за равенство и стойност на имената на параметрите, както следва:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">var</span> add = <span class="code">new Function</span>("first", "second = first", "return first + second");
console.log(add(1, 1));     // 2
console.log(add(1));        // 2	
				</pre>
			</dd>
		</dl>
		<p>В този пример, на
			<em>second</em> параметъра се дава стойността на
			<em>first</em>, когато се подава само един параметър. Синтаксиса е същия, като при декларация на функция, която не използва
			<em>Function</em> конструктор.</p>
		<p>За
			<em>rest</em> параметрите просто добавете три точки ... преди последния параметър, като този:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> pickFirst = <span class="code">new Function</span>("...args", "return args[0]");
console.log(pickFirst(1, 2));   // 1
				</pre>
			</dd>
		</dl>
		<p>Този код създава функция, която използва само един единствен
			<em>rest</em> параметър и връща първия аргумент, който е подаден вътре.</p>
		<p>Добавянето на
			<em>default</em> и
			<em>rest</em> параметри гарантира, че
			<em>Function</em> конструктора има същите възможности, както и формата за деклариране на функция при създаването на функция.</p>
		<h3 id="spread">Оператора Spread (разпростиране)</h3>
		<p>Тясно свързан с
			<em>rest</em> параметрите е оператора
			<em>spread</em>. Докато
			<em>rest</em> параметрите ни позволяват да уточним множество независими аргументи, които трябва да бъдат комбинирани в един
			<em>array</em>, оператора
			<em>spread</em> (разпростиране) ни позволява да определим <em>array</em>, който трябва да се раздели и неговите елементи да се подадат,
			като отделни аргументи към функция. Помислете за
			<em>Math.max()</em> метода, който приема произволен брой аргументи и връща този с най-голяма стойност. Ето един прост случай
			на употреба на този метод:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> value1 = 25,
    value2 = 50;
console.log(<span class="code">Math</span>.max(value1, value2));      // 50	
				</pre>
			</dd>
		</dl>
		<p>Когато имаш работа само с две стойности, както в този пример,
			<em>Math.max()</em> е много лесен за употреба. Двете стойности се подават в него и по-голямата се връща. Но ако трябва да
			проследявате стойности на <em>array</em> и искате да се намери най-голямата стойност. Метода
			<em>Math.max()</em> не позволява подаване на <em>array</em>, така че в ECMAScript 5 и по-рано, трябваше да се залепи търсачка за <em>array</em>
			или да се използва метода
			<em>apply()</em>, както следва:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> values = [25, 50, 75, 100]
console.log(<span class="code">Math</span>.max.apply(<span class="code">Math</span>, values));  // 100	
				</pre>
			</dd>
		</dl>
		<p>Това решение работи, но използването на
			<em>apply()</em> по този начин е малко объркващо. То всъщност изглежда, че обърква истинското значение на кода с допълнителния
			синтаксис.</p>
		<p>ECMAScript 6 с оператора
			<em>spread</em> прави този случай много прост. Вместо извикване на
			<em>apply()</em>, той подава <em>array</em> на
			<em>Math.max()</em> директно и префикс със същия модел ... използван при
			<em>rest</em> параметрите. Машината JavaScript разделя <em>array</em> на отделни аргументи и ги подава по начин подобен на този:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> values = [25, 50, 75, 100]
<span class="comment"><em>// еквивалентно на</em></span>
<span class="comment"><em>// console.log(Math.max(25, 50, 75, 100));</em></span>
console.log(<span class="code">Math</span>.max(...values));           // 100			
				</pre>
			</dd>
		</dl>
		<p>Сега извикването на
			<em>Math.max()</em> изглежда малко по-конвенционално и избягва сложността за уточняване на свързващия
			<em>this</em> (първият аргумент на
			<em>Math.max.apply()</em> в предишния пример) за една проста математическа операция.</p>
		<p>Можете да смесвате и съчетавате оператора
			<em>spread</em> с други аргументи, като избор. Да предположим, че искате най-малкия номер върнат от
			<em>Math.max()</em> да е 0 (за всеки случай поставяме отрицателни числа в <em>array</em>). Можете да подадете този аргумент отделно
			и да използвате оператора
			<em>spread</em> върху другите аргументи, както следва:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> values = [-25, -50, -75, -100]
console.log(<span class="code">Math</span>.max(...values, 0));        // 0
				</pre>
			</dd>
		</dl>
		<p>В този пример последният аргумент подаден към
			<em>Math.max()</em> е 0, който идва след другите аргументи, които са подадени за използване към оператора
			<em>spread</em>.</p>
		<p>Оператора
			<em>spread</em> за подаване на аргумент, прави използването на <em>arrays</em>, като аргументи за функция много по-лесно. Най-вероятно
			ще откриете, че това е подходящ заместител на метода
			<em>apply()</em> в повечето случаи.</p>
		<p>В допълнение на употребите, които видяхте за
			<em>default</em> и
			<em>rest</em> параметрите досега в ECMAScript 6, можете също така да прилагате двата типа параметри в JavaScript Function
			конструктора.</p>
		<h3>Name свойство в ECMAScript 6</h3>
		<p>Идентифицирането на функции може да бъде предизвикателство в JavaScript, като се има в предвид различните начини, по които
			функциите могат да бъдат дефинирани. Освен това разпространяването на анонимни функционални изрази, прави отстраняването
			на грешки малко по-трудно, което често води до следи в стека, които са трудни за четене и разчитане. Поради тази причина,
			ECMAScript 6 добави
			<em>name property</em> (име свойство) за всички функции.</p>
		<h3>Избор на подходящи имена</h3>
		<p>Всички функции в една ECMAScript 6 програма ще имат подходяща стойност за тяхното
			<em>name</em> свойство. За да видите това в действие, погледнете следния пример, който показва функция и функционален израз
			и отпечатване на
			<em>name</em> свойството за двете.</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> doSomething() {
    // ...
}
<span class="code">var</span> doAnotherThing = <span class="code">function</span>() {
    // ...
};
console.log(doSomething.name);          // "doSomething"
console.log(doAnotherThing.name);       // "doAnotherThing"	
				</pre>
			</dd>
		</dl>
		<p>В този код
			<em>doSomething()</em> има
			<em>name</em> свойство равно на
			<em>"doSomething"</em>, защото това е декларация на функция. Анонимната функция
			<em>doAnotherThing()</em> има
			<em>name</em> свойство
			<em>"doAnotherThing"</em>, защото това е името на променливата, за която е предназначена.</p>
		<h3>Особени случаи на name свойството</h3>
		<p>Докато подходящи имена за декларации на функции и функционални изрази са лесни за намиране, ECMAScript 6 отива по-далеч,
			като гарантира, че всички функции са с подходящи имена. За да се убедите в това, да разгледаме следната програма:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">var</span> doSomething = <span class="code">function</span> doSomethingElse() {
    // ...
};
<span class="code">var</span> person = {
    get firstName() {
        <span class="code">return</span> "Nicholas"
    },
    sayName: <span class="code">function</span>() {
       console.log(<span class="code">this</span>.name);
    }
}
console.log(doSomething.name);      // "doSomethingElse"
console.log(person.sayName.name);   // "sayName"

<span class="code">var</span> descriptor = <span class="code">Object</span>.getOwnPropertyDescriptor(person, "firstName");
console.log(descriptor.get.name); // "get firstName"	
				</pre>
			</dd>
		</dl>
		<p>В този пример
			<em>doSomething.name</em> е
			<em>"doSomethingElse"</em>, защото самият функционален израз има име и това име е с приоритет пред променливата, на която
			е възложена функцията.
			<em>name</em> свойството
			<em>person.sayName()</em> е
			<em>"sayName"</em>, като стойността се тълкува от обекта буквално. По същия начин,
			<em>person.firstName</em> е всъщност функция на
			<em>getter</em>, така че името и е
			<em>"get firstName"</em> за да покаже тази разлика.
			<em>Setter</em> функциите са с префикс
			<em>"set"</em>. (И
			<em>getter</em> и
			<em>setter</em> функциите трябва да бъдат извлечени с помощта на
			<em>Object.getOwnPropertyDescriptor()</em>.)</p>
		<p>Има няколко други специални случаи за имена на функции, също. Функции създадени с помощта на
			<em>bind()</em> имената им ще започват с префикс
			<em>"bound"</em> и функции създадени с помощта на
			<em>Function</em> конструктор ще имат име
			<em>"anonymous"</em>, както в този пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> doSomething = <span class="code">function</span>() {
    // ...
};
console.log(doSomething.bind().name);   // "bound doSomething"
console.log((<span class="code">new Function</span>()).name);     // "anonymous"	
				</pre>
			</dd>
		</dl>
		<p>The
			<em>name</em> на обвързната функция винаги ще бъде
			<em>name</em> на функцията, обвързано с префикс
			<em>string "bound"</em>, така че обвързаната версия на
			<em>doSomething()</em> е
			<em>"bound doSomething"</em>.</p>
		<p>Имайте в предвид, че стойността на
			<em>name</em> за всяка функция, не е задължително да се отнася до променлива със същото име. Свойството
			<em>name</em> има за цел да бъде информативно, за да помогне с отстраняването на грешки, така че няма начин да се използва
			стойността на
			<em>name</em>, за да получите препратка към функцията.</p>
		<h3 id="izqsnqwane">Изясняване на двойната цел на функции</h3>
		<p>В ECMAScript 5 и по-рано, функциите които служат за двойна цел са със или без
			<em>new</em>. Когато се използват с
			<em>new</em>, стойността на
			<em>this</em> вътре във функцията е нов обект и този нов обект се връща, както е показано в следващия пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> Person(name) {
    <span class="code">this</span>.name = name;
}
<span class="code">var</span> person = new Person("Nicholas");
<span class="code">var</span> notAPerson = Person("Nicholas");
console.log(person);        // "[Object object]"
console.log(notAPerson);    // "undefined"	
		    	</pre>
			</dd>
		</dl>
		<p>Когато създаваме
			<em>notAPerson</em>, извиквайки
			<em>Person()</em> без
			<em>new</em> резултата е
			<em>undefined</em> (и поставя
			<em>name</em> свойството в глобалния обект в режим
			<em>nonstrict</em>). Капитализацията на
			<em>Person</em> е единственият реален показател, че функцията е писана да бъде извикана използвайки
			<em>new</em>, както е обичайно в програми на JavaScript. Това объркване на двойната роля на функциите доведе до промени в
			ECMAScript 6.</p>
		<p>JavaScript има два различни вътрешни метода за функции: [[Call]] и [[Construct]]. Когато дадена функция се извиква без
			<em>new</em>, се изпълнява метода [[Call]], който изпълнява тялото на функцията, както е посочено в кода. Когато дадена функция
			се извиква с
			<em>new</em>, се извиква метода [[Construct]]. Метода [[Construct]] е отговорен за създаването на нов обект, наречен
			<em>new target</em>, и след това изпълнява тялото на функцията с
			<em>this</em> настроено към новата цел. Функциите, които имат [[Construct]] метод се наричат конструктори.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong> Имайте в предвид, че не всички функции имат [[Construct]] и поради тази причина не всички функции могат да бъдат извикани
					с
					<em>new</em>. Функциите стрела, обсъдени в “Arrow Функции” на тази страница, нямат [[Construct]] метод.</strong>
			</dd>
		</dl>
		<h3>Определяне на начина на извикване на функция в ECMAScript 5</h3>
		<p>Най-популярният начин за определяне дали функцията е извикана с
			<em>new</em> (и следователно дали е конструктор) в ECMAScript 5 е с използването на
			<em>instanceof</em>, например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> Person(name) {
    <span class="code">if</span> (<span class="code">this instanceof</span> Person) {
        <span class="code">this</span>.name = name;   <span class="comment"><em>// използва new</em></span>
    } <span class="code">else</span> {
       <span class="code">throw new Error</span>("You must use new with Person.")
    }
}
<span class="code">var</span> person = <span class="code">new</span> Person("Nicholas");
<span class="code">var</span> notAPerson = Person("Nicholas");  <span class="comment"><em>// хвърля грешка</em></span>
		    	</pre>
			</dd>
		</dl>
		<p>Тука
			<em>this</em> стойноста се проверява, за да се види дали това е случай на конструктора и ако е така изпълнението продължава
			нормално. Ако
			<em>this</em> не е инстанция на
			<em>Person</em> се хвърля грешка. Това работи, защото метода [[Construct]] създава нова инстанция на
			<em>Person</em> и я възлага на
			<em>this</em>. За съжаление този подход не е напълно надежден, защото
			<em>this</em> може да бъде инстанция на
			<em>Person</em> без да се използва
			<em>new</em>, както в този пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> Person(name) {
    <span class="code">if</span> (<span class="code">this</span> instanceof Person) {
        <span class="code">this</span>.name = name;   <span class="comment"><em>// използва new</em></span>
    } <span class="code">else</span> {
        <span class="code">throw new Error</span>("You must use new with Person.")
    }
}
var person = new Person("Nicholas");
var notAPerson = Person.call(person, "Michael");    <span class="comment"><em>// работи!</em></span>	
		    	</pre>
			</dd>
		</dl>
		<p>Извикването на
			<em>Person.call()</em> подава променливата
			<em>person</em>, като първи аргумент, което означава, че
			<em>this</em> е настроена на
			<em>person</em> вътре в
			<em>Person</em> функцията. Функцията няма начин да разграничи това да бъде извикано с
			<em>new</em>.</p>
		<h3 id="target">The new.target MetaProperty</h3>
		<p>За да реши този проблем, ECMAScript 6 въвежда
			<em>new.target metaproperty. Metaproperty</em> е свойство на не-обект, което предоставя допълнителна информация свързана с
			целта (като
			<em>new</em>). Когато на дадена функция е извикан [[Construct]] метода,
			<em>new.target</em> се изпълнява с целта на
			<em>new</em> оператора. Тази цел обикновено е инстанция на конструктора на ново-създадения обект, която ще стане
			<em>this</em> във вътрешността на функцията. Ако се изпълни [[Call]], тогава
			<em>new.target</em> е
			<em>undefined</em>.</p>
		<p>Това ново
			<em>metaproperty</em> позволява, безопасно да се открие, дали дадена функция се изпълнява с
			<em>new</em>, като проверява дали
			<em>new.target</em> е дефиниран, както следва:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> Person(name) {
    <span class="code">if</span> (<span class="code">typeof new</span>.target !== "undefined") {
        <span class="code">this</span>.name = name;   <span class="comment"><em>// използва new</em></span>
    } <span class="code">else</span> {
        <span class="code">throw new Error</span>("You must use new with Person.")
    }
}
<span class="code">var</span> person = <span class="code">new</span> Person("Nicholas");
<span class="code">var</span> notAPerson = Person.call(person, "Michael");    <span class="comment"><em>// грешка!</em></span>	
		    	</pre>
			</dd>
		</dl>
		<p>С използването на
			<em>new.target</em> вместо
			<em>this instanceof Person, Person</em> конструктора вече правилно хвърля грешка, когато се използва без
			<em>new</em>.</p>
		<p>Можете също така да проверите, дали
			<em>new.target</em> се извиква с определен конструктор. Например, вижте следния пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> Person(name) {
    <span class="code">if</span> (<span class="code">typeof new</span>.target === Person) {
        <span class="code">this</span>.name = name;   <span class="comment"><em>// използва new</em></span>
    } <span class="code">else</span> {
        <span class="code">throw new Error</span>("You must use new with Person.")
    }
}
<span class="code">function</span> AnotherPerson(name) {
    Person.call(<span class="code">this</span>, name);
}
<span class="code">var</span> person = <span class="code">new</span> Person("Nicholas");
<span class="code">var</span> anotherPerson = <span class="code">new</span> AnotherPerson("Nicholas");  <span class="comment"><em>// грешка!</em></span>	
		    	</pre>
			</dd>
		</dl>
		<p>В този код,
			<em>new.target</em> трябва да е
			<em>Person</em> за да работи правилно. Когато
			<em>new AnotherPerson("Nicholas")</em> се извика, последващото извикване на
			<em>Person.call(this, name)</em> ще хвърли грешка, защтото
			<em>new.target</em> е
			<em>undefined</em> вътре в
			<em>Person</em> конструктора (който се извиква без
			<em>new</em>).</p>
		<dl>
			<dd>
				<div class="worning">
					<img src="./img/worning.jpg" alt="worning">
				</div>
				<strong>Внимание: Използването на
					<em>new.target</em> извън функция е синтактична грешка.</strong>
			</dd>
		</dl>
		<p>Чрез добавяне на
			<em>new.target</em>, ECMAScript 6 помага да се изяснят някои неясноти около извикванията на функции. Като продължение на тази
			тема, ECMAScript 6 се обръща също и към друга по-рано двусмислена част от езика: обявяване на функции вътре в блока.</p>
		<h3>Block-Level Functions</h3>
		<p>В ECMAScript 3 и по-рано, декларации на функции срещани във вътрешността на блок (
			<em>block-level function</em>) е техническа синтактична грешка, като всички браузъри го поддържат все още. За съжаление, всеки
			браузър, който позволява прояви на синтаксиса по-малко по-различен начин, ги счита за най-добри практики, като да се избягват
			декларации на функции вътре в блока (най-добрата алтернатива е да се използва функционален израз).</p>
		<p>В опит да овладее това несъвместимо поведение, ECMAScript 5
			<em>strict mode</em> въведе грешка, когато декларация на функция се използва вътре в рамките на един блок, по този начин:</p>
		<dl>
			<dd>
				<pre class="highlight">
"use strict";
<span class="code">if</span> (<span class="code">true</span>) {
    <span class="comment"><em>// хвърля синтактична грешка в ES5, но не и в ES6</em></span>
    <span class="code">function</span> doSomething() {
        // ...
    }
}	
		    	</pre>
			</dd>
		</dl>
		<p>В ECMAScript 5, този код хвърля синтактична грешка. В ECMAScript 6,
			<em>doSomething()</em> функцията се счита за блокова декларация и може да бъде достъпна и извикана в рамките на същия блок,
			в който е била определена. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
"use strict";
<span class="code">if</span> (<span class="code">true</span>) {
    console.log(<span class="code">typeof</span> doSomething);        // "function"
    <span class="code">function</span> doSomething() {
        // ...
    }
    doSomething();
}
console.log(<span class="code">typeof</span> doSomething);            // "undefined"	
		    	</pre>
			</dd>
		</dl>
		<p>
			<em>Block level</em> функциите се издигат до върха на блока в който са дефинирани, така
			<em>typeof doSomething</em> връща
			<em>"function"</em> въпреки, че се появява преди декларацията на функцията в кода. След като
			<em>if</em> блока е завършил изпълнението,
			<em>doSomething()</em> вече не съществува.</p>
		<h3>Вземане на решение, кога да се ползват Block-Level функциите</h3>
		<p>
			<em>Block level</em> функциите са сходни с функционалните изрази
			<em>let</em> в това, че дефиницията на функцията се отстранява, след като изпълнението излезе от блока, в който е дефинирана.
			Основната разлика е, че
			<em>block level</em> функциите се издигат до върха на съдържащия ги блок. Функционалните изрази, които използват
			<em>let</em> не се издигат, както този пример илюстрира:</p>
		<dl>
			<dd>
				<pre class="highlight">
"use strict";
<span class="code">if</span> (<span class="code">true</span>) {
    console.log(<span class="code">typeof</span>doSomething);        <span class="comment"><em>// хвърля грешка</em></span>
    <span class="code">let</span> doSomething = <span class="code">function</span> () {
        // ...
    }
    doSomething();
}
console.log(<span class="code">typeof</span> doSomething);
		    		</pre>
			</dd>
		</dl>
		<p>Тука, изпълнението на кода спира, когато се изпълни
			<em>typeof doSomething</em>, защото
			<em>let</em> твърдението не е изпълнено все още, оставяйки
			<em>doSomething()</em> в TDZ. Знаейки тази разлика може да изберете дали да ползвате
			<em>block level</em> функции или
			<em>let</em> изрази въз основа на това дали искате или не издигащо се поведение.</p>
		<h3>Block-Level функции в Nonstrict режим</h3>
		<p>ECMAScript 6 също така позволява блокови функции в
			<em>nonstrict</em> режим, но поведението им е малко по различно. Тези декларации вместо да се издигат до върха на блока, се
			издигат по целия път до съдържащата ги функция или глобална среда. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="comment"><em>// ECMAScript 6 поведение</em></span>
<span class="code">if</span> (<span class="code">true</span>) {
    console.log(typeof doSomething);        // "function"
    <span class="code">function</span> doSomething() {
        // ...
    }
    doSomething();
}
console.log(<span class="code">typeof</span> doSomething);            // "function"
		    		
		    	</pre>
			</dd>
		</dl>
		<p>В този пример
			<em>doSomething()</em> е издигната в глобалния обхват, така че все още съществува извън
			<em>if</em> блока. ECMAScript 6 стандартизира това поведение, за да се отстрани несъвместимо поведение с браузъра, което преди
			това съществуваше, така че всички ECMAScript 6 работещи автономно трябва да се държат по същия начин.</p>
		<p>Разрешаването на блокови функции подобрява способноста да се декларират функции в JavaScript, но ECMAScript 6 същевременно
			въвежда изцяло нов начин за деклариране на функции.</p>
		<h3>
			<a name="arrow"></a>Arrow Functions (стрела функции)</h3>
		<p>Една от най-интересните нови части на ECMAScript 6 е
			<em>arrow function</em>. Стрела функциите, както подсказва името, са функции определени с нов вид синтаксис, който използва
			“стрела” (=>). Но стрела функциите се държат по различно в сравнение с традиционните функции в JavaScript, по редица важни
			неща:</p>
		<dl>
			<dd>
				<strong>
					<ul>
						<li>
							Няма
							<em>this, super, arguments</em> и
							<em>new.target</em> обвързвания</strong> - Стойността на
				<em>this, super, arguments</em> и
				<em>new.target</em> вътре във функцията е най-близката съдържаща се
				<em>nonarrow</em> функция. (
				<em>super</em> е разгледан в
				<a href="./04_object_function.html">Глава 4</a>.)</li>
				<li>
					<strong>Не може да се извика с
						<em>new</em>
					</strong> - Стрела функциите нямат [[Construct]] метод и следователно не могат да бъдат използвани, като конструктори. Стрела
					функциите хвърлят грешка ако се използват с
					<em>new</em>.</li>
				<li>
					<strong>Няма прототип </strong> - Тъй като не може да използвате
					<em>new</em> върху стрела функцията, няма нужда от прототип. Свойството
					<em>prototype</em> на стрела функцията не съществува.</li>
				<li>
					<strong>Не може да променя
						<em>this</em>
					</strong> - Стойността на
					<em>this</em> вътре във функцията не може да бъде променяна. Тя остава една и съща през целия жизнен цикъл на функцията.</li>
				<li>
					<strong>Няма
						<em>arguments</em> обект</strong> - Тъй като стрела функциите са без обвързващи
					<em>arguments</em>, трябва да разчитат на имена и останалите параметри за достъп до аргументите на функцията.</li>
				<li>
					<strong>Няма дублиране на имена на параметри</strong> - Стрела функциите не могат да имат дублиращи се имена на параметри в
					<em>strict</em> или
					<em>nonstrict</em> режим, за разлика от
					<em>nonarrow</em> функциите, които не могат да имат дублиращи имена на параметри само в
					<em>strict mode</em>.</li>
				</ul>
		</dl>
		<p>Има няколко причини за тези разлики. На първо място
			<em>this</em> обвързването е общ източник на грешки в JavaScript. Много лесно могат да се загубят следите на
			<em>this</em> стойноста вътре във функция, което може да доведе до нежелано програмно поведение, стрела функциите елиминират
			това объркване. Второ, чрез ограничаване на стрела функциите до просто изпълнение на код с една
			<em>this</em> стойност, JavaScript машината по-лесно ще оптимизира тези операции, за разлика от обикновените функции, които
			могат да се използват, като конструктор или да бъдат модифицирани по някакъв друг начин.</p>
		<p>Останалата част от различията също са насочени към отстраняване на грешки и неясноти във вътрешността на стрела функцията.
			По този начин, JavaScript машината е способна да оптимизира изпълнението на стрела функцията.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Забележка. Стрела функциите също имат
					<em>name</em> свойство, което следва същото правило, както и другите функции.</strong>
			</dd>
		</dl>
		<h3>Синтаксис на стрела функциите</h3>
		<p>Синтаксиса на стрела функциите идва с много нюанси в зависимост от това, което се опитвате да постигнете. Всички промени
			започват с аргументите на функцията, следвани от стрелка, следвана от тялото на функцията. И аргументите и тялото могат
			да приемат различни форми в зависимост от употребата. Например, следната стрела функция приема един аргумент и просто
			го връща:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> reflect = value => value;
<span class="comment"><em>// ефективно еквивалентен на:</em></span>
<span class="code">var</span> reflect = <span class="code">function</span>(value) {
    <span class="code">return</span> value;
};	
		    	</pre>
			</dd>
		</dl>
		<p>Когато има само един аргумент за стрела функцията, той може да се използва директно без допълнителен синтаксис. Стрелата
			идва на следващо място и израза от дясно на стрелата се оценява и връща. Въпреки, че няма изрично
			<em>return</em> изявление, тази стрела функция ще върне първия аргумент, който и е подаден.</p>
		<p>Ако се подадат повече от един аргумент, тогава трябва да се включат скоби около тези аргументи, като това:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> sum = (num1, num2) => num1 + num2;
<span class="comment"><em>// ефективно еквивалентен на:</em></span>
<span class="code">var</span> sum = <span class="code">function</span>(num1, num2) {
    <span class="code">return</span> num1 + num2;
};	
		    	</pre>
			</dd>
		</dl>
		<p>Функцията
			<em>sum()</em> просто добавя два аргумента заедно и връща резултата. Единствената разлика между стрела функцията и
			<em>reflect()</em> функцията е, че аргументите са затворени в скоби с отделяща ги запетая (като традициионите функции).</p>
		<p>Ако няма аргументи на функцията, тогава трябва да се включат празен набор от скоби в декларацията, както следва:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> getName = () => "Nicholas";
<span class="comment"><em>// ефективно еквивалентен на:</em></span>
<span class="code">var</span> getName = <span class="code">function</span>() {
    <span class="code">return</span> "Nicholas";
};	
		    	</pre>
			</dd>
		</dl>
		<p>Когато искате да осигурите едно по-традиционно тяло на функция, може би състоящо се от повече от един израз, тогава трябва
			да увиете тялото на функцията във фигурни скоби и определите изрично
			<em>return</em> за връщане на стойност, както в тази версия на
			<em>sum()</em>:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> sum = (num1, num2) => {
    <span class="code">return</span> num1 + num2;
};
<span class="comment"><em>// ефективно еквивалентен на:</em></span>
<span class="code">var</span> sum = <span class="code">function</span>(num1, num2) {
    <span class="code">return</span> num1 + num2;
};	
		    	</pre>
			</dd>
		</dl>
		<p>Можете повече или по-малко да третирате вътрешността на фигурните скоби, също както бихте направили в традиционна функция
			с изключение на това, че аргументите не са в наличност.</p>
		<p>Ако искате да създадете функция, която не прави нищо, тогава ще трябва да се включат фигурни скоби, като това:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> doNothing = () => {};
<span class="comment"><em>// ефективно еквивалентен на:</em></span>
<span class="code">var</span> doNothing = <span class="code">function</span>() {};
		    	</pre>
			</dd>
		</dl>
		<p>Фигурните скоби се използват за означаване на тялото на функцията, което работи добре в случаите, които сме виждали досега.
			Но ако една стрела функция иска да върне обект извън тялото на функцията, трябва да я увиете в скоби. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> getTempItem = id => ({ id: id, name: "Temp" });
<span class="comment"><em>// ефективно еквивалентен на:</em></span>
<span class="code">var</span> getTempItem = <span class="code">function</span>(id) {
   <span class="code">return</span> {
        id: id,
        name: "Temp"
    };
};
		    	</pre>
			</dd>
		</dl>
		<p>Опаковането на обекта в скоби сигнализира, че скобите са обект вместо тяло на функцията.</p>
		<h3>Създаване на Immediately-Invoked Function Expressions</h3>
		<p>Едно популярно използване на функции в JavaScript е създаване на
			<em>immediately-invoked function expressions</em> (IIFEs). IIFEs ви позволява да дефинирате анонимна функция и да я извикате
			веднага, без да записвате препратка. Този модел е по-удобен, когато искате да създадете обхват, който е защитен от останалата
			част на програмата. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> person = function(name) {
    <span class="code">return</span> {
        getName: <span class="code">function</span>() {
            <span class="code">return</span> name;
        }
    };
}("Nicholas");
console.log(person.getName());      // "Nicholas"
		    	</pre>
			</dd>
		</dl>
		<p>В този код IIFE се използва за създаване на обект с
			<em>getName()</em> метода. Метода използва
			<em>name</em> аргумента, като стойност за връщане, ефективно правейки
			<em>name</em> защитена (
			<em>private</em>) част на върнатия обект.</p>
		<p>Можете да постигнете същото използвайки стрела функция стига да увиете стрела функцията в скоби:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> person = ((name) => {
    <span class="code">return</span> {
        getName: <span class="code">function</span>() {
            <span class="code">return</span> name;
        }
    };
})("Nicholas");
console.log(person.getName());      // "Nicholas"
		    	</pre>
			</dd>
		</dl>
		<p>Имайте в предвид, че скобите са само около дефиницията на стрела функцията, а не около ("Nicholas"). Това е различно от
			нормална функция, където скобите могат да бъдат поставени отвън на подадените параметри, както и само около дефиницията
			на функцията. </p>
		<h3>Не на this обвързването</h3>
		<p>Една от най-общите грешки в JavaScript е обвързването на
			<em>this</em> във вътрешноста на функции. Тъй като стойността на
			<em>this</em> може да се промени във вътрешноста на една функция в зависимост от контекста, с който функцията се извиква,
			е възможно да се отрази по погрешка на един обект, когато е трябвало да повлияе на друг. Да разгледаме следния пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> PageHandler = {
    id: "123456",
    init: <span class="code">function</span>() {
        <span class="code">document</span>.addEventListener("click", <span class="code">function</span>(event) {
            <span class="code">this</span>.doSomething(event.type);     // error
        }, <span class="code">false</span>);
    },
    doSomething: <span class="code">function</span>(type) {
        console.log("Handling " + type  + " for " + <span class="code">this</span>.id);
    }
};
                 </pre>
			</dd>
		</dl>
		<p>В този код, обекта
			<em>PageHandler</em> е проектиран да обработва взаимодействия на страницата. Метода
			<em>init()</em> се извиква да създаде взаимодействие и също определя манипулатор на събитие, който да извика
			<em>this.doSomething()</em>. Въпреки това, този код не работи точно, както е предвидено.</p>
		<p>Извикването на
			<em>this.doSomething()</em> е счупено, защото
			<em>this</em> е препратка към обекта, който е целта на събитието (в този случай
			<em>document</em>) вместо да бъде обвързано с
			<em>PageHandler</em>. Ако сте опитали да пуснете този код, ще получите съобщение за грешка, когато се създаде ефект на манипулатора
			на събитието, защото
			<em>this</em>.
			<em>doSomething()</em> не съществува в целевия
			<em>document</em> обект.</p>
		<p>Може да го оправите, като свържете стойността на
			<em>this</em> с
			<em>PageHandler</em> изрично използвайки
			<em>bind()</em> метод на функцията, както това: </p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> PageHandler = {
    id: "123456",
    init: <span class="code">function</span>() {
        <span class="code">document</span>.addEventListener("click", (<span class="code">function</span>(event) {
            <span class="code">this</span>.doSomething(event.type);     // no error
        }).bind(<span class="code">this</span>), <span class="code">false</span>);
    },
    doSomething: <span class="code">function</span>(type) {
        console.log("Handling " + type  + " for " + <span class="code">this</span>.id);
    }
};	
		     	</pre>
			</dd>
		</dl>
		<p>Сега кодът работи, както се очаква, но изглежда малко странно. С извикването на
			<em>bind(this)</em>, вие всъщност създавате нова функция, чиято
			<em>this</em> се обвързва с текущото
			<em>this</em>, което е
			<em>PageHandler</em>. За да избегнете създаването на допълнителна функция, по добър начин за определяне на този код е да се
			използва функция стрела.</p>
		<p>Стрела функциите нямат
			<em>this</em> обвързване, което означава, че стойността на
			<em>this</em> вътре във функцията стрела може да се определи само, като се потърси нагоре в обхвата на веригата. Ако стрела
			функцията се съдържа в рамките на
			<em>nonarrow</em> функция,
			<em>this</em> ще бъде същия, както в съдържащата функция. В противен случай,
			<em>this</em> е
			<em>undefined</em>. Ето един начин, по който може да напишете този код с помощта на функция стрела:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> PageHandler = {
    id: "123456",
    init: function() {
        <span class="code">document</span>.addEventListener("click",
		event => <span class="code">this</span>.doSomething(event.type), <span class="code">false</span>);
    },
    doSomething: <span class="code">function</span>(type) {
        console.log("Handling " + type  + " for " + <span class="code">this</span>.id);
    }
};		
		     	</pre>
			</dd>
		</dl>
		<p>Манипулатора на събитие в този пример е функцията стрела, която извиква
			<em>this.doSomething()</em>. Стойността на
			<em>this</em> е същата, както в
			<em>init()</em>, така че тази версия на кода работи подобно на използването на
			<em>bind(this)</em>. Въпреки, че метода
			<em>doSomething()</em> не връща стойност, тя все още е единственото изявление изпълнено в тялото на функцията, така че няма
			нужда от включване на фигурни скоби.</p>
		<p>Стрела функциите са проектирани да бъдат за “еднократна употреба”, така че не могат да бъдат ползвани за определяне на
			нови типове. Това е ясно от липсващото
			<em>prototype</em> свойство, което редовните функции имат. Ако се опитате да използвате оператора
			<em>new</em> с функция стрела, ще получите съобщение за грешка, както в този пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> MyType = () => {},
    object = <span class="code">new</span> MyType(); 
<span class="comment"><em>// грешка - не може да използвате стрела функция с new</em></span>	
		     	</pre>
			</dd>
		</dl>
		<p>В този код, поканата за
			<em>new MyType()</em> не успява, защото
			<em>MyType</em> е функция стрела и затова няма [[Construct]] поведение. Знаейки, че стрела функциите не могат да бъдат използвани
			с
			<em>new</em>, позволява на JavaScript машината по нататъшно оптимизиране на поведението им.</p>
		<p>Също така, тъй като стойността на
			<em>this</em> се определя от съдържащата функция, в която стрелата функция е дефинирана, не може да промените стойността на
			<em>tish</em> използвайки
			<em>call(), apply()</em> или
			<em>bind()</em>.</p>
		<h3>Стрела функции и <em>arrays</em></h3>
		<p>Краткия синтаксис на функциите стрела ги прави идеални за използване при обработка на <em>arrays</em>. Например, ако искате да сортирате
			<em>array</em>, използвайки потребителско сравнение, може би бихте написали нещо такова:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> result = values.sort(<span class="code">function</span>(a, b) {
    <span class="code">return</span> a - b;
});
		     	</pre>
			</dd>
		</dl>
		<p>Това е много синтаксис за една проста процедура. Сравнете това с по-изразителната версия на стрела функция:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> result = values.sort((a, b) => a - b);		     		
		     	</pre>
			</dd>
		</dl>
		<p>Методите на <em>array</em>, които приемат функции за обратно извикване, като
			<em>sort(), map()</em> и
			<em>reduce()</em> могат да се възползват от по-простия синтаксис на стрела функцията, която променя привидно сложни процеси
			в по-прост код.</p>
		<h3>Нямат обвързващи аргументи</h3>
		<p>Макар, че стрела функциите не разполагат със собствен
			<em>arguments</em> обект, е възможно да имат достъп до
			<em>arguments</em> обекта от съдържащата функция. Този
			<em>arguments</em> обект след това е на разположение, без значение къде се изпълнява функцията стрела по-късно. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> createArrowFunctionReturningFirstArg() {
    <span class="code">return</span> () => arguments[0];
}
<span class="code">var</span> arrowFunction = createArrowFunctionReturningFirstArg(5);
console.log(arrowFunction());       // 5
		     	</pre>
			</dd>
		</dl>
		<p>Вътре в
			<em>createArrowFunctionReturningFirstArg()</em>, елемента
			<em>arguments[0]</em> е посочен от създадената функция стрела. Тази препратка съдържа първият аргумент подаден на
			<em>createArrowFunctionReturningFirstArg()</em> функцията. Когато се изпълни стрела функцията по-късно тя връща 5, който е
			първият аргумент подаден на
			<em>createArrowFunctionReturningFirstArg()</em>. Въпреки, че функцията стрела не е в обхвата на функцията, която я е създала,
			<em>arguments</em> остава достъпен поради разрешения обхват на веригата на
			<em>arguments</em> идентификатора.</p>
		<h3>Идентифициране на функции стрели</h3>
		<p>Въпреки различния синтаксис, функциите стрели са все още функции и са обозначени, като такива. Да разгледаме следния код:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> comparator = (a, b) => a - b;
console.log(<span class="code">typeof</span> comparator);                 // "function"
console.log(comparator <span class="code">instanceof Function</span>);    // true	
		     	</pre>
			</dd>
		</dl>
		<p>На изхода
			<em>console.log()</em> показва, че
			<em>typeof</em> и
			<em>instanceof</em> се държат по същия начин с функциите стрели, както го правят с други функции.</p>
		<p>Също, както другите функции, може да използвате
			<em>call(), apply()</em> и
			<em>bind()</em> върху стрела функциите въпреки, че
			<em>this</em> обвързването на функцията няма да бъде засегнато. Ето някои примери:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">var</span> sum = (num1, num2) => num1 + num2;
console.log(sum.call(<span class="code">null</span>, 1, 2));      // 3
console.log(sum.apply(<span class="code">null</span>, [1, 2]));   // 3
<span class="code">var</span> boundSum = sum.bind(<span class="code">null</span>, 1, 2);
console.log(boundSum());                // 3
		     	</pre>
			</dd>
		</dl>
		<p>Функцията
			<em>sum()</em> се извиква използвайки
			<em>call()</em> и
			<em>apply()</em> за подаване на аргументи, както бихме направили с всяка функция. Метода
			<em>bind()</em> се използва за създаване на
			<em>boundSum()</em>, който разполага с два свои аргумента, свързани с 1 и 2 , така че те не трябва да се подават директно.</p>
		<p>Стрела функциите са подходящи за използване на всякъде, където в момента се използват анонимни функционални изрази, като
			например с обратно извикване. Следващия раздел обхваща друг основен аспект на развитие в ECMAScript 6, но всичко е вътрешно
			и не разполага с нов синтаксис.</p>
		<h3>Оптимизацията Tail Call</h3>
		<p>Може би най-интересната промяна на функциите в ECMAScript 6 е оптимизация на двигателя, който променя системата на
			<em>tail call</em>.
			<em>Tail call</em> е, когато дадена функция се извиква, като последно изявление в друга функция, като тази:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> doSomething() {
    <span class="code">return</span> doSomethingElse();   // tail call
}
		     	</pre>
			</dd>
		</dl>
		<p>
			<em>Tail calls</em>, от както е въведена в ECMAScript 5 се обработва, както всяка друга извикана функция: създава се нова
			стек рамка и се вкарва в стека за извикване, за да представлява извиканата функция. Това означава, че всяка предишна стек
			рамка се запазва в паметта, което е проблемно, когато стека за извикване стане твърде голям.</p>
		<h3>Какво е различното?</h3>
		<p>ECMAScript 6 има за цел да намали размера на стека за определени
			<em>tail calls</em> в
			<em>strict mode</em> (в
			<em>nonstrict mode tail calls</em> са оставени непроменени). С тази промяна вместо да създаде нова стек рамка за
			<em>tail call</em>, текущата стек рамка се изчиства и се използва повторно толкова дълго, колкото са изпълнени следните условия:</p>
		<dl>
			<dd>
				<strong>
					<ol>
						<li>Повикването на
							<em>tail call</em> не изисква достъп до променливите в текущата стек рамка (което означава, че функцията не е закриваща).</li>
						<li>Функцията правеща
							<em>tail call</em> няма допълнителна работа за вършене след връщането на
							<em>tail call</em>.</li>
						<li>Резултата от
							<em>tail call</em> се връща, като стойност на функцията.</li>
					</ol>
				</strong>
			</dd>
		</dl>
		<p>Като пример този код може лесно да бъде оптимизиран, тъй като се вписва във всичките три критерия:</p>
		<dl>
			<dd>
				<pre class="highlight">
"use strict";
<span class="code">function</span> doSomething() {
    // optimized
    <span class="code">return</span> doSomethingElse();
}
		     	</pre>
			</dd>
		</dl>
		<p>Тази функция прави
			<em>tail call</em> към
			<em>doSomethingElse()</em>, връща резултата незабавно и няма достъп до променливите в местния обхват. Една малка промяна,
			не връща резултат и води до неоптимизирана функция:</p>
		<dl>
			<dd>
				<pre class="highlight">
"use strict";
<span class="code">function</span> doSomething() {
    <span class="comment"><em>// не оптимизирана- няма return</em></span>
    doSomethingElse();
}	     		
		     	</pre>
			</dd>
		</dl>
		<p>По същия начин, ако имате функция, която изпълнява една операция след завръщането си от
			<em>tail call</em>, тя след това не може да бъде оптимизирана:</p>
		<dl>
			<dd>
				<pre class="highlight">
"use strict";
<span class="code">function</span> doSomething() {
  <span class="comment"><em>// не оптимизирана - трябва да се добави след завръщането</em></span>
    <span class="code">return</span> 1 + doSomethingElse();
}
</pre>
			</dd>
		</dl>
		<p>Този пример добавя 1 към резултата на
			<em>doSomethingElse()</em> преди да се върне стойността и това е достатъчно за да се изключи оптимизацията.</p>
		<p>Друг често срещан начин за невнимателно изключване на оптимизацията е да се съхранява резултата от извикването на функцията
			в променлива и след това да се върне променливата на резултата, като този пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
"use strict";
<span class="code">function</span> doSomething() {
     <span class="comment"><em>// не оптимизирана- извикването не е в tail позиция</em></span>
    var result = doSomethingElse();
    return result;
}	
		     	</pre>
			</dd>
		</dl>
		<p>Този пример не може да бъде оптимизиран, тъй като стойността на
			<em>doSomethingElse()</em> не се връща незабавно.</p>
		<p>Може би най-трудната ситуация е да се избегне в използването на закриване. Понеже закриването има достъп до променливите
			в съдържащия обхват,
			<em>tail call</em> може да бъде изключен. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
"use strict";
<span class="code">function</span> doSomething() {
    <span class="code">var</span> num = 1,
        func = () => num;
    <span class="comment"><em>// не оптимизирана - функцията е закриваща</em></span>
    <span class="code">return</span> func();
}
		     	</pre>
			</dd>
		</dl>
		<p>Закриващата
			<em>func()</em> има достъп до локалната променлива
			<em>num</em> в този пример. Въпреки, че извикването към
			<em>func()</em> незабавно връща резултата, оптимизацията не може да се дължи на отнасяне към променливата
			<em>num</em>.</p>
		<h3>Как да впрегнем оптимизацията Tail Call</h3>
		<p>На практика,
			<em>tail call</em> оптимизацията се случва зад кулисите, така че не трябва да се мисли затова освен, ако не се опитвате да
			оптимизирате функция. Случаите за употреба на
			<em>tail call</em> оптимизация е в рекурсивни функции, тъй като това е мястото, където оптимизацията има най-голям ефект.
			Помислете за тази функция, която изчислява факториал:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> factorial(n) {
    <span class="code">if</span> (n <= 1) {
        <span class="code">return</span> 1;
    } <span class="code">else</span> {
    <span class="comment"><em>// не оптимизирана - трябва да се умножават след завръщането</em></span>
        <span class="code">return</span> n * factorial(n - 1);
    }
}
		     	</pre>
			</dd>
		</dl>
		<p>Тази версия на функция не може да бъде оптимизирана, защото умножението трябва да се случи след рекурсивното извикване
			на
			<em>factorial()</em>. Ако
			<em>n</em> е много голям номер, размера на стека за извикване ще расте и може потенциално да доведе до препълване на стека.</p>
		<p>С цел оптимизиране на функцията, трябва да се гарантира, че умножението не се случва след извикването на последната функция.
			За да направим това, можем да използваме
			<em>default</em> параметър и да преместим операцията за умножение извън
			<em>return</em> изявлението. Получената функция носи временен резултат в следващата итерация на създадената на функция, която
			работи по същия начин, но може да бъде оптимизирана от ECMAScript 6 машината. Ето новия код:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> factorial(n, p = 1) {
    <span class="code">if</span> (n <= 1) {
        <span class="code">return</span> 1 * p;
    } <span class="code">else</span> {
        <span class="code">let</span> result = n * p;
        <span class="comment"><em>// оптимизирана</em></span>
        <span class="code">return</span> factorial(n - 1, result);
    }
}
                  </pre>
			</dd>
		</dl>
		<p>В тази пренаписана версия на
			<em>factorial()</em>, вторият аргумент
			<em>p</em> е добавен, като параметър с
			<em>default</em> стойност 1. Параметъра
			<em>p</em> държи предишния резултат от умножението, така че следващия резултат може да бъде изчислен, без друга извикваща
			функция. Когато
			<em>n</em> е по-голямо от 1, се извършва първо умножението и след това се подава, като втори аргумент на
			<em>factorial()</em>. Това позволява на ECMAScript 6 машината да оптимизира рекурсивните извиквания.</p>
		<p>
			<em>Tail call</em> оптимизацията е нещо, за което трябва да се мисли, когато пишете рекурсивни функции, тъй като тя може да
			осигури значително подобрение в производителноста, особено когато се прилага в изчисляването на по-скъпа функция. </p>
	</article>
	<footer>
		<h3>Обобщение</h3>
		<p>Функциите не са претърпели огромна промяна в ECMAScript 6, а по-скоро серия от постепенни промени, които ги правят по-лесни
			за работа.</p>
		<p>
			<em>Default</em> параметрите на функции ви позволяват лесно да уточните, каква стойност да се използва, когато не е подаден
			аргумент. Преди ECMAScript 6, това щеше да изисква допълнителен код във вътрешността на функцията, който да провери за
			наличието на аргументи и да зададе друга стойност.</p>
		<p>
			<em>Rest</em> параметрите позволяват да определите <em>array</em>, в който да се поставят всички останали параметри. Използвайки реален
			<em>array</em>, който ви позволява да посочите кои параметри да се включат, прави
			<em>rest</em> параметрите много по-гъвкаво решение от
			<em>arguments</em>.</p>
		<p>Оператора
			<em>spread</em> е спътник на
			<em>rest</em> параметрите, който ви позволява да пренаредите <em>array</em> на отделни параметри при извикване на функция. Преди ECMAScript
			6, имаше само два начина за подаване на индивидуални параметри съдържащи се в <em>array</em>: чрез ръчно уточняване или използвайки
			<em>apply()</em>. С оператора
			<em>spread</em> можете лесно да подадете <em>array</em> на всяка функция, без да се притеснявате за
			<em>this</em> обвързването на функцията.</p>
		<p>Добавянето на
			<em>name</em> свойство ще ви помогне за по-лесно идентифициране на функции с цел на отстраняване на грешки и оценка. Освен
			това, ECMAScript 6 официално определя поведението на блокови функции, така че те вече не са синтактична грешка в строг
			режим.</p>
		<p>В ECMAScript 6, поведението на една функция се определя от [[Call]] при нормално изпълнение на функция и [[Construct]],
			когато една функция се извиква с
			<em>new</em>.
			<em>The new.target metaproperty</em> ви позволява да определите дали дадена функция се извиква с
			<em>new</em> или не.</p>
		<p>Най-голямата промяна на функциите в ECMAScript 6 е добавянето на стрели функции. Стрели функциите са предназначени за използване
			вместо анонимните функционални изрази. Функциите стрели имат по-кратък синтаксис, лексикално
			<em>this</em> обвързване и нямат
			<em>arguments</em> обект. Освен това функциите стрели не могат да променят своето
			<em>this</em> обвързване и така не могат да се използват, като конструктори.</p>
		<p>
			<em>Tail call</em> оптимизацията позволява някои извикани функции да бъдат оптимизирани, за да се запази по-малък стека на
			извикване, използвайки по-малко памет и предотвратяване на грешки от препълване на стека. Тази оптимизация се прилага
			автоматично, разбира се когато това е безопасно да се направи, ако решите можете да пренапишете рекурсивни функции, за
			да се възползвате от тази оптимизация.</p>
	</footer>
	<nav>
		<a href="./02_strings.html" title="previous chapter">◀</a>
		<a href="./index.html" title="cover">◆</a>
		<a href="./04_object_function.html" title="next chapter">▶</a>
	</nav>
</body>

</html>