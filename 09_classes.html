<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Класове :: Understanding ECMAScript 6</title>
	<link rel="stylesheet" href="font.css">
</head>

<body>
	<nav>
		<a href="08_iterators_and_generators.html" title="previous chapter">◀</a>
		<a href="./index.html" title="cover">◆</a>
		<a href="10_array.html" title="next chapter">▶</a>
	</nav>

	<header id="header" class="">
		<h1>
			<div class="head-num">Глава 9</div>Въвеждане на Класове в JavaScript</h1>
		<p>За разлика от повечето официални обектно-ориентирани езици за програмиране, JavaScript още от както е бил създаден, не
			подкрепя класове и класическо наследяване, като основен начин на дефиниране подобни и свързани обекти. Това създава объркване
			в програмистите и още от ECMAScript 1 през целия път до ECMAScript 5, тази точка на объркване доведе до създаване на много
			библиотеки с програми, предназначени да направят JavaScript да изглежда, като че поддържа класове. Макар, че има някои
			JavaScript програмисти, които твърдят, че езика не се нуждае от класове, фактът, че толкова много библиотеки са създадени
			специално за тази цел, доведе до включването на класовете в ECMAScript 6.</p>
		<p>Докато изследваме ECMAScript 6 класовете, е полезно да се разберат основните механизми, които използват класове, така че
			тази глава започва с обсъждане на това как ECMAScript 5 програмистите постигат клас-поведение. Както ще видите обаче,
			в ECMAScript 6 класовете не са точно същите, както класовете на другите езици. Има една уникалност във тях, която обхваща
			динамичния характер на JavaScript.</p>
	</header>
	<!-- /header -->
	<article>
		<h3>Подобни на класове структури в ECMAScript 5</h3>
		<p> В ECMAScript 5 и по рано, не е имало класове, най-близкият еквивалент е създаването на конструктор и след това възлагане
			на методи на неговия прототип, този подход обикновено се нарича създаване на потребителски тип. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> PersonType(name) {
    <span class="code">this</span>.name = name; 
}
 PersonType.prototype.sayName = <span class="code">function</span>() { 
    console.log(<span class="code">this</span>.name); 
};

<span class="code">let</span> person = <span class="code">new</span> PersonType("Nicholas");
    person.sayName(); // outputs "Nicholas"

console.log(person <span class="code">instanceof</span> PersonType); // true
console.log(person <span class="code">instanceof Object</span>);    // true
</pre>
			</dd>
		</dl>
		<p>В този код,
			<em>PersonType</em> е функция конструктор, която създава едно свойство наречено
			<em>name</em>. Метода
			<em>sayName()</em> се възлага на прототипа, така същата функция се споделя от всички случаи на прототипа на
			<em>PersonType</em> обекта. След това, се създава нова инстанция на
			<em>PersonType</em> с помощта на оператора
			<em>new</em>. Полученият
			<em>person</em> обект се счита за инстанция на
			<em>PersonType</em> и на
			<em>Object</em> чрез прототипното наследяване.</p>
		<p>Същият основен модел е в основата на много от имитиращите класове библиотеки в JavaScript и това е до началото на класовете
			в ECMAScript 6.</p>
		<h3>Декларации на класове</h3>
		<p> Декларациите на класове започват с ключовата дума
			<em>class</em>, последвана от името на класа. Останалата част от синтаксиса изглежда подобно на кратките методи за обект без
			да се изисква запетая между тях. Например, това е една проста декларация на клас:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">class</span> PersonClass {

<span class="comment"><em>// еквивалентно на конструктора PersonType</em>
    </span> constructor(name) {
        <span class="code">this</span>.name = name;
	}

    <span class="comment"><em>// еквивалентно на PersonType.prototype.sayName</em>
    </span> sayName() { 
	    console.log(<span class="code">this</span>.name);
	} 
}

<span class="code">let</span> person = <span class="code">new</span> PersonClass("Nicholas"); 
person.sayName();     // outputs "Nicholas" 
	
console.log(person <span class="code">instanceof</span> PersonClass);    // true 
console.log(person <span class="code">instanceof Object</span>);         // true 

console.log(<span class="code">typeof</span> PersonClass);                     // "function" 
console.log(<span class="code">typeof</span> PersonClass.prototype.sayName);   // "function"
				</pre>
			</dd>
		</dl>
		<p>Декларацията на класа
			<em>PersonClass</em> се държи доста подобно на
			<em>PersonType</em> от предишния пример. Вместо да дефинира функция, като конструктор, декларацията на класа ви позволява
			да определите конструктора директно в класа, използвайки метод наречен
			<em>constructor</em>. Тъй като, методите на класа използват краткия синтаксис, няма нужда да се използва ключовата дума
			<em>function</em>. Всички други имена на методи са без особено значение, така че може да добавите толкова методи, колкото
			искате.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Собствените свойства, са свойства, които се случват само в инстанцията, а не в прототипа и могат да се създават само
					вътре в клас конструктор или метод. В предишния пример,
					<em>name</em> е собствено свойство. Препоръчително е да се създадат всички възможни собствени свойства в рамките на функцията
					конструктор, така че да има едно единствено място, което е отговорно за всички тях.</strong>
			</dd>
		</dl>
		<p>Интересен аспект на декларациите на класове е, че те са само
			<em>syntactic sugar</em> на върха на съществуващите потребителски типoве декларации. Декларацията на
			<em>PersonClass</em> всъщност създава функция, която има поведението на
			<em>constructor</em> метода, поради което
			<em>typeof PersonClass</em> е "function". По същия начин, метода
			<em>sayName()</em> завършва, като метод на
			<em>PersonClass.prototype</em>. Този пример е подобен на връзката между
			<em>sayName()</em> и
			<em>PersonType.prototype</em> в предишния пример. Тези сходства ви позволяват да смесвате потребителски типове и класове без
			да се притеснявате твърде много за какво ги използвате.</p>
		<h3>Защо да използваме клас синтаксис</h3>
		<p>Въпреки приликите има няколко важни разлики между класове и потребителски типове, които трябва да имате в предвид:</p>
		<dl>
			<dd>
				<ol>
					<li>Клас декларациите, за разлика от декларациите на функции, не се издигат. Декларациите на класове действат, като
						<em>let</em> декларации и така съществуват в темпоралната мъртва зона, докато изпълнението не достигне декларацията.</li>
					<li>Целия код вътре в клас декларацията, минава в
						<em>strict mode</em> автоматично. Няма начин да се откажете от
						<em>strict mode</em> вътре в класовете.</li>
					<li>Всички методи са
						<em>non-enumerable</em>. Това е значителна промяна от потребителските типове, където трябва да използвате
						<em>Object.defineProperty()</em> за да направите методите
						<em>non-enumerable</em>.</li>
					<li>Всички методи нямат вътрешен метод [[Construct]] и така хвърлят грешка ако опитате да ги извикате с
						<em>new</em>.</li>
					<li>Извикването на клас конструктора без
						<em>new</em> хвърля грешка</li>
					<li>Опита да замените името на класа в рамките на клас метода хвърля грешка.</li>
				</ol>
			</dd>
		</dl>
		<p>С всичко това в предвид, декларацията на
			<em>PersonClass</em> от предишния пример е директно еквивалентна на следния код, който не използва синтаксиса за клас:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="comment"><em>// директен еквивалент на PersonClass</em></span>
<span class="code">let</span> PersonType2 = (<span class="code">function</span>() {
  "use strict";

  <span class="code">const</span> PersonType2 = <span class="code">function</span>(name) {

    <span class="comment"><em>// уверете се, че функцията се извиква с new</em></span>
    <span class="code">if</span> (<span class="code">typeof new</span>.target === "undefined") {
        <span class="code">throw new Error</span>("Constructor must be called with new."); 
  }

  <span class="code">this</span>.name = name; 
}

<span class="code">Object</span>.defineProperty(PersonType2.prototype, "sayName", {
  value: <span class="code">function</span>(){

      <span class="comment"><em>// уверете се, че метода не се извиква с new</em></span>
      <span class="code">if</span> (<span class="code">typeof new</span>.target !== "undefined") {
        <span class="code">throw new Error</span>("Method cannot be called with new.");  
      } 
       console.log(<span class="code">this</span>.name); 	
    }, 
    enumerable: <span class="code">false</span>,
    writable: <span class="code">true</span>,
    configurable: <span class="code">true</span> 
  });

    <span class="code">return</span> PersonType2; 
}());
				</pre>
			</dd>
		</dl>
		<p>Първото нещо, което се забелязва в този код е, че има две декларации на
			<em>PersonType2</em>:
			<em>let</em> декларацията във външния обхват и
			<em>const</em> декларацията вътре в IIFE. Това е начина, по който методите на класа са защитени от презаписване на името на
			класа, докато на кода от вън е позволено да го направи. Функцията конструктор се проверява от
			<em>new.target</em> за да се гарантира, че тя се извиква с
			<em>new</em>, в противен случай се хвърля грешка. На следващо място
			<em>sayName()</em> метода се определя на
			<em>non-enumerable</em> и също така се проверява от
			<em>new.target</em> за да се гарантира, че не се извиква с
			<em>new</em>. Последната стъпка е да се върне функцията конструктор.</p>
		<p>От този пример може да видите, че е възможно да се направи всичко, което класовете правят без да се използва нов синтаксис,
			но синтаксиса на класа опростява цялата функционалност значително.</p>
		<div class="aside">
			<h3>Постоянни имена на класове</h3>
			<p>Името на класа се указва с използването на
				<em>const</em>, но само в рамките на самия клас. Това означава, че можете да замените името на класа извън този клас, но
				не и вътре в метода на класа. Например:</p>
			<pre class="highlight">
<span class="code">class</span> Foo {
  constructor() { 
    Foo = "bar";  <span class="comment"><em>// хвърля грешка ако бъде изпълнено</em></span>				
  } 
}

<span class="comment"><em>// но това е добре</em>
</span> Foo = "baz";
			</pre>
			<p>В този код,
				<em>Foo</em> вътре в конструктора е с отделно обвързване от
				<em>Foo</em> извън класа. Вътрешния
				<em>Foo</em> се определя, все едно, че е
				<em>const</em> декларация и така не може да бъде презаписан. Ще бъде хвърлена грешка, ако конструктора се опита да замени
				<em>Foo</em> с някаква стойност. Външния
				<em>Foo</em> се определя, все едно, че е
				<em>let</em> декларация и така неговата стойност може да бъде презаписана по всяко време.</p>
		</div>
		<h3>Клас изрази</h3>
		<p>Класове и функции са сходни по това, че те имат две форми: декларации и изрази. Декларацията на функции и класове започва
			с подходяща дума (
			<em>function</em> или
			<em>class</em> съответно) последвана от идентификатор. Функциите имат израз форма, която не изисква идентификатор след
			<em>function</em> и по същия начин, класовете имат израз форма, която не изисква идентификатор след
			<em>class</em>. Тези
			<em>class expressions</em> са предназначени да бъдат използвани в декларации на променливи или подаване към функции, като
			аргументи.</p>
		<h4>A Basic Class Expression</h4>
		<p>Ето един клас израз еквивалент на предишните
			<em>PersonClass</em> примери, последван от някакъв код, който го използва:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> PersonClass = <span class="code">class</span> {

    <span class="comment"><em>// еквивалентно на PersonType конструктора</em></span>
    constructor(name) {
       <span class="code">this</span>.name = name;
    }

    <span class="comment"><em>// еквивалентно на PersonType.prototype.sayName</em></span> 
    sayName() { 
       console.log(<span class="code">this</span>.name);
    } 
};

<span class="code">let</span> person = <span class="code">new</span> PersonClass("Nicholas");
person.sayName();     // outputs "Nicholas" 
 
console.log(person <span class="code">instanceof</span> PersonClass);    // true 
console.log(person <span class="code">instanceof Object</span>);         // true 
 
console.log(<span class="code">typeof</span> PersonClass);         // "function" 
console.log(<span class="code">typeof</span> PersonClass.prototype.sayName);//"function"
				</pre>
			</dd>
		</dl>
		<p>Този пример показва, че клас изразите не изискват идентификатор след
			<em>class</em>. Освен синтаксиса, клас изразите са абсолютно равностойни на декларациите на класове</p>
		<p>В анонимни клас изрази, както в предишния пример,
			<em>PersonClass.name</em> е празен
			<em>string</em>. При използване на декларация на клас,
			<em>PersonClass.name</em> ще бъде "PersonClass".</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Използването на декларации за класове или клас изрази е най-вече въпрос на стил. За разлика от декларациите за функции
					и функционални изрази, декларациите на клас и клас изрази не се издигат, така избора няма голямо влияние върху поведението
					по време на изпълнение на кода. Единствената съществена разлика е, че анонимни клас изрази имат
					<em>name</em> свойство, което е празен
					<em>string</em>, докато декларации на класа винаги имат
					<em>name</em> свойство равно на името на класа (например,
					<em>PersonClass.name</em> е "PersonClass", когато се използва при декларация на клас).</strong>
			</dd>
		</dl>
		<h3>Именуване на клас израз</h3>
		<p>В предния раздел използва анонимен клас израз в примера, но можете също да дадете имена на клас изрази, точно както можете
			да дадете имена на функционални изрази. За да направите това, трябва да включите идентификатор след ключовата дума
			<em>class</em>, по този начин:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> PersonClass = <span   class="code">class</span> PersonClass2 {

   <span class="comment"><em>// еквивалентно на PersonType конструктора</em></span> 
   constructor(name) {
	<span class="code">this</span>.name = name; 
   }

   <span class="comment"><em>// еквивалентно на PersonType.prototype.sayName</em></span> 
   sayName() { 
	   console.log(<span class="code">this</span>.name); 
   } 
}; 

console.log(<span class="code">typeof</span> PersonClass); // "function" 
console.log(<span class="code">typeof</span> PersonClass2); // "undefined"
				</pre>
			</dd>
		</dl>
		<p>В този пример, на клас израза се дава име:
			<em>PersonClass2</em>. Идентификатора
			<em>PersonClass2</em> съществува само в рамката на дефиницията на класа, така че може да се използва вътре от методите на
			класа (като
			<em>sayName()</em>). Извън този клас,
			<em>typeof PersonClass2</em> е "undefined", защто
			<em>PersonClass2</em> не съществува там. За да разберете, защо се случва това, погледнете еквивалентната декларация, която
			не използва класове:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="comment"><em>// директен еквивалент на PersonClass име на клас израз</em></span>
<span class="code">let</span> PersonClass = (<span class="code">function</span>() { 
   "use strict";

   <span class="code">const</span> PersonClass2 = <span class="code">function</span>(name) {

    <span class="comment"><em>// уверете се, че функцията се извиква с new</em></span>
    <span class="code">if</span> (<span class="code">typeof new</span>.target === "undefined") {
       <span class="code">throw new Error</span>("Constructor must be called with new.");
    }

   <span class="code">this</span>.name = name;
  }

  <span class="code">Object</span>.defineProperty(PersonClass2.prototype, "sayName", { 
     value: <span class="code">function</span>() { 
     <span class="comment"><em>// уверете се, че функцията се извиква с new</em></span>
     <span class="code">if</span> (<span class="code">typeof new</span>.target !=== "undefined") {
	<span class="code">throw new Error</span>("Method must be called with new.");
     }
     console.log(<span class="code">this</span>.name); 
   }, 
   enumerable: <span class="code">false</span>, 
   writable: <span class="code">true</span>,
   configurable: <span class="code">true</span> 
  });

  <span class="code">return</span> PersonClass2; 
}());
				</pre>
			</dd>
		</dl>
		<p>Създаване на клас израз с име леко променя това, което се случва в JavaScript машината. За декларация на клас, външното
			обвързване (дефинирано с
			<em>let</em>) има същото име, като вътрешното обвързване (дефинирано с
			<em>const</em>). Клас изразите използват името си, като
			<em>const</em> дефиниция, така че в този случай
			<em>PersonClass2</em> е определен за употреба само в рамките на класа.</p>
		<p>Докато поведението на клас изрази е различно от това на функционалнте изрази, все още има много прилики между двете. И
			двете могат да се използват, като стойности, което отваря много възможности.</p>
		<h3>Класовете, като First-Class Citizens</h3>
		<p>В програмирането, се казва за нещо, че е
			<em>first-class citizen</em>, когато то може да се използва, като стойност, което означава, че може да бъде прехвърлено във
			функция, върнато от функция и присвоено от променлива. В JavaScript функциите са
			<em>first-class citizen</em> (понякога наричани само първокласни функции) и това е само част от това, което прави JavaScript
			уникален език.</p>
		<p>ECMAScript 6 продължава тази традиция, като прави класовете
			<em>first-class citizen</em>. Това позволява класовете да бъдат използвани по много различни начини. Например, те могат да
			бъдат вкарани във функции, като аргументи:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> createObject(classDef) {
    <span class="code">return new</span> classDef(); 
}

<span class="code">let</span> obj = createObject(<span class="code">class</span> { 
   sayHi() { 
     console.log("Hi!"); 
   } 
});
obj.sayHi();     // "Hi!"
				</pre>
			</dd>
		</dl>
		<p>В този пример, функцията
			<em>createObject()</em> се извиква с анонимен клас израз, като аргумент, създава инстанция на този клас с
			<em>new</em> и връща инстанция. Променливата
			<em>obj</em> след това съхранява върнатата инстанция.</p>
		<p>Друго интересно приложение на клас изрази е да създават
			<em>singletons</em>, като незабавно се позовават на клас конструктора. За да направите това, трябва да използвате
			<em>new</em> с израза на класа и да включите скоби на края. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> person = <span class="code">new class</span> PersonClass {
   constructor(name) {
      <span class="code">this</span>.name = name; 
   } 
   sayName() { 
      console.log(<span class="code">this</span>.name); 
   } 

}("Nicholas");

person.sayName(); // "Nicholas"
				</pre>
			</dd>
		</dl>
		<p>Тука, анонимния клас израз се създава и след това се изпълнява незабавно. Този модел позволява използването на синтаксиса
			на класа за създаване на
			<em>singletons</em> без да излизате от препратката на класа за проверка (не забравяйте, че
			<em>PersonClass</em> създава обвързване вътре в класа, не отвън). Скобите в края са индикатор за извикването на функцията
			и също така позволяват подаване на аргумент.</p>
		<p>Примерите в тази глава са фокусирани, доколкото може, върху класове с методи. Но можете да създадете
			<em>accessor</em> свойства на класове със синтаксис подобен за обект.</p>
		<h3>Accessor свойства</h3>
		<p>Докато собствените свойства трябва да бъдат създадени в клас конструктора, класовете ви позволяват за определите
			<em>accessor</em> свойства на прототипа. За създаване на
			<em>getter</em>, трябва да изпозвате ключовата дума
			<em>get</em> последвана от интервал, последван от идентификатор. За създаване на
			<em>setter</em>, трябва да използвате ключовата дума
			<em>set</em>. Например:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">class</span> CustomHTMLElement { 
    constructor(element) {
        <span class="code">this</span>.element = element; 
    } 

    get html() {
        <span class="code">return this</span>.element.innerHTML; 
    } 
	
    set html(value) {
        <span class="code">this</span>.element.innerHTML = value; 
    }
}

<span class="code">var</span> descriptor = <span class="code">Object</span>.getOwnPropertyDescriptor(CustomHTMLElement.prototype, "html"); 

console.log("get" <span class="code">in</span> descriptor); // true
console.log("set" <span class="code">in</span> descriptor); // true 
console.log(descriptor.enumerable); // false
				</pre>
			</dd>
		</dl>
		<p>В този пример, класа
			<em>CustomHTMLElement</em> прави обвивка около съществуващ DOM елемент. Той има
			<em>getter</em> и
			<em>setter</em> за
			<em>html</em>, като делегати на
			<em>innerHTML</em> метода на самия елемент. Това
			<em>accessor</em> свойство се създава, като
			<em>non-enumerable</em>, точно както всеки друг метод ще бъде създаден в
			<em>CustomHTMLElement.prototype</em>. Еквивалент на предишния пример с
			<em>non-class</em> ще бъде представен, като:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="comment"><em>// директен еквивалент на предишния пример</em></span>
<span class="code">let</span> CustomHTMLElement = (<span class="code">function</span>() {
    "use strict";

    <span class="code">const</span> CustomHTMLElement = <span class="code">function</span>(element) {

      <span class="comment"><em>// уверете се, че функцията се извиква с new</em></span>
      <span class="code">if</span> (<span class="code">typeof new</span>.target === "undefined") {
        <span class="code">throw new Error</span>("Constructor must be called with new.");
      }

      <span class="code">this</span>.element = element; 
  }

  <span class="code">Object</span>.defineProperty(CustomHTMLElement.prototype, "html", { 
    enumerable: <span class="code">false</span>,
    configurable: <span class="code">true</span>, 
    get: <span class="code">function</span>() {
      <span class="code">return this</span>.element.innerHTML; 
    },
    set: function(value) {
      <span class="code">this</span>.element.innerHTML = value; 
    } 
  });

  <span class="code">return</span> CustomHTMLElement; 
}());
				</pre>
			</dd>
		</dl>
		<p>Както при предишните примери, това показва колко много код се спести чрез използване на класове вместо еквиваленти на
			<em>non-class</em>. Дефинирането само на
			<em>html</em> свойството за достъп е почти с размера на еквивалента на декларацията на класа.</p>
		<h3>Изчисляване на имена</h3>
		<p>Клас методите и
			<em>accessor</em> свойствата могат да имат изчислени имена. Вместо използването на идентификатор, можем да използваме квадратни
			скоби около израза, което е същия синтаксис, както за изчислените имена на обект. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> methodName = "sayName";

<span class="code">class</span> PersonClass {  
    constructor(name) {
      <span class="code">this</span>.name = name; 
    } 
    [methodName]() { 
      console.log(<span class="code">this</span>.name); 
    } 
};

<span class="code">let</span> me = <span class="code">new</span> PersonClass("Nicholas"); 
me.sayName();    // "Nicholas"
				</pre>
			</dd>
		</dl>
		<p>Тази версия на
			<em>PersonClass</em> използва променлива да зададе името на метода вътре в своята дефиниция.
			<em>String</em> "sayName" се възлага на променливата
			<em>methodName</em> и след това
			<em>methodName</em> се използва за деклариране на метода. Метода
			<em>sayName()</em> по късно се достъпва директно.</p>
		<p>
			<em>Accessor</em> свойствата могат да използват изчислени имена по същия начин, като този:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> propertyName = "html";

<span class="code">class</span> CustomHTMLElement {
    constructor(element) {
      <span class="code">this</span>.element = element; 
    } 

    get [propertyName]() {
      <span class="code">return this</span>.element.innerHTML; 
    } 
	
    set [propertyName](value) {
      <span class="code">this</span>.element.innerHTML = value; 
    }
}
				</pre>
			</dd>
		</dl>
		<p>Тука
			<em>getter</em> и
			<em>setter</em> за
			<em>html</em> са определени с помощта на променливата
			<em>propertyName</em>. Mожете да получите достъп до свойството с помощта на
			<em>.html</em>, което засяга само определението.</p>
		<p>Видяхте, че има много прилики между класове и обекти за методи,
			<em>accessor</em> свойства и изчисляване на имена. Има още една прилика за покриване: генератори.</p>
		<h3>Генератор методи</h3>
		<p>Когато въведохме генератори в
			<a href="08_iterators_and_generators.html">Глава 8</a>, вие научихте как да дефинирате генератор на даден обект, като поставите символа звезда (*) до името на метода.
			Същия синтаксис работи и за класове, както и че позволява всеки един метод да бъде генератор. Ето един пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">class</span> MyClass { 
    *createIterator() {
        <span class="code">yield</span> 1;
        <span class="code">yield</span> 2;
        <span class="code">yield</span> 3; 
    }
}

<span class="code">let</span> instance = <span class="code">new</span> MyClass();
<span class="code">let</span> iterator = instance.createIterator();
				</pre>
			</dd>
		</dl>
		<p>Този код създава клас наречен
			<em>MyClass</em> с метод - генератор наречен
			<em>createIterator()</em>. Метода връща итератор, чиито стойности са кодирани в генератора. Генератор методите са полезни,
			когато имате обект, който представлява сбор от стойности и искате да обхождате тези стойности лесно.
			<em>arrays, sets</em> и
			<em>maps</em> имат множество генератор методи за отчитане на различните начини, по които програмистите взаимодействат с техните
			позиции.</p>
		<p>Докато методите на генератора са полезни, много по-полезно е да се определят
			<em>default</em> итератори за вашия клас, ако класа представлява колекция от стойности. Можете да определите
			<em>default</em> итератор за един клас с помощта на
			<em>Symbol.iterator</em> за определяне на метод - генератор, като например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">class</span> Collection { 
    constructor() {
        <span class="code">this</span>.items = []; 
    } 
    *[Symbol.iterator]() {
        <span class="code">yield *this</span>.items.values(); 
    } 
}

<span class="code">var</span> collection = <span class="code">new</span> Collection(); 
collection.items.push(1); 
collection.items.push(2);
collection.items.push(3);

<span class="code">for</span>(<span class="code">let</span> x of collection) { 
    console.log(x); 
} 
// Output: 
// 1 
// 2 
// 3
				</pre>
			</dd>
		</dl>
		<p>Този пример използва изчислено име за метода на генератора, който делегира итератора
			<em>values()</em> към
			<em>this.items</em>. Всеки клас, който управлява колекция от стойности трябва да включва
			<em>default</em> итератор, защото за да работят някои специфични операции за колекции изисква да имат итератор. По този начин
			всички случаи на
			<em>Collection</em> може да се използват директно в
			<em>for-of</em> цикъл или с оператора
			<em>spread</em>.</p>
		<p>Добавянето на методи и
			<em>accessor</em> свойства на прототипа на класа е полезно, когато искате те да се появяват в инстанциите на обекта. Ако от
			друга страна искате методи и
			<em>accessor</em> свойства на самия клас, тогава ще трябва да използвате статични членове.</p>
		<h3>Статични членове</h3>
		<p>Друг общ модел в ECMAScript 5 и по-рано е добавяне на допълнителни методи директно в конструктора за симулиране на статични
			членове. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> PersonType(name) {
    <span class="code">this</span>.name = name; 
}

<span class="comment"><em>// статичен метод</em></span> 
PersonType.create = <span class="code">function</span>(name) {
    <span class="code">return new</span> PersonType(name); 
};

<span class="comment"><em>// инстанция на метод</em></span> 
PersonType.prototype.sayName = <span class="code">function</span>() { 
    console.log(<span class="code">this</span>.name); 
};

<span class="code">var</span> person = PersonType.create("Nicholas");
				</pre>
			</dd>
		</dl>
		<p>Този код създава
			<em>factory</em> метод с
			<em>PersonType.create()</em>. В други програмни езици
			<em>factory</em> метода се счита статичен метод, тъй като той не зависи от инстанцията на
			<em>PersonType</em> за своите данни. ECMAScript 6 класовете опростяват създаването на статични членове с помощта на
			<em>static</em> нотация преди името на метод или accessor свойство. Например, тук е клас еквивалент на последния пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">class</span> PersonClass {

    <span class="comment"><em>// еквивалентно на PersonType конструктора</em></span> 
    constructor(name) {
        <span class="code">this</span>.name = name; 
    }

    <span class="comment"><em>// еквивалентно на PersonType.prototype.sayName</em></span> 
    sayName() {
        console.log(<span class="code">this</span>.name); 
    }

    <span class="comment"><em>// еквивалентно на PersonType.create</em></span>
    <span class="code">static</span> create(name) {
        <span class="code">return new</span> PersonClass(name); 
    } 
}

<span class="code">let</span> person = PersonClass.create("Nicholas");
				</pre>
			</dd>
		</dl>
		<p>Дефиницията на
			<em>PersonClass</em> има един единствен статичен метод наречен
			<em>create()</em>. Синтаксиса на метода е същия, както за
			<em>sayName()</em> с изключение на ключовата дума
			<em>static</em>. Можете да използвате ключовата дума
			<em>static</em> върху всеки метод или
			<em>accessor</em> свойство в рамките на един клас. Единственото ограничение е, че не можете да използвате
			<em>static</em> в дефиницията на конструктора.</p>
		<dl>
			<dd>
				<div class="worning">
					<img src="./img/worning.jpg" alt="worning">
				</div>
				<strong>Статичните членове не са достъпни от инстанциите. Достъп до статичните членове винаги трябва да се получи от класа директно.</strong>
			</dd>
		</dl>
		<h3>Наследяване с производни класовете</h3>
		<p>Друг проблем с потребителските типове перди ECMAScript 6, беше обширния процес необходим за изпълнение на наследяването.
			За правилно наследяване, трябват няколко стъпки. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> Rectangle(length, width) {
    <span class="code">this</span>.length = length;
    <span class="code">this</span>.width = width; 
} 

Rectangle.prototype.getArea = <span class="code">function</span>() {
    <span class="code">return this</span>.length * <span class="code">this</span>.width; 
};

<span class="code">function</span> Square(length) { 
    Rectangle.call(<span class="code">this</span>, length, length); 
} 

Square.prototype = <span class="code">Object</span>.create(Rectangle.prototype, { 
    constructor: {
        value: Square,
        enumerable: <span class="code">true</span>, 
        writable: <span class="code">true</span>,
        configurable: <span class="code">true</span> 
    } 
});

<span class="code">var</span> square = <span class="code">new</span> Square(3); 

console.log(square.getArea());     // 9
console.log(square <span class="code">instanceof</span> Square);   // true 
console.log(square <span class="code">instanceof</span> Rectangle);    // true
				</pre>
			</dd>
		</dl>
		<p>Тука,
			<em>Square</em> наследява от
			<em>Rectangle</em> и за да го направи, трябва да презапише
			<em>Square.prototype</em> с нов обект създаден от
			<em>Rectangle.prototype</em>, както и да извика
			<em>Rectangle.call()</em> метода. Тези стъпки често се бъркат от начинаещите в изучаването на езика, но са и източник на грешки
			и за опитни програмисти.</p>
		<p>Класовете правят наследяването по-лесно с помощта на познатата ключова дума
			<em>extends</em> за уточняване на функциите, от която трябва да наследи класа. Прототипите се настройват автоматично и можете
			да получите достъп до базовия клас конструктор, използвайки
			<em>super()</em> метода. Ето ECMAScript 6 еквивалента на предишния пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">class</span> Rectangle { 
    constructor(length, width) {
        <span class="code">this</span>.length = length;
        <span class="code">this</span>.width = width; 
    } 
	
    getArea() {
    <span class="code">return this</span>.length * <span class="code">this</span>.width; 
    } 
}

<span class="code">class</span> Square <span class="code">extends</span> Rectangle { 
    constructor(length) {
        <span class="comment"><em>// също, като Rectangle.call(this, length, length)</em></span>
        <span class="code">super</span>(length, length); 
    } 
}

<span class="code">var</span> square = <span class="code">new</span> Square(3); 

console.log(square.getArea());     // 9
console.log(square <span class="code">instanceof</span> Square);  // true 
console.log(square <span class="code">instanceof</span>Rectangle);  // true
				</pre>
			</dd>
		</dl>
		<p>В този пример, класа
			<em>Square</em> наследява от
			<em>Rectangle</em> с помощта на ключовата дума
			<em>extends. Square</em> конструктора използва
			<em>super()</em> за да извика
			<em>Rectangle</em> конструктора с определени аргументи. Имайте в предвид, че за разлика от версията на кода в ECMAScript 5
			идентификатора
			<em>Rectangle</em> се използва само в рамките на декларацията на класа (след
			<em>extends</em>).</p>
		<p>Класове, които наследяват от други класове са посочени, като производни класове. Използването на
			<em>super()</em> е изискване за производните класове, ако посочите конструктор; ако не го направите, ще възникне грешка. Ако
			решите да не използвате конструктор, тогава
			<em>super()</em> се извиква автоматично, с всички аргументи при създаването на нова инстанция на класа. Например, следващите
			два класа са идентични:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">class</span> Square <span class="code">extends</span> Rectangle {
    <span class="comment"><em>// няма конструктор</em></span> 
}

<span class="comment"><em>// е еквивалентно на</em></span>

<span class="code">class</span> Square <span class="code">extends</span> Rectangle { 
    constructor(...args) {
        <span class="code">super</span>(...args); 
    } 
}
				</pre>
			</dd>
		</dl>
		<p>Втория клас в този пример показва еквивалент на конструктор по подразбиране за всички производни класове. Всички аргументи
			се подават към конструктора на базовия клас. В този случай функционалността не е съвсем правилна, защото на
			<em>Square</em> конструктора му трябва само един аргумент и затова е най-добре да се определят ръчно в конструктора.</p>
		<dl>
			<dd>
				<div class="worning">
					<img src="./img/worning.jpg" alt="worning">
				</div>
				<strong>Има няколко неща, които трябва да имате в предвид, когато използвате
					<em>super()</em>:
					<ol>
						<li>Може да използвате
							<em>super()</em> само в производен клас. Ако се опитате да го използвате в не-производен клас (клас който не използва
							<em>extends</em>) или функция, ще бъде хвърлена грешка.</li>
						<li>Трябва да извикате
							<em>super()</em> преди
							<em>this</em> в конструктора. Тъй като
							<em>super()</em> е отговорен за инициализацията на
							<em>this</em>, опита за достъп до
							<em>this</em> преди извикването на
							<em>super()</em> ще доведе до грешка.</li>
						<li>Единственият начин да се избегне извикване на
							<em>super()</em> е да се върне обект от клас конструктора.</li>
					</ol>
				</strong>
			</dd>
		</dl>
		<h3>Сянка на методите на класа</h3>
		<p>Методите на производните класове са винаги сянка на методите със същото име на базовия клас. Например можем да добавим
			<em>getArea()</em> към
			<em>Square</em> с цел да предефинираме тази функционалност:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">class</span> Square <span class="code">extends</span> Rectangle { 
    constructor(length) {
        <span class="code">super</span>(length, length); 
    }

    <span class="comment"><em>// презаписване и сянката на Rectangle.prototype.getArea()</em></span> 
    getArea() {
        <span class="code">return this</span>.length * <span class="code">this</span>.length;
    } 
}
					</pre>
			</dd>
		</dl>
		<p>В този код,
			<em>getArea()</em> се определя, като част от
			<em>Square</em> и следователно
			<em>Rectangle.prototype.getArea()</em> метода вече няма да се извиква с всички случаи на
			<em>Square</em>. Разбира се винаги може да решите да извикате от базовия клас версията на метода с помощта на
			<em>super.getArea()</em>, също като:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">class</span> Square <span class="code">extends</span> Rectangle { 
    constructor(length) {
        <span class="code">super</span>(length, length); 
    }

    <span class="comment"><em>// презаписване, сянка и извикване на Rectangle.prototype.getArea()</em></span> 
    getArea() {
        <span class="code">return super</span>.getArea(); 
    }
}
					</pre>
			</dd>
		</dl>
		<p>Използването на
			<em>super</em> по този начин, е обсъдено в
			<a href="./04_object_function.html">Глава 4</a> (виж "Easy Prototype Access със
			<em>super</em> референция"). Стойността
			<em>this</em> е автоматично настроена правилно, така че да можете да направите един прост метод за извикване.</p>
		<h3>Наследяване на статични членове</h3>
		<p>Ако базовият клас има статични членове, тогава тези статични членове също са на разположение на производния клас. Това
			наследяване работи подобно на други езици, но е нова концепция за JavaScript. Ето един пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">class</span> Rectangle { 
    constructor(length, width) {
        <span class="code">this</span>.length = length;
        <span class="code">this</span>.width = width; 
    } 
	
    getArea() {
        <span class="code">return this</span>.length * <span class="code">this</span>.width; 
    }

    <span class="code">static</span> create(length, width) {
        <span class="code">return new</span> Rectangle(length, width);
    } 
}

<span class="code">class</span> Square <span class="code">extends</span> Rectangle { 
    constructor(length) {

        <span class="comment"><em>// също, като Rectangle.call(this, length, length)</em></span>
        <span class="code">super</span>(length, length); 
    }
}

<span class="code">var</span> rect = Square.create(3, 4); 

console.log(rect <span class="code">instanceof</span> Rectangle);   // true 
console.log(rect.getArea());              // 12 
console.log(rect <span class="code">instanceof</span> Square);      // false
					</pre>
			</dd>
		</dl>
		<p>В този код, новия
			<em>static create()</em> метод се добавя към
			<em>Rectangle</em> класа. Чрез наследяване този метод е достъпен, като
			<em>Square.create()</em> метода се държи по същия начин, както
			<em>Rectangle.create()</em> метода.</p>
		<h3>Производни класове от изрази</h3>
		<p>Може би най-мощният аспект на производните класове в ECMAScript 6 е възможността да се извлече клас от израз. Можете да
			използвате
			<em>extends</em> с всеки израз, толкова дълго, колкото израза реши, че е функция с [[Construct]] и прототип. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> Rectangle(length, width) {
    <span class="code">this</span>.length = length;
    <span class="code">this</span>.width = width; 
} 

Rectangle.prototype.getArea = function() {
    <span class="code">return this</span>.length * <span class="code">this</span>.width; 
};

<span class="code">class</span> Square <span class="code">extends</span> Rectangle { 
    constructor(length) {
    <span class="code">super</span>(length, length); 
    } 
}

<span class="code">var</span> x = <span class="code">new</span> Square(3); 
console.log(x.getArea());              // 9 
console.log(x <span class="code">instanceof</span> Rectangle);   // true
					</pre>
			</dd>
		</dl>
		<p>Този пример определя
			<em>Rectangle</em> в ECMAScript 5 стил на конструктора, докато
			<em>Square</em> е клас. Тъй като
			<em>Rectangle</em> има [[Construct]] и прототип,
			<em>Square</em> класа все още може да наследява директно от него.</p>
		<p>Приемане на всякакъв тип на израз след
			<em>extends</em> позволява някои мощни възможности, като например, динамично определяне, на това какво наследява. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> Rectangle(length, width) {
    <span class="code">this</span>.length = length;
    <span class="code">this</span>.width = width; 
} 

Rectangle.prototype.getArea = <span class="code">function</span>() {
    <span class="code">return this</span>.length * <span class="code">this</span>.width; 
};

<span class="code">function</span> getBase() {
    <span class="code">return</span> Rectangle; 
}

<span class="code">class</span> Square <span class="code">extends</span> getBase() { 
    constructor(length) {
    <span class="code">super</span>(length, length); 
    } 
}

<span class="code">var</span> x = <span class="code">new</span> Square(3); 
console.log(x.getArea());              // 9 
console.log(x <span class="code">instanceof</span> Rectangle);   // true
					</pre>
			</dd>
		</dl>
		<p>Тука, функцията
			<em>getBase()</em> се извиква директно, като част от декларацията на класа. Тя връща
			<em>Rectangle</em>, което прави този пример функционално еквивалентен на предишния. И тъй като можем да определим базовия
			клас динамично, означава, че е възможно да се създадат различни подходи за наследяване. Например, можете ефективно да
			създадете
			<em>mixins</em>:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> SerializableMixin = { 
    serialize() {
        <span class="code">return</span> JSON.stringify(<span class="code">this</span>); 
    } 
};

<span class="code">let</span> AreaMixin = { 
    getArea() {
        <span class="code">return this</span>.length * <span class="code">this</span>.width; 
    } 
};

<span class="code">function</span> mixin(...mixins) {
    <span class="code">var</span> base = <span class="code">function</span>() {};
    <span class="code">Object</span>.assign(base.prototype, ...mixins);
    <span class="code">return</span> base; 
}

<span class="code">class</span> Square <span class="code">extends</span> mixin(AreaMixin, SerializableMixin) { 
    constructor(length) {
        <span class="code">super</span>();
        <span class="code">this</span>.length = length;
        <span class="code">this</span>.width = length;
    } 
}

<span class="code">var</span> x = <span class="code">new</span> Square(3); 
console.log(x.getArea());            // 9 
console.log(x.serialize());          // "{"length":3,"width":3}"
					</pre>
			</dd>
		</dl>
		<p>В този пример,
			<em>mixins</em> се използват вместо класическо наследяване. Функцията
			<em>mixin()</em> взема произволен брой аргументи, които представляват
			<em>mixin</em> обекти. Той създава функция наречена
			<em>base</em> и възлага свойства на всеки
			<em>mixin</em> обект към прототипа. Функцията след това се връща, така
			<em>Square</em> може да използва
			<em>extends</em>. Имайте в предвид, че тъй като
			<em>extends</em> все още се използва, вие трябва да извикате
			<em>super()</em> в конструктора.</p>
		<p>В този случай,
			<em>Square</em> има както
			<em>getArea()</em> от
			<em>AreaMixin</em> така и
			<em>serialize</em> от
			<em>SerializableMixin</em>. Това се постига чрез прототипното наследяване. Функцията
			<em>mixin()</em> динамично наследява прототипа на новата функция с всички собствени свойства на всеки
			<em>mixin</em>. (Имайте в предвид, че ако няколко
			<em>mixins</em> имат едно и също свойство, само последното добавено свойство ще остане.)</p>
		<dl>
			<dd>
				<div class="worning">
					<img src="./img/worning.jpg" alt="worning">
				</div>
				<strong>Въпреки, че всеки израз може да се използва след
					<em>extends</em>, не всички изрази дават валиден клас. По-конкретно следните типове изрази предизвикват грешка:
					<ul>
						<li>null</li>
						<li>генератор функции (
							<a href="08_iterators_and_generators.html">Глава 8</a>)</li>
					</ul>
					В тези случаи, всеки опит да се създаде нова инстанция на класа ще доведе до грешка, защото няма [[Construct]] за извикване.
				</strong>
			</dd>
		</dl>
		<h3>Наследяване от вградени модули</h3>
		<p>Почти толкова дълго, от когато има
			<em>arrays</em> в JavaScript, програмистите са искали да създават свои собствени специални видове
			<em>arrays</em>, чрез наследяване. Обаче, в ECMAScript 5 и по-рано, това не е било възможно. Опитите да се използва класическо
			наследяване не са водели до функциониращ код. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="comment"><em>// вградено поведение в <em>array</em></em></span>
<span class="code">var</span> colors = []; 
colors[0] = "red"; 
console.log(colors.length);     // 1 

colors.length = 0; 
console.log(colors[0]);     // undefined

<span class="comment"><em>// опити за наследяване на <em>array</em> в ES5</em></span>

<span class="code">function</span> MyArray() {
    <span class="code">Array</span>.apply(<span class="code">this</span>, arguments); 
} 

MyArray.prototype = <span class="code">Object</span>.create(<span class="code">Array</span>.prototype, { 
    constructor: { 
        value: MyArray, 
        writable: <span class="code">true</span>,
        configurable: <span class="code">true</span>, 
        enumerable: <span class="code">true</span> 
    }
});

<span class="code">var</span> colors = <span class="code">new</span> MyArray(); 
colors[0] = "red"; 
console.log(colors.length);     // 0 

colors.length = 0; 
console.log(colors[0]);        // "red"
					</pre>
			</dd>
		</dl>
		<p>В изхода на
			<em>console.log</em> в края на кода, може да видите, че използването на класическата форма на наследяване в JavaScript води
			до неочаквано поведение в резултатите на
			<em>array</em>. Дължината
			<em>length</em> и цифровото свойство в копието на
			<em>MyArray</em> не реагират по същия начин, както във вградения <em>array</em>, защото тази функционалност не се покрива от
			<em>Array.apply()</em> или чрез възлагане на прототипа.</p>
		<p>Една от целите на ECMAScript 6 класовете е да се позволи наследяване от всички вградени модули. За да се постигне това,
			модела на наследяването на класове е малко по-различен от модела на класическото наследяване в ECMAScript 5 и по-рано,
			по два начина:</p>
		<dl>
			<dd>
				<ul>
					<li>В класическото наследяване на ECMAScript 5, стойността
						<em>this</em> се създава първо от производните типове (например,
						<em>MyArray</em>) и след това се извиква базовия тип конструктор (
						<em>Array.apply()</em>). Това означава, че
						<em>this</em> започва, като инстанция на
						<em>MyArray</em> и след това се украсява с допълнителни свойства от
						<em>Array</em>.</li>
					<li>В базираното на класове наследяване на ECMAScript 6 стойността на
						<em>this</em> се създава първо от базовия (
						<em>Array</em>) и след това се модифицира от конструктора на производния клас (
						<em>MyArray</em>). Резултата е, че
						<em>this</em> започва с всички вградени функции на основата и правилно приема всички функции свързани с него.</li>
				</ul>
			</dd>
		</dl>
		<p>Следния базиран на клас специален <em>array</em>, работи както се очаква</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">class</span> MyArray <span class="code">extends Array</span> {
    <span class="comment"><em>// празно</em></span> }

<span class="code">var</span> colors = <span class="code">new</span> MyArray(); 

colors[0] = "red"; 
console.log(colors.length);    // 1 
colors.length = 0; 
console.log(colors[0]);        // undefined
					</pre>
			</dd>
		</dl>
		<p>В този пример,
			<em>MyArray</em> наследява директно от
			<em>Array</em> и следователно работи, като
			<em>Array</em>. Взаимодействието с цифровите свойства актуализира
			<em>length</em> свойството и манипулирането на
			<em>length</em> свойството актуализира цифровите свойства. Това означава, че не само може правилно да наследява от
			<em>Array</em>, но и да създаде свои собствени производни класове от
			<em>arrays</em>, както и да наследява от други вградени модули. С цялата тази допълнителна функционалност, ECMAScript 6 и
			производните класове ефективно отстраняват последния специален случай на наследяване от вградени модули, но този случай
			е все още на етап проучване.</p>
		<h3>Symbol.species свойства</h3>
		<p>Интересен аспект на наследяване от вградени модули е, че всеки метод, който връща инстанция на вграден модул автоматично,
			ще върне инстанция на производния клас. Така, че ако имаме производен клас
			<em>MyArray</em>, който наследява от
			<em>Array</em> методи, като
			<em>slice()</em>, ще се върне, като инстанция на
			<em>MyArray</em>. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">class</span> MyArray <span class="code">extends Array</span> {
    <span class="comment"><em>// празно</em></span> 
}

<span class="code">let</span> items = <span class="code">new</span> MyArray(1, 2, 3, 4), 
    subitems = items.slice(1, 3); 
	
console.log(items <span class="code">instanceof</span> MyArray);      // true 
console.log(subitems <span class="code">instanceof</span> MyArray);   // true
					</pre>
			</dd>
		</dl>
		<p>В този код,
			<em>slice()</em> метода се връща, като инстанция на
			<em>MyArray</em>. Метода
			<em>slice()</em> е наследен от
			<em>Array</em> и се връща, като инстанция на
			<em>Array</em> нормално. Зад кулисите на сцената, това е
			<em>Symbol.species</em> свойство, който прави тази промяна.</p>
		<p>
			<em>Well-known</em>
			<em>Symbol.species</em> се използва за определяне на статично свойство за достъп, което връща функция. Тази функция е конструктор,
			която за да се използва,като инстанция на клас, трябва да бъде създадена вътре в инстанцията на метода (вместо да се използва
			конструктора). Има няколко вградени типове, които имат дефиниран
			<em>Symbol.species</em>:</p>
		<dl>
			<dd>
				<ul>
					<li>Array</li>
					<li>ArrayBuffer (обсъден в
						<a href="10_array.html">Chapter 10</a>)</li>
					<li>Map</li>
					<li>Promise</li>
					<li>RegExp</li>
					<li>Set</li>
					<li>Typed Arrays (обсъдени в
						<a href="10_array.html">Chapter 10</a>)</li>
				</ul>
			</dd>
		</dl>
		<p>Всеки един от тези типове имат по подразбиране
			<em>Symbol.species</em> свойство, което връща
			<em>this</em>, което означава, че свойството винаги ще върне функция конструктор. Ако ви се налага да изпълнявате тези функции
			на потребителски клас, кодът ще изглежда така:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="comment"><em>// няколко вградени типове използват видове подобни на this</em></span>
<span class="code">class</span> MyClass {
    <span class="code">static</span> get [Symbol.species]() {
        <span class="code">return this</span>; 
    } 
    constructor(value) {
        <span class="code">this</span>.value = value; 
    } 
    clone() {
        <span class="code">return new this</span>.constructor[Symbol.species](<span class="code">this</span>.value); 
    }
}
					</pre>
			</dd>
		</dl>
		<p>В този пример,
			<em>well-known Symbol.species</em> се използва за да зададете статично свойство за достъп до
			<em>MyClass</em>. Имайте в предвид, че има само едни
			<em>getter</em> без
			<em>setter</em>, защото не е възможно да се промени вида на един клас. Всяко извикване на
			<em>this.constructor[Symbol.species]</em> връща
			<em>MyClass</em>. Метода
			<em>clone()</em> използва това определение, за да върне нова инстанция, вместо директно използване на
			<em>MyClass</em>, което позволява на производните класове да заменят тази стойност. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">class</span> MyClass {
    <span class="code">static</span> get [Symbol.species]() {
        <span class="code">return this</span>; 
    } 
	
    constructor(value) {
        <span class="code">this</span>.value = value; 
    } 
	
    clone() {
        <span class="code">return new this</span>.constructor[Symbol.species](<span class="code">this</span>.value); 
    }
}

<span class="code">class</span> MyDerivedClass1 <span class="code">extends</span> MyClass {
    <span class="comment"><em>// празно</em></span> 
}

<span class="code">class</span> MyDerivedClass2 <span class="code">extends</span> MyClass {
    <span class="code">static</span> get [Symbol.species]() {
        <span class="code">return</span> MyClass; 
    }
}

<span class="code">let</span> instance1 = <span class="code">new</span> MyDerivedClass1("foo"),
    clone1 = instance1.clone(),
    instance2 = <span class="code">new</span> MyDerivedClass2("bar"),
    clone2 = instance2.clone(); 
	
console.log(clone1 <span class="code">instanceof</span> MyClass);             // true 
console.log(clone1 <span class="code">instanceof</span> MyDerivedClass1);     // true 
console.log(clone2 <span class="code">instanceof</span> MyClass);             // true 
console.log(clone2 <span class="code">instanceof</span> MyDerivedClass2);     // false
					</pre>
			</dd>
		</dl>
		<p>Тука,
			<em>MyDerivedClass1</em> наследява от
			<em>MyClass</em> и не променя
			<em>Symbol.species</em> свойството. Когато се извика
			<em>clone()</em>, той връща инстанцията на
			<em>MyDerivedClass1</em>, защото
			<em>this.constructor[Symbol.species]</em> връща
			<em>MyDerivedClass1</em>. Класа
			<em>MyDerivedClass2</em> наследява от
			<em>MyClass</em> и
			<em>overrides</em>
			<em>Symbol.species</em> да върне
			<em>MyClass</em>. Когато се извика
			<em>clone()</em> върху инстанцията на
			<em>MyDerivedClass2</em>, върнатата стойност е инстанция на
			<em>MyClass</em>. Използвайки
			<em>Symbol.species</em>, за всеки производен клас може да се определи, какъв тип стойност трябва да върне, когато метода връща
			инстанция.</p>
		<p> Например
			<em>Array</em> използва
			<em>Symbol.species</em>, за да каже на класа да използва методите, които връща
			<em>array</em>. В един клас, получен от
			<em>Array</em> можете да определите типа на обекта, върнат от наследените методи, като например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">class</span> MyArray <span class="code">extends Array</span> {
    <span class="code">static</span> get [Symbol.species]() {
        <span class="code">return Array</span>; 
    }
}

<span class="code">let</span> items = <span class="code">new</span> MyArray(1, 2, 3, 4),
    subitems = items.slice(1, 3); 
	
console.log(items <span class="code">instanceof</span> MyArray);       // true 
console.log(subitems <span class="code">instanceof</span> Array);      // true 
console.log(subitems <span class="code">instanceof</span> MyArray);    // false
					</pre>
			</dd>
		</dl>
		<p>Този код
			<em>overrides</em>
			<em>Symbol.species</em> на
			<em>MyArray</em>, който наследява
			<em>Array</em> и всички наследени методи, които връщат
			<em>arrays</em> ще се използват, като инстанция на Array вместо на
			<em>MyArray</em>.</p>
		<p>Като, цяло трябва да използвате
			<em>Symbol.species</em> свойството, когато искате да използвате
			<em>this.constructor</em> в клас метод. По този начин, позволява на получените класове да заменят типа на връщане лесно. Освен
			това, ако създавате производни класове от клас, който има дефиниран
			<em>Symbol.species</em>, не забравяйте да използвате тази стойност вместо тази на конструктора.</p>
		<h3 id="newTarget">Използване на new.target в клас конструктори</h3>
		<p>В
			<a href="./03_function.html">Глава 3</a>, учихме за
			<em>new.target</em> и как неговата стойност се променя в зависимост от това как се извиква една функция. Можете също да използвате
			<em>new.target</em> в клас конструктор, за да определите, как се позовава един клас. В прост случай,
			<em>new.target</em> е равен на функцията конструктор за класа, както в този пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">class</span> Rectangle { 
    constructor(length, width) { 
        console.log(<span class="code">new</span>.target === Rectangle);
        <span class="code">this</span>.length = length;
        <span class="code">this</span>.width = width; 
    }
} 

// new.target is Rectangle
<span class="code">var</span> obj = <span class="code">new</span> Rectangle(3, 4);     // outputs true
					</pre>
			</dd>
		</dl>
		<p>В този код, можем да видим, че
			<em>new.target</em> е еквивалентен на
			<em>Rectangle</em>, когато се извика
			<em>new Rectangle(3, 4)</em>. Тъй като, клас конструктора не може да се извика без
			<em>new, new.target</em> винаги е дефиниран вътре в клас конструктора. Въпреки това, стойността не може винаги да е една и
			съща. Помислете над този код:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">class</span> Rectangle { 
    constructor(length, width) { 
        console.log(<span class="code">new</span>.target === Rectangle);
        <span class="code">this</span>.length = length;
        <span class="code">this</span>.width = width; 
    }
}

<span class="code">class</span> Square <span class="code">extends</span> Rectangle { 
    constructor(length) {
        <span class="code">super</span>(length, length) 
    } 
} 

// new.target is Square
<span class="code">var</span> obj = <span class="code">new</span> Square(3);       // outputs false
					</pre>
			</dd>
		</dl>
		<p>Тука,
			<em>Square</em> извиква
			<em>Rectangle</em> конструктора, така че
			<em>new.target</em> е равна на
			<em>Square</em>, когато се извика конструктора на
			<em>Rectangle</em>. Това е важно, защото дава на всеки конструктор способноста да променя поведението си, въз основа на това
			как се извиква. Например, можете да създадете абстрактен базов клас (такъв, който не може да бъде инстанция директно)
			с помощта на
			<em>new.target</em>:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="comment"><em>// абстрактен базов клас</em></span>
<span class="code">class</span> Shape { 
    constructor() {
        <span class="code">if</span>(<span class="code">new</span>.target === Shape) {
            <span class="code">throw new Error</span>("This class cannot be instantiated directly.") 
        } 
    } 
}

<span class="code">class</span> Rectangle <span class="code">extends</span> Shape { 
    constructor(length, width) {
        <span class="code">super</span>();
        <span class="code">this</span>.length = length;
        <span class="code">this</span>.width = width; 
    } 
}

<span class="code">var</span> x = <span class="code">new</span> Shape();  <span class="comment"><em>// хвърля грешка</em></span>

<span class="code">var</span> y = <span class="code">new</span> Rectangle(3, 4); <span class="comment"><em>// няма грешка</em></span>						
console.log(y <span class="code">instanceof</span> Shape); // true
					</pre>
			</dd>
		</dl>
		<p>В този пример, клас конструктора
			<em>Shape</em> хвърля грешка, когато
			<em>new.target</em> е
			<em>Shape</em>, което означава, че
			<em>new Shape()</em> винаги хвърля грешка. Въпреки това, можете да използвате
			<em>Shape</em>, като базов клас, това е което
			<em>Rectangle</em> прави. Извикването на
			<em>super()</em> изпълнява
			<em>Shape</em> конструктора и
			<em>new.target</em> е равно на
			<em>Rectangle</em>, затова конструктора продължава без грешка.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Понеже класа не може да бъде извикан без
					<em>new, new.target</em> никога не е
					<em>undefined</em> в рамките на клас конструктор.</strong>
			</dd>
		</dl>
	</article>
	<footer>
		<h3>Обобщение</h3>
		<p>ECMAScript 6 класове правят наследяването в JavaScript лесно за използване, така че не е нужно да изхвърляте съществуващите
			разбирания на наследяването, които може да имате от други езици. ECMAScript 6 класовете започват, като
			<em>syntactic sugar</em> за класичкия модел на наследяване в ECMAScript 5, но добавят много функции за да се намалят грешките.</p>
		<p>ECMAScript 6 класовете работят с прототипното наследяване, чрез определяне на не-статични методи на прототипа на класа,
			докато статичните методи в крайна сметка са на самия конструктор. Всички методи са
			<em>non-enumerable</em>, което по-добре съответства на поведението на вградените обекти, за които методите са обикновено
			<em>non-enumerable</em> по подразбиране. Освен това, клас конструктора не може да се извика без
			<em>new</em>, това гарантира, че не може да извикате клас случайно, като функция.</p>
		<p>Клас базираното наследяване, позволява да се извлече един клас от друг клас, функция или израз. Тази способност означава,
			че можете да извикате функция за определяне на правилната основа, от която се наследява, което ви позволява да използвате
			<em>mixins</em> и други различни модели в състава за създаване на нов клас. Наследяването работи по такъв начин, че сега е
			възможно наследяване на вградени обекти, като
			<em>Array</em> и да работят, както се очаква.</p>
		<p>Можете да използвате
			<em>new.target</em> в клас конструктори, да се държи различно в зависимост от начина на извикване на класа. Най-честата употреба
			е създаване на абстрактен базов клас, който хвърля грешка, като директна инстанция, но все пак позволява наследяване през
			други класове.</p>
		<p>Като цяло, класовете са важно допълнение към JavaScript. Те осигуряват по-кратък синтаксис и по-добра функционалност за
			дефиниране на потребителски типове обекти по безопасен и последователен начин.</p>
	</footer>
	<nav>
		<a href="08_iterators_and_generators.html" title="previous chapter">◀</a>
		<a href="./index.html" title="cover">◆</a>
		<a href="10_array.html" title="next chapter">▶</a>
	</nav>
</body>

</html>