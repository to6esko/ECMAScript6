<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Sets and Maps :: Understanding ECMAScript 6</title>
	<link rel="stylesheet" href="font.css">
</head>

<body>
	<nav>
		<a href="./06_simbols.html" title="previous chapter">◀</a>
		<a href="./index.html" title="cover">◆</a>
		<a href="08_iterators_and_generators.html" title="next chapter">▶</a>
	</nav>
	<header id="header" class="">
		<h1>
			<div class="head-num">Глава 7</div>Sets и Maps</h1>
		<p>През по-голямата част от историята си, JavaScript е имала само един вид колекции, представени от
			<em>Array</em> типа (въпреки че някои могат да твърдят, че всички обекти, които не са масиви са само колекции от двойки ключ-стойности
			и тяхното предназначение е първоначално доста различно от масиви). Масивите се използват в JavaScript точно като масивите
			на другите езици, но поради липсата на други опции за колекции предназначени за масиви, те често са използвани, като
			<em>queues</em> и
			<em>stacks</em>. Тъй като, масивите използват само цифрови индекси, програмистите използват не-масиви обекти, когато са необходими
			не-цифрови индекси. Тази техника доведе до персонализирани решения за
			<em>sets</em> и
			<em>maps</em> с помоща на не-масиви обекти.</p>
		<p>
			<em>Set</em> е даден списък от стойности, които не могат да сдържат дубликати. Обикновено няма достъп до отделните елементи
			в
			<em>set</em>, както се прави с елементи в масив. Вместо това, много по-често се проверява, за да се види дали една стойност
			е на лице.
			<em>Map</em> е колекция от ключове, които съответстват на конкретни стойности. Като така, всеки елемент от
			<em>map</em> се съхранява с две парчета от данни и стойностите се извличат чрез определяне на ключ, който да чете от тях.
			<em>Maps</em> често се използват, като кеш за съхраняване на данни, които бързо да се изтеглят по-късно. Докато ECMAScript
			5 формално няма
			<em>sets</em> и
			<em>maps</em>, програмистите са успели да заобиколят това ограничение използвайки не-масиви обекти.</p>
		<p>ECMAScript 6 добавя
			<em>sets</em> и
			<em>maps</em> за JavaScript и тази глава разглежда всичко, което трябва да знаете за тези два вида колекции.</p>
		<p>Първо, аз ще обсъдя заобиколните начини, които програмистите използват за прилагане на
			<em>sets</em> и
			<em>maps</em> преди ECMAScript 6 и защо тези реализации са проблемни. След това ще обхвана как
			<em>sets</em> и
			<em>maps</em> работят в ECMAScript 6.</p>
	</header>
	<!-- /header -->
	<article>
		<h3>Sets и Maps в ECMAScript 5</h3>
		<p>В ECMAScript 5 и по-рано, програмистите имитират
			<em>sets</em> и
			<em>maps</em> чрез използване на обектни свойства, като това:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> set = <span class="code">Object</span>.create(<span class="code">null</span>);

set.foo = <span class="code">true</span>;

<span class="comment">// проверка за съществуване</span>
<span class="code">if</span> (set.foo) {

    <span class="comment">// направи нещо</span>
}	
			</pre>
			</dd>
		</dl>
		<p>Променливата
			<em>set</em> в този пример е обект с прототип
			<em>null</em>, което гарантира, че няма наследени свойства на обекта. Това е често срещан подход в ECMAScript 5, който използва
			обектни свойства, като уникални стойности, които трябва да бъдат проверени. Свойствата се добавят към
			<em>set</em> обекта и се определят на
			<em>true</em> така, че лесно да могат да се използват в условни конструкции (като,
			<em>if</em> изявлението в този пример), за да може да се провери дали стойността е налична.</p>
		<p> Единствената разлика между обект използван, като
			<em>set</em> и обект използван, като
			<em>map</em> е начина на съхранение на стойността. Например, този пример използва един обект като
			<em>map</em>:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> map = <span class="code">Object</span>.create(<span class="code">null</span>);

map.foo = "bar";

<span class="comment">// извличане на стойност</span>
<span class="code">let</span> value = map.foo;

console.log(value);         // "bar"
			</pre>
			</dd>
		</dl>
		<p>Този код съхранява
			<em>string</em> стойност "bar" под ключ "foo". За разлика от
			<em>sets</em>,
			<em>maps</em> се използват предимно за извличане на информация, а не само за проверка за съществуване на ключа.</p>
		<h3>Проблеми със заобикаляне</h3>
		<p>Докато подхода за използване на обекти, като
			<em>sets</em> и
			<em>maps</em> работи добре в прости ситуации, той може да стане по-сложен, когато се сблъска с ограниченията на обектни свойства.
			Тъй като, всички обектни свойства трябва да са
			<em>strings</em>, ние трябва да сме сигурни, че няма два ключа, които да оценяват същия
			<em>string</em>. Помислете за следното:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> map = <span class="code">Object</span>.create(<span class="code">null</span>);

map[5] = "foo";

console.log(map["5"]);      // "foo"
			</pre>
			</dd>
		</dl>
		<p>Този пример присвоява стойността на
			<em>string</em> "foo" към цифров ключ 5. Вътрешно, цифровата стойност се превръща в
			<em>string</em>, така
			<em>map["5"]</em> и
			<em>map[5]</em> всъщност са референция към едно и също свойство. Това вътрешно преобразуване може да предизвика проблеми,
			когато искаме използваме числа и
			<em>strings</em>, като ключове. Друг проблем е, когато се използват обекти, като ключове:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> map = <span class="code">Object</span>.create(<span class="code">null</span>),
    key1 = {},
    key2 = {};

map[key1] = "foo";

console.log(map[key2]);     // "foo"
			</pre>
			</dd>
		</dl>
		<p>Тука,
			<em>map[key2]</em> указва една и същата стойност, като
			<em>map[key1]</em>. Обектите
			<em>key1</em> и </em>key2</em> се преобразуват в
			<em>strings</em>, защото обектните свойства трябва да са
			<em>strings</em>. Тъй като, "[object Object]" е
			<em>string</em> представянето по подразбиране за обекти, така
			<em>key1</em> и
			<em>key2</em> се преобразуват в
			<em>string</em>. Това може да доведе до грешки, които да не са очевидни, тъй като е логично да се предположи, че различните
			ключове обекти в действителност са различни.</p>
		<p>Преобразуването на представянето в
			<em>string</em> по подразбиране, прави трудно използването на обекти, като ключове. (Същият проблем съществува, когато се
			опитваме да използваме един обект, като
			<em>set</em>.)</p>
		<p>Друг проблем се отнася конкретно до
			<em>maps</em> с ключ, чиято стойност е
			<em>falsy</em>. Стойността
			<em>falsy</em> автоматично се превръща във
			<em>false</em>, когато се използва в ситуации, при които се изисква булева стойност, като условие за
			<em>if</em> изявление. Това само по себе си не е проблем, стига да сте внимателни затова как използвате стойностите. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> map = <span class="code">Object</span>.create(<span class="code">null</span>);

map.count = 1;

<span class="comment">// проверка за наличие на "count" или не нулева стойност</span>
<span class="code">if</span> (map.count) {
    // ...
}
			</pre>
			</dd>
		</dl>
		<p>Този код има известна неяснота по отношение на използването на
			<em>map.count</em>. Предназначението на
			<em>if</em> изявлението е да провери за наличието на
			<em>map.count</em> или че стойността не е нулева. Кода вътре в
			<em>if</em> изявлението ще се изпълни защото стойността 1 е истина. Обаче, ако
			<em>map.count</em> е 0 или
			<em>map.count</em> не съществува, кодът вътре в
			<em>if</em> изявлението няма да бъде изпълнен.</p>
		<p>Това е труден проблем за идентифициране и отстраняване на грешки, когато това се случи в големи приложения, което е и основна
			причина поради която ECMAScript 6 добавя
			<em>sets</em> и
			<em>maps</em> в езика.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>JavaScript има
					<em>in</em> оператор, който връща
					<em>true</em>, ако свойството съществува в обекта, без да чете стойността на обекта. Освен това,
					<em>in</em> операторът също търси в прототипа на един обект, което го прави безопасен за използване, когато един обект е
					с
					<em>null</em> прототип. Дори и така, много програмисти все още неправилно използват код, като в последния пример, а не използват
					<em>in</em>.</strong>
			</dd>
		</dl>
		<h3>Sets в ECMAScript 6</h3>
		<p>ECMAScript 6 добавя
			<em>Set</em> тип, който е подреден списък от стойности без дубликати.
			<em>Sets</em> позволява бърз достъп до данните, съдържащи се в рамката му, добавяйки по-ефективен начин за проследяване на
			дискретни стойности.</p>
		<h4>Създаване на Sets и добавяне на елементи</h4>
		<p>
			<em>Set</em> се създава с помощта на
			<em>new Set()</em> и елементи се добавят към
			<em>set</em> използвайки
			<em>add()</em> метод. Можем да видим, колко елемента са в
			<em>set</em> използвайки
			<em>size</em> свойство.</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> Set();
set.add(5);
set.add("5");

console.log(set.size);    // 2
			</pre>
			</dd>
		</dl>
		<p>
			<em>Sets</em> не коригира стойностите за определяне на типа, те са едни и същи. Това означава, един
			<em>set</em> може да съдържа, както номер 5 така и
			<em>string</em> "5", като два отделни елемента. (Вътрешно сравнението се прави с помощта на
			<em>Object.is()</em> метода, който е обсъден в
			<a href="./04_object_function.html">Глава 4</a>, за да определи дали двете стойности са едни и същи). Можете да добавите множество обекти, към
			<em>set</em> и те ще останат различни:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> Set(),
    key1 = {},
    key2 = {};

set.add(key1);
set.add(key2);

console.log(set.size);    // 2
			</pre>
			</dd>
		</dl>
		<p>Тъй като,
			<em>key1</em> и
			<em>key2</em> не се преобразуват в
			<em>strings</em>, те се броят за два уникални елемента в
			<em>set</em>. (Не забравяйте, че ако те се превръщат в
			<em>strings</em> и двата ще са равни на "[Object object]".)</p>
		<p>Ако
			<em>add()</em> метода се извика повече от веднъж с една и съща стойност, всички извиквания след първото се игнорират ефективно:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> Set();
set.add(5);
set.add("5");
set.add(5);     <span class="comment">// дублирането се игнорира</span>

console.log(set.size);    // 2
			</pre>
			</dd>
		</dl>
		<p>Можете да инициализирате
			<em>set</em> използвайки масив и
			<em>Set</em> конструктора ще гарантира, че се използват само уникални стойности:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> Set([1, 2, 3, 4, 5, 5, 5, 5]);
console.log(set.size);    // 5
			</pre>
			</dd>
		</dl>
		<p>В този пример, масив с дублиращи се стойности се използва за инициализиране на
			<em>set</em>. Броя 5 се появява само веднъж в
			<em>set</em> въпреки, че изглежда четири пъти в масива. Тази функционалност прави лесно преобразуването на съществуващ код
			или JSON структури с използването на
			<em>sets</em>.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>
					<em>Set</em> конструктора всъщност приема всеки
					<em>iterable</em> обект, като аргумент. Масивите работят, защото те са
					<em>iterable</em> по подразбиране, също като
					<em>sets</em> и
					<em>maps</em>.
					<em>Set</em> конструктора използва итератор за извличане на стойности от аргумента.(
					<a href="08_iterators_and_generators.html">
						<em>Iterables</em>
					</a> и
					<a href="08_iterators_and_generators.html">итераторите</a> са разгледани в
					<a href="08_iterators_and_generators.html">Глава 8</a>.)</strong>
			</dd>
		</dl>
		<p>Можете да тествате за да видите, кои стойности са в
			<em>set</em> използвайки
			<em>has()</em> метод:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> Set();
set.add(5);
set.add("5");

console.log(set.has(5));    // true
console.log(set.has(6));    // false
			</pre>
			</dd>
		</dl>
		<p>Тук
			<em>set.has(6)</em> ще се върне
			<em>false</em>, защото
			<em>set</em> няма такава стойност.</p>
		<h3>Премахване на стойност</h3>
		<p>Възможно е да се премахват стойности от
			<em>set</em>. Можете да премахнете една стойност с помощта на
			<em>delete()</em> метода или да премахнете всички стойности от
			<em>set</em> с помощта на
			<em>clear()</em> метода. Този код показва това в действие:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> Set();
set.add(5);
set.add("5");

console.log(set.has(5));    // true

set.<span class="code">delete</span>(5);

console.log(set.has(5));    // false
console.log(set.size);      // 1

set.clear();

console.log(set.has("5"));  // false
console.log(set.size);      // 0
			</pre>
			</dd>
		</dl>
		<p>След извикването на
			<em>delete()</em>, само 5 го няма; след изпълнението на
			<em>clear()</em> метода,
			<em>set</em> е празен.</p>
		<p>Всичко това е само един много лесен механизъм за проследяване на уникални подредени стойности. Обаче, ако искате да добавите
			елемент в
			<em>set</em> и след това да изпълните някоя операция върху всеки елемент, е момента, в който метода
			<em>forEach()</em> идва на помощ.</p>
		<h3>Метода forEach() за Sets</h3>
		<p>Ако сте свикнали да използвате масиви тогава вече може да сте запознати с
			<em>forEach()</em> метода. ECMAScript 5 добавя
			<em>forEach()</em> към масиви, за да се създаде по-лесен начин за работа върху всеки елемент в масив, без създаване на
			<em>for</em> цикъл. Метода се оказа популярен сред програмистите и така един и същи метод е наличен и за
			<em>sets</em> и работи по същия начин.</p>
		<p>Метода
			<em>forEach()</em> се подава на функция за обратно извикване и приема три аргумента.</p>
		<dl>
			<dd>
				<ol>
					<li>Стойността от следващата позиция в
						<em>set</em>.</li>
					<li>Същата стойност, като първия аргумент.</li>
					<li>
						<em>Set</em> от който чете стойността.</li>
				</ol>
			</dd>
		</dl>
		<p>Странна разлика между
			<em>set</em> версията на
			<em>forEach()</em> и версията за масив, е че първия и втория аргумент на функцията за обратно извикване са едни и същи. Въпреки,
			че това изглежда, като грешка има добра причина затова поведение.</p>
		<p>Другите обекти, които имат
			<em>forEach()</em> метод (масиви и
			<em>maps</em>) подават три аргумента към техните функции за обратно извикване. Първите два аргумента за масиви и
			<em>maps</em> са стойност и ключ (цифров индекс за масиви).</p>
		<p>
			<em>Sets</em> нямат ключове, обаче. Хората зад стандарта на ECMAScript 6 биха могли да направят функцията за обратно извикване
			да приема два аргумента, което ще я направи различна от другите две. Вместо това те намерили начин да запазят функцията
			за обратно извикване да приема три аргумента и така
			<em>sets</em> разглежда всяка стойност едновременно, като ключ и стойност. Като такива, първият и вторият аргумент са винаги
			едни и същи в
			<em>forEach()</em> за
			<em>sets</em>, за да се запази същата функционалност в съответствие с другите
			<em>forEach()</em> методи за масиви и
			<em>maps</em>.</p>
		<p>Освен разликата с аргументите, използването на
			<em>forEach()</em> е основно същото, както за
			<em>set</em> така и за масиви. Ето част от код, който показва начина на работа:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> Set([1, 2]);

set.forEach(<span class="code">function</span>(value, key, ownerSet) {
    console.log(key + " " + value);
    console.log(ownerSet === set);
});
			</pre>
			</dd>
		</dl>
		<p>Този код минава над всеки елемент във
			<em>set</em> и на изхода извежда стойностите подадени към
			<em>forEach()</em> функцията за обратно извикване. Всеки път, когато функцията обратно извикване се изпълнява,
			<em>key</em> и
			<em>value</em> са еднакви и
			<em>ownerSetе</em> винаги e равно на
			<em>set</em>. Това е изхода:</p>
		<dl>
			<dd>
				<pre class="highlight">
				<br>1 1 <br>true <br>2 2 <br>true</p>
			    </pre>
			</dd>
		</dl>
		<p>Също, като при масиви, можете да подадете
			<em>this</em> стойност, като втори аргумент на
			<em>forEach()</em>, ако имате нужда да използвате
			<em>this</em> в вашата функция за обратно извикване:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> Set([1, 2]),
    processor = {
        output(value) {
            console.log(value);
        },
        process(dataSet) {
            dataSet.forEach(<span class="code">function</span>(value) {
                <span class="code">this</span>.output(value);
            }, <span class="code">this</span>);
        }
    };

processor.process(set);
	    	</pre>
			</dd>
		</dl>
		<p>В този пример, метода
			<em>processor.process()</em> извиква
			<em>forEach()</em> върху
			<em>set</em> и подава
			<em>this</em>, като
			<em>this</em> стойност за обратно извикване. Това е необходимо, така че
			<em>this.output()</em> правилно да реши по отношение на
			<em>processor.output()</em> метода.
			<em>forEach()</em> функцията използва само първия аргумент
			<em>value</em>, така че другите са пропуснати. Може да използвате функция стрела, за да получите същия ефект, без да подавате
			втори аргумент:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> Set([1, 2]),
    processor = {
        output(value) {
            console.log(value);
        },
        process(dataSet) {
            dataSet.forEach((value) => <span class="code">this</span>.output(value));
        }
    };

processor.process(set);
	    	</pre>
			</dd>
		</dl>
		<p>Функцията стрела в този пример, чете
			<em>this</em> от съдържащата
			<em>process()</em> функция и така правилно решава
			<em>this.output()</em> по отношение на
			<em>processor.output()</em> извикването.</p>
		<p>Имайте в предвид, че
			<em>sets</em> са чудесни стойности за проследяване и
			<em>forEach()</em> ви позволява да работите върху всяка стойност последователно, но не можете да получите директен достъп
			до индекса на стойност, както можете в масив. Ако трябва да направите това, тогава най-добрия вариант е да превърнете
			<em>set</em> в масив.</p>
		<h3 id="spreads">Превръщане на Set в масив</h3>
		<p>Превръщането на масив в
			<em>set</em> е лесно, защото можем да подадем масива на
			<em>Set</em> конструктора. Също така е лесно да превърнем
			<em>set</em> обратно в масив, използвайки оператора
			<em>spread</em>. Оператора
			<em>spread (...)</em> беше обсъден в
			<a href="./03_function.html">Глава 3</a>, като начин да се разделят елементите в масив на отделни функционални параметри. Можем също да използваме
			оператора
			<em>spread</em> върху
			<em>iterable</em> обекти, също като
			<em>sets</em>, който да ги превръща в масив. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> set = new Set([1, 2, 3, 3, 3, 4, 5]),
    array = [...set];

console.log(array);             // [1,2,3,4,5]
	    	</pre>
			</dd>
		</dl>
		<p>Тука,
			<em>set</em> е зареден първоначално с масив, който съдържа дубликати.
			<em>Set</em> премахва дубликатите и след това елементите се поставят в нов масив, използвайки оператора
			<em>spread</em>. Самия
			<em>set</em> все още съдържа същите елементи (1,2,3,4 и 5), които е получил, когато е бил създаден. Те само са копирани в
			нов масив.</p>
		<p>Този подход е полезен, когато вече имаме масив и искаме да създадем масив без дубликати. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> eliminateDuplicates(items) {
    <span class="code">return</span> [...<span class="code">new</span> Set(items)];
}

<span class="code">let</span> numbers = [1, 2, 3, 3, 3, 4, 5],
    noDuplicates = eliminateDuplicates(numbers);

console.log(noDuplicates);      // [1,2,3,4,5]
	    	</pre>
			</dd>
		</dl>
		<p>Във функцията
			<em>eliminateDuplicates()</em>,
			<em>set</em> е само временен посредник, използван за филтриране на дублирани стойности преди създаването на нов масив, който
			няма дубликати.</p>
		<h3>Weak Sets</h3>
		<p>
			<em>Set</em> типа алтернативно може да се нарече силен комплект, заради начина по който съхранява референции към обекти. Един
			обект се съхранява в инстанция на
			<em>Set</em> ефективно по същия начин, както се съхранява този обект в променлива. Докато препратка към тази инстанция на
			<em>Set</em> съществува, обектът не може да бъде почистен от събрания
			<em>garbage</em> (боклук) за да се освободи памет. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> set = new Set(),
    key = {};

set.add(key);
console.log(set.size);      // 1

<span class="comment">// премахване на оригиналната референция</span>
key = <span class="code">null</span>;

console.log(set.size);      // 1

<span class="comment">// вземане на оригиналната референция обратно</span>
key = [...set][0];
	    	</pre>
			</dd>
		</dl>
		<p>В този пример,
			<em>key</em> се настройва на
			<em>null</em> и изчиства една препратка към
			<em>key</em> обекта, но друга остава вътре в
			<em>set</em>. Все още можете да извлечете
			<em>key</em>, чрез превръщане на
			<em>set</em> в масив, използвайки оператора
			<em>spread</em> и достъп до първия елемент. Това работи добре за повечето програми, но понякога е по-добре референциите в
			<em>set</em> да изчезнат, когато и всички други референции изчезнат. Например, ако вашия JavaScript код се изпълнява в уеб-страница
			и искате да следите DOM елементите, които могат да бъдат премахнати от друг скрипт, вие не искате вашия код да държи последната
			референция към DOM елемента - (това се нарича загуба на памет).</p>
		<p>За да облекчи тези въпроси, ECMAScript 6 включва
			<em>Weak sets</em>, в които съхранява само нетрайни референции към обекти и не могат да съхраняват примитивни стойности. Нетрайна
			референция към обект е тази, която не възпрепятства
			<em>garbage collector</em> (събирача на боклук), ако това е единствената останала препратка.</p>
		<h3>Създаване на WeakSet</h3>
		<p>
			<em>Weak sets</em> се създават с помощта на
			<em>WeakSet</em> конструктора и имат
			<em>add(), has()</em> и
			<em>delete()</em> методи. Ето един пример, който използва всичките три:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> WeakSet(),
    key = {};

<span class="comment">// добавяне на обект към set</span>
set.add(key);

console.log(set.has(key));      // true

set.<span class="code">delete</span>(key);

console.log(set.has(key));      // false
	    	</pre>
			</dd>
		</dl>
		<p>Използването на
			<em>weak set</em> прилича на използването на редовен
			<em>set</em>. Можете да добавяте, премахвате и проверявате в
			<em>weak set</em>. Можете също така да изпращате
			<em>weak set</em> със стойности подадени, като
			<em>iterable</em> към конструктора:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> key1 = {},
    key2 = {},
    set = <span class="code">new</span> WeakSet([key1, key2]);

console.log(set.has(key1));     // true
console.log(set.has(key2));     // true
	    	</pre>
			</dd>
		</dl>
		<p>В този пример, масива се подава на
			<em>WeakSet</em> конструктора. Тъй като, този масив съдържа два обекта, тези обекти са добавени в
			<em>weak set</em>. Имайте в предвид, че ще бъде хвърлена грешка, ако масивът съдържа някакви стойности, които не са обект,
			тъй като
			<em>WeakSet</em> не може да приема примитивни стойности</p>
		<h3>Основни разлики между Set типовете</h3>
		<p>Най-голямата разлика между
			<em>weak sets</em> и редовен
			<em>sets</em> е нетрайната референция, държана към стойността на обекта. Ето един пример, който показва разликата:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">let</span> set = <span class="code">new</span> WeakSet(),
    key = {};

<span class="comment">// добавяне на обект към set</span>
set.add(key);

console.log(set.has(key));      // true

<span class="comment">// премахване на последната силна референция към ключа, като също я премахва и от weak set</span>
key = null;
	    	</pre>
			</dd>
		</dl>
		<p>След изпълнението на този код, референцията към
			<em>key</em> в
			<em>weak set</em> вече не е достъпна. Не е възможно да се провери неговото премахване, защото ще трябва една препратка към
			този обект да се подаде към
			<em>has()</em> метода. Това може да направи тестването на
			<em>weak sets</em> малко объркващо, но вие може да се доверите, че препратката е била правилно отстранена от JavaScript машината.</p>
		<p>От тези примери, може да се види, че
			<em>weak sets</em> споделя някои характеристики с редовния
			<em>sets</em>, но има някои основни разлики. Те са:</p>
		<dl>
			<dd>
				<ol>
					<li>В инстаницята на
						<em>Weak sets</em>, методите
						<em>add(), has()</em> и
						<em>delete()</em> хвърлят грешка, когато им се подава не-обект.</li>
					<li>
						<em>Weak set</em> не са
						<em>iterables</em> и следователно не могат да се използват в
						<em>for-of</em> цикъл.</li>
					<li>
						<em>Weak sets</em> не излагат никакви итератори (като
						<em>keys()</em> и
						<em>values()</em> методите), така че няма начин програмно да се определи съдържанието на
						<em>weak set</em>.</li>
					<li>
						<em>Weak sets</em> не разполагат с
						<em>forEach()</em> метод.</li>
					<li>
						<em>Weak sets</em> не разполагат с
						<em>size</em> свойство.</li>
				</ol>
			</dd>
		</dl>
		<p>Привидно ограничената функционалност на
			<em>weak sets</em> е необходима за правилно справяне с паметта. По принцип, ако имате нужда само да следите препратки към
			обекти, тогава трябва да използвате
			<em>weak set</em> вместо редовния
			<em>set</em>.</p>
		<p>
			<em>Sets</em> дават нов начин да се справим със списъци от стойности, но те не са полезни, когато трябва да се асоциира допълнителна
			информация с тези стойности. Ето защо, ECMAScript 6 добавя
			<em>maps</em>.</p>
		<h3>Maps в ECMAScript 6</h3>
		<p>ECMAScript 6
			<em>Map</em> типа е подреден списък от двойки ключ-стойност, където ключа и стойността могат да бъдат от всякакъв тип. Ключовата
			равностойност се определя с помощта на
			<em>Object.is()</em>, така че може да имате ключ от 5 и ключ от "5", нищо, че са различни видове. Това е доста по различно,
			отколкото при използване на обектни свойства, като ключове, които винаги коригираме в
			<em>string</em> стойности.</p>
		<p>Елементи се добавят към
			<em>maps</em> с помощта на
			<em>set()</em> метод и подаване на ключ и стойност за асоцииране с ключа. След това можем да извлечем стойност чрез подаване
			на ключа към
			<em>get()</em> метода. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> map = <span class="code">new</span> Map();
map.set("title", "Understanding ES6");
map.set("year", 2016);

console.log(map.get("title"));      // "Understanding ES6"
console.log(map.get("year"));       // 2016
	    	</pre>
			</dd>
		</dl>
		<p>В този пример, се съхраняват две двойки ключ-стойност. Ключа "title" съхранява
			<em>string</em>, докато ключа "year" съхранява номер. По-късно,
			<em>get()</em> метода извлича стойностите от двата ключа. Ако ключа не съществува в
			<em>map</em>,
			<em>get()</em> връща специалната стойност
			<em>undefined</em>.</p>
		<p>Можете също да използвате обекти, като ключове, нещо, което е невъзможно при използване на обектни свойства. Ето един пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> map = <span class="code">new</span> Map(),
    key1 = {},
    key2 = {};

map.set(key1, 5);
map.set(key2, 42);

console.log(map.get(key1));         // 5
console.log(map.get(key2));         // 42	    		
	    	</pre>
			</dd>
		</dl>
		<p>Този код използва обектите
			<em>key1</em> и
			<em>key2</em>, като ключове в
			<em>map</em> за съхраняване на две различни стойности. Тъй като тези ключове не са коригирани в друга форма, всеки обект се
			счита за уникален. Това ви позволява да свържете допълнителни данни към даден обект, без да променяте самия обект.</p>
		<h3>Map методи</h3>
		<p>
			<em>Maps</em> споделят няколко метода с
			<em>sets</em>. Така умишлено ви се дава възможност да взаимодействате с
			<em>maps</em> и
			<em>sets</em> по подобни начини. Има три метода на разположение за
			<em>maps</em> и
			<em>sets</em>:</p>
		<dl>
			<dd>
				<ol>
					<li>
						<strong>has(key) </strong>- показва дали даден ключ съществува в
						<em>map</em>
					</li>
					<li>
						<strong>delete(key) </strong>- изтрива ключ и свързаната с него стойност от
						<em>map</em>
					</li>
					<li>
						<strong>clear() </strong>- изтрива всички ключове и стойности от
						<em>map</em>
					</li>
				</ol>
			</dd>
		</dl>
		<p>В допълнение,
			<em>maps</em> имат
			<em>size</em> свойство, което показва, колко двойки ключ-стойности съдържа. Този код използва трите метода и
			<em>size</em> по различни начини:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> map = <span class="code">new</span> Map();
map.set("name", "Nicholas");
map.set("age", 25);

console.log(map.size);          // 2

console.log(map.has("name"));   // true
console.log(map.get("name"));   // "Nicholas"

console.log(map.has("age"));    // true
console.log(map.get("age"));    // 25

map.<span class="code">delete</span>("name");
console.log(map.has("name"));   // false
console.log(map.get("name"));   // undefined
console.log(map.size);          // 1

map.clear();
console.log(map.has("name"));   // false
console.log(map.get("name"));   // undefined
console.log(map.has("age"));    // false
console.log(map.get("age"));    // undefined
console.log(map.size);          // 0
	    	</pre>
			</dd>
		</dl>
		<p>Както при
			<em>sets, size</em> свойството винаги съдържа броя на двойките ключ-стойност в
			<em>map</em>. Този пример започва с два ключа "name" и "age", така че
			<em>has()</em> връща
			<em>true</em>, когато му е подаден ключ. След това ключа "name" се отстранява с помощта на
			<em>delete()</em> метода, така че,
			<em>has()</em> връща
			<em>false</em>, когато му е подадено "name" и
			<em>size</em> свойството показва един елемент по-малко. Метода
			<em>clear()</em> след това премахва останалите ключове и
			<em>has()</em> връща
			<em>false</em> за всички ключове и
			<em>size</em> е 0.</p>
		<p>Метода
			<em>clear()</em> е бърз начин за премахване на голямо количество данни от
			<em>map</em>, но има и начин за добавяне на много данни в
			<em>map</em> на един път.</p>
		<h3>Map инициализация</h3>
		<p>Също като
			<em>sets</em>, можем да инициализираме
			<em>map</em> с подаване на масив от данни към
			<em>Map</em> конструктора. Всеки елемент в масива, трябва да бъде сам по себе си масив, където първия елемент е ключът, а
			втория съответната стойност. Целия
			<em>map</em>, следователно е масив от тези два под-масива, например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> map = <span class="code">new</span> Map([ ["name", "Nicholas"], ["age", 25]]);

console.log(map.has("name"));   // true
console.log(map.get("name"));   // "Nicholas"
console.log(map.has("age"));    // true
console.log(map.get("age"));    // 25
console.log(map.size);          // 2
	    	</pre>
			</dd>
		</dl>
		<p>Ключовете "name" и "age" се добавят в
			<em>map</em> чрез инициализация в конструктора. Понеже масив от масиви изглежда малко странно, не е необходимо да си представяме
			точно ключове, тъй като те могат да бъдат всякакъв тип данни. Съхраняването на тези ключове в масив е единствения начин
			да се гарантира, че те не са коригирани в друг тип данни, преди да бъдат съхранени в
			<em>map</em>.</p>
		<h3>Метода forEach за Maps</h3>
		<p>Метода
			<em>forEach()</em> за
			<em>maps</em> е подобен на
			<em>forEach()</em> за
			<em>sets</em> и масиви, който приема функция за обратно извикване, която получава три аргумента:</p>
		<dl>
			<dd>
				<ol>
					<li>Стойността от следващата позиция в
						<em>map</em>
					</li>
					<li>Ключът за тази стойност</li>
					<li>
						<em>Map</em> от който се чете стойността</li>
				</ol>
			</dd>
		</dl>
		<p>Аргументите за обратно извикване по-точно съответстват на
			<em>forEach()</em> поведението за масиви, където първия аргумент е стойността, а втория е ключът (съответстващ на цифров индекс
			в масива). Ето един пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> map = <span class="code">new</span> Map([ ["name", "Nicholas"], ["age", 25]]);

map.forEach(<span class="code">function</span>(value, key, ownerMap) {
    console.log(key + " " + value);
    console.log(ownerMap === map);
});	
	    	</pre>
			</dd>
		</dl>
		<p>Функцията за обратно извикване на
			<em>forEach()</em> извежда информацията, която се предава в нея,
			<em>value</em> и
			<em>key</em> се извеждат директно, a
			<em>ownerMap</em> се сравнява с
			<em>map</em> за да покаже, че стойностите са еквивалентни. Това е изхода:</p>
		<dl>
			<dd>
				<pre class="highlight">
	    		<p>name Nicholas <br>true <br>age 25 <br>true</p>
	    	</pre>
			</dd>
		</dl>
		<p>Функцията за обратно извикване на
			<em>forEach()</em> получава всяка двойка ключ-стойност в реда на тяхното вмъкване в
			<em>map</em>. Това е малко по-различно от извикването на
			<em>forEach()</em> за масиви, където обратното извикване получава всеки елемент в реда на цифровия индекс.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Можете също така да представите втори аргумент на
					<em>forEach()</em> за да уточните
					<em>this</em> стойноста вътре във функцията за обратно извикване. Това поведение е същото, както при
					<em>set</em> версията на
					<em>forEach()</em> метода.</strong>
			</dd>
		</dl>
		<h3>Weak Maps</h3>
		<p>
			<em>Weak maps</em> са
			<em>maps</em>, както
			<em>weak sets</em> са
			<em>sets</em>, което е начин за съхраняване на нетрайни референции към обект. В
			<em>weak maps</em>, всеки ключ трябва да бъде обект (и ще бъде хвърлена грешка ако се опитате да използвате ключ не-обект)
			и тези референции към обекти се събират нетрайно, така че да не са в противоречие с
			<em>garbage collector</em>. Когато няма други препратки към
			<em>weak map</em> ключа извън
			<em>weak map</em>, двойката ключ-стойност се изважда от
			<em>weak map</em>.</p>
		<p>Най-полезното място за използване на
			<em>weak maps</em> е при създаването на обект, свързан с конкретен DOM елемент в уеб-страница. Например, някои JavaScript
			библиотеки за уеб-страници поддържат един потребителски обект за всеки DOM елемент, който е посочен в библиотеката и мапнат
			се съхранява вътрешно в кеша на обектите.</p>
		<p>Най-трудната част от този подход е да се определи, кога DOM елемента вече не съществува в уеб-страницата, така че библиотеката
			да може да премахне свързания с нея обект. В противен случай, библиотеката ще задържи препратката на DOM елемента и по
			този начин ще предизвика загуба на памет. Проследяването на DOM елементи със
			<em>weak map</em> все пак позволява на библиотеката да свърже един потребителски обект с всеки DOM елемент и след това автоматично
			да унищожи този обект, когато DOM елемента не съществува вече.</p>
		<dl>
			<dd></dd>
		</dl>
		<div class="info">
			<img src="./img/info.jpg" alt="info">
		</div>
		<strong>Важно е да се отбележи, че само
			<em>weak map</em> ключове, а не
			<em>weak map</em> стойности, са
			<em>weak</em> референции. Ако един обект се съхранява, като
			<em>weak map</em> стойност, това ще попречи на
			<em>garbage collector</em>, ако всички други референции са премахнати.</strong>
		</dd>
		</dl>
		<h3>Използване на Weak Maps</h3>
		<p>В ECMAScript 6
			<em>WeakMap</em> типа е неподреден списък от двойки ключ-стойност, където ключа трябва да бъде не нулев обект, а стойността
			може да бъде всякакъв тип. Интерфейса за
			<em>WeakMap</em> е много подобен на този за
			<em>Map</em> в това, че
			<em>set()</em> и
			<em>get()</em> се използват за добавяне и извличане на данни съответно.</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> map = <span class="code">new</span> WeakMap(),
    element = <span class="code">document</span>.querySelector(".element");

map.set(element, "Original");

<span class="code">let</span> value = map.get(element);
console.log(value);             // "Original"

<span class="comment">// премахване на елемент</span>
element.parentNode.removeChild(element);
element = null;

<span class="comment">// the weak map е празен в този момент</span>
	    	</pre>
			</dd>
		</dl>
		<p>В този пример, се съхранява една двойка ключ-стойност. Ключът
			<em>element</em> е DOM елемент, който се използва за съхраняване на съответната
			<em>string</em> стойност. След това тази стойност се извлича чрез подаване на DOM елемента към
			<em>get()</em> метода. Когато DOM елемента след това се премахне от документа и променливата референция е настроена на
			<em>null</em>, тогава данните се отстраняват от
			<em>weak map</em>.</p>
		<p>Подобно на
			<em>weak sets</em>, няма начин да се провери дали
			<em>weak map</em> е празен, тъй като няма
			<em>size</em> свойство. Понеже няма останали препратки към ключа, не можете да използвате
			<em>get()</em> метода да се опита да извлече стойността.
			<em>Weak map</em> е отрязал достъпа до стойността на този ключ и когато
			<em>garbage collector</em> заработи, паметта заета от стойността ще бъде освободена.</p>
		<h3>Инициализация на Weak Map</h3>
		<p>
			<em>Weak maps</em> могат да се инициализират по същия начин, като редовните
			<em>maps</em>: чрез подаване на масив от масиви към
			<em>WeakMap</em> конструктора. Точно като инициализацията на
			<em>map</em>, всеки елемент в масива трябва да бъде сам по себе си масив с два елемента, където първият елемент е ключът (не
			нулев обект) и втория елемент е стойността (всички типове данни). Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> key1 = {},
    key2 = {},
    map = <span class="code">new</span> WeakMap([ [key1, "Hello"], [key2, 42]]);

console.log(map.has(key1));     // true
console.log(map.get(key1));     // "Hello"
console.log(map.has(key2));     // true
console.log(map.get(key2));     // 42
	    	</pre>
			</dd>
		</dl>
		<p>Обектите
			<em>key1</em> и
			<em>key2</em> се използват, като ключове в
			<em>weak map</em> и те могат да бъдат достъпни с
			<em>get()</em> и
			<em>has()</em> методите. Грешка се хвърля, ако конструктора на
			<em>WeakMap</em> получи ключ, който не е обект за някоя от двойките ключ-стойност.</p>
		<h3>Weak Map методи</h3>
		<p>
			<em>Weak maps</em> имат само два допълнителни метода на разположение, за да взаимодействат с двойките ключ-стойност. Това
			са
			<em>has()</em> метод за определяне дали съществува даден ключ в
			<em>map</em> и
			<em>delete()</em> метод за премахване на специфична двойка ключ-стойност. Няма
			<em>clear()</em> метод, защото това би изисквало изброяване на ключове и както при
			<em>weak sets</em>, това също не е възможно за
			<em>weak maps</em>. Този пример използва
			<em>has()</em> и
			<em>delete()</em> методи:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> map = <span class="code">new</span> WeakMap(),
    element = <span class="code">document</span>.querySelector(".element");

map.set(element, "Original");

console.log(map.has(element));   // true
console.log(map.get(element));   // "Original"

map.<span class="code">delete</span>(element);
console.log(map.has(element));   // false
console.log(map.get(element));   // undefined
	    	</pre>
			</dd>
		</dl>
		<p>Тука, DOM елемента отново е използван, като ключ в
			<em>weak map</em>. Метода
			<em>has()</em> е подходящ за проверка, за да се види дали референцията в момента се използва, като ключ в
			<em>weak map</em>. Имайте в предвид, че това работи само, когато имате не-нулева референция на ключ. Ключът насилствено е
			премахнат от
			<em>weak map</em> с помощта на
			<em>delete()</em> метода, в която точка
			<em>has()</em> връща
			<em>false</em> и
			<em>get()</em> връща
			<em>undefined</em>.</p>
		<h3>Private обект данни</h3>
		<p>Докато повечето програмисти обмислят основната употреба на случаи на
			<em>weak maps</em>, за асоцииране на данни с DOM елементи, има много други възможни употреби (и няма съмнение, че има някои,
			които все още предстоят да бъдат открити). Една практическа употреба на
			<em>weak maps</em> е да съхранява данни, които са private инстанции на обект. Всички обектни свойства са публични в ECMAScript
			6 и ще трябва да използвате някои творчески идеи, да направите данните достъпни за обекти, но не достъп до всичко. Да
			разгледаме следващия пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> Person(name) {
    this._name = name;
}

Person.prototype.getName = <span class="code">function</span>() {
    <span class="code">return this</span>._name;
};
	    	</pre>
			</dd>
		</dl>
		<p>Този код използва общата конвенция от водеща долна черта, за да покаже, че този обект се счита за private и не трябва да
			бъде променян извън инстанцията на обекта. Намерението е да се използва
			<em>getName()</em> за да прочете
			<em>this._name</em> и да не позволи на тази стойност да бъде променяна. Обаче, няма нищо което да стои на пътя на някой да
			пише на
			<em>_name</em> свойството, така че да може да бъде презаписано умишлено или случайно.</p>
		<p>Използвайки ECMAScript 5, беше възможно да се доближим до истински private данни, чрез създаване на обект с помощта на модел,
			като този например:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">let</span> Person = (<span class="code">function</span>() {

    <span class="code">let</span> privateData = {},
        privateId = 0;

    <span class="code">function</span> Person(name) {
        <span class="code">Object</span>.defineProperty(<span class="code">this</span>, "_id", { value: privateId++ });

        privateData[<span class="code">this</span>._id] = {
            name: name
        };
    }

    Person.prototype.getName = <span class="code">function</span>() {
        <span class="code">return</span> privateData[<span class="code">this</span>._id].name;
    };

    <span class="code">return</span> Person;
}());	
	    	</pre>
			</dd>
		</dl>
		<p>Този пример увива дефиницията на
			<em>Person</em> с IIFE , която съдържа две private променливи
			<em>privateData</em> и
			<em>privateId</em>. Обекта
			<em>privateData</em> съхранява лична информация за всеки отделен случай, докато
			<em>unique ID</em> се използва за генериране на уникално
			<em>ID</em> за всеки отделен случай. Когато
			<em>Person</em> конструктора се извика, се добавя свойството
			<em>_id</em>, така че да е
			<em>nonenumerable, nonconfigurable</em> и
			<em>nonwritable</em>.</p>
		<p>След това, се прави запис в
			<em>privateData</em> обекта, който съответства на
			<em>ID</em> за инстанция на обект, това е когато
			<em>name</em> се съхранява. По-късно в
			<em>getName()</em> функцията, името може да бъде извлечено с помоща на
			<em>this._id</em>, като ключ в
			<em>privateData</em>. Понеже
			<em>privateData</em> не е достъпна извън IIFE, актуалните данни са в безопасност, въпреки че
			<em>this._id</em> е изложено публично.</p>
		<p>Големият проблем при този подход е, че данните в
			<em>privateData</em> никога не изчезват, защото няма начин да се знае, кога е унищожена една обектна инстанция, което означава,
			че обекта
			<em>privateData</em> винаги ще съдържа допълнителни данни. Този проблем може да бъде решен, чрез използване на
			<em>weak map</em>:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> Person = (<span class="code">function</span>() {

    <span class="code">let</span> privateData = <span class="code">new</span> WeakMap();

    <span class="code">function</span> Person(name) {
        privateData.set(<span class="code">this</span>, { name: name });
    }

    Person.prototype.getName = <span class="code">function</span>() {
        return privateData.get(<span class="code">this</span>).name;
    };

    <span class="code">return</span> Person;
}());	
	    	</pre>
			</dd>
		</dl>
		<p>Тази версия на кода използва
			<em>weak map</em> за private данни, вместо обект. Тъй като, самата инстанция на
			<em>Person</em> обектa може да се използва, като ключ, няма нужда да следите отделно
			<em>ID</em>. Когато
			<em>Person</em> конструктора се извика, се прави нов запис в
			<em>weak map</em> с ключ
			<em>this</em> и стойност на даден обект, който съдържа лична информация. В този случай, тази стойност е обект, съдържащ само
			<em>name</em>. Функцията
			<em>getName()</em> извлича тази лична информация, чрез подаване на
			<em>this</em> към
			<em>privateData.get()</em> метода, който извлича стойността на обекта и има достъп до свойството
			<em>name</em>. По този начин личната информация се пази в тайна и ще бъде унищожена, когато инстанцията на свързания с нея
			обект е унищожена.</p>
		<h3>Използване и ограничения на weak map</h3>
		<p>При вземането на решение, дали да използвате
			<em>weak map</em> или редовен
			<em>map</em>, основният мотив е дали искате да използвате само ключове обекти. Всеки път, когато вие ще използвате само ключове
			обекти най-добрия избор е
			<em>weak map</em>. Това ще ви позволи да оптимизирате използването на паметта и да избегнете загуба на памет, като гарантирате,
			че допълнителните данни не се съхраняват на около след, като вече не са достъпни.</p>
		<p>Имайте в предвид, че
			<em>weak maps</em> дават много малка видимост в съдържанието им, така че не можете да използвате
			<em>forEach()</em>,
			<em>size</em> или
			<em>clear()</em> за управление на елементите. Ако имате нужда от някои възможности за инспекция, тогава редовния
			<em>maps</em> е по-добрия избор. Само не забравяйте да държите под око използването на паметта.</p>
		<p>Разбира се, ако искате да използвате ключове не-обекти, тогава редовния
			<em>maps</em> е вашия избор.</p>
	</article>
	<footer>
		<h3>Обобщение</h3>
		<p>ECMAScript 6 официално въвежда
			<em>sets</em> и
			<em>maps</em> в езика. Преди това, програмистите често използват обекти за да имитират
			<em>sets</em> и
			<em>maps</em>, което често работи с проблеми поради ограниченията, свързани с обектните свойствата.</p>
		<p>
			<em>Sets</em> са подредени списъци на уникални стойности. Стойностите се считат за уникални, ако те не са еквивалентни, съгласно
			<em>Object.is()</em> метода.
			<em>Sets</em> автоматично премахва дублиращите се стойности, така че може да се използва за филтриране на масив за дубликати
			и връщане на резултата.
			<em>Sets</em> не са подкласове на масиви, така че няма случаен достъп до техните стойности. Вместо това може да използвате
			<em>has()</em> метод, за да определите дали една стойност се съдържа в
			<em>set</em> и
			<em>size</em> свойство, за да разберете броя на стойностите включени в
			<em>set</em>.
			<em>Set</em> типа има също така
			<em>forEach()</em> метод за обработка на всяка зададена стойност.</p>
		<p>
			<em>Weak sets</em> са специален тип
			<em>set</em>, който може да съдържа само обекти. Обектите се съхраняват с нетрайни референции, което означава, че даден елемент
			в
			<em>weak set</em> няма да блокира
			<em>garbage collection</em>, ако този елемент е единствената останала препратка към даден обект. Не възможно да се инспектира
			<em>weak set</em> съдържанието поради сложността на управление на паметта, така че най-добре да ги използвате само за проследяване
			на обекти, които трябва да бъдат групирани заедно.</p>
		<p>
			<em>Maps</em> са подредени двойки ключ-стойности, като ключа може да бъде всеки тип данни. Подобно на
			<em>sets</em>, дублираните ключове се определят от
			<em>Object.is()</em> метода, което означава, че може да има цифров ключ 5 и
			<em>string</em> "5", като два отделни ключа. Всеки тип данни може да се използва, като стойност за асоцииране към ключ, използвайки
			<em>set()</em> метода и тази стойност по-късно може да бъде извлечена чрез използване на
			<em>get()</em> метода.
			<em>Maps</em> също имат
			<em>size</em> свойство и
			<em>forEach()</em> метод, за да се даде възможност за по-лесен достъп.</p>
		<p>
			<em>Weak maps</em> са специален вид
			<em>map</em>, който може да има само ключове обекти. Както и при
			<em>weak sets</em>, тези референции към ключове обекти са нетрайни и не пречат на
			<em>garbage collection</em>, когато това е единствената останала референция към даден обект. Когато ключа е изчистен от
			<em>garbage collection</em>, свързаната с него стойност се премахва от
			<em>weak map</em>. Този аспект на управление на паметта прави
			<em>weak maps</em> уникално подходящи за съгласуване на допълнителна информация с обекти, чиито жизнен цикъл се управлява
			извън кода за достъп до тях.</p>
	</footer>
	<nav>
		<a href="./06_simbols.html" title="previous chapter">◀</a>
		<a href="./index.html" title="cover">◆</a>
		<a href="08_iterators_and_generators.html" title="next chapter">▶</a>
	</nav>
</body>

</html>