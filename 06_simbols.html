<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Simbols :: Understanding ECMAScript 6</title>
	<link rel="stylesheet" href="font.css">
</head>

<body>
	<nav>
		<a href="./05_destructured.html" title="previous chapter">◀</a>
		<a href="./index.html" title="cover">◆</a>
		<a href="./07_set_and_map.html" title="next chapter">▶</a>
	</nav>

	<header id="header" class="">
		<h1>
			<div class="head-num">Глава 6</div><em>Simbols</em> и <em>simbol</em> свойства</h1>
		<p><em>Simbols</em> са примитивен тип въведен в ECMAScript 6, присъединявайки се към съществуващите примитивни типове:
			<em>strings, numbers, booleans, null</em> и
			<em>undefined</em>. <em>Simbols</em> поставят началото на начин за създаване на частни членове на обекти, характеристика, която JavaScript
			програмистите отдавна очакваха. Преди <em>simbols</em>, всяко свойство с име
			<em>string</em> е лесен начин за достъп, независимо от неяснотата на името и функцията "private names" имаше за цел да позволи
			на програмистите да създадат
			<em>non-string</em> свойство на имената. Но по този начин нормалните техники за откриване на тези частни имена няма да работят.</p>
		<p>Предложението за частни имена в крайна сметка се превърна в ECMAScript 6 <em>simbols</em> и тази глава ще ви научи как да използвате
			<em>simbols</em> ефективно. Макар подробностите по изпълнението да остават същите (
			<em>non-string</em> стойности за свойство на имената), целта за неприкосновенност намаля. Вместо това, свойствата на <em>simbols</em>
			се категоризират отделно от други обектни свойства.</p>

	</header>
	<!-- /header -->
	<article>
		<h3>Създаване на <em>simbols</em></h3>
		<p> <em>Simbols</em> са уникални сред JavaScript примитивните типове, с това че не разполагат с литерална форма, като
			<em>true</em> за булев тип или 42 за числа. Можете да създадете <em>simbol</em> с помощта на глобалната
			<em>Symbol</em> функция, както в този пример:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> firstName = Symbol();
<span class="code">let</span> person = {};

person[firstName] = "Nicholas";
console.log(person[firstName]);     // "Nicholas"
	 		</pre>
			</dd>
		</dl>
		<p>В този пример <em>simbol</em>
			<em>firstName</em> е създаден и се използва за присвояване от новото свойство на
			<em>person</em> обекта. Този <em>simbol</em> трябва да се използва всеки път, когато искате да получите достъп до същото свойство.
			Именуването на променливата на <em>simbol</em> подходящо е добра идея, така че лесно да разберем какво представлява <em>simbol</em>.</p>
		<dl>
			<dd>
				<div class="worning">
					<img src="./img/worning.jpg" alt="worning">
				</div>
				<strong>Тъй като <em>simbols</em> са примитивни стойности, извикването на
					<em>new Symbol()</em> хвърля грешка. Възможно е да се създаде инстанция на
					<em>Symbol</em> чрез
					<em>new Object(yourSymbol)</em>, но не е ясно, кога това би било полезно.</strong>
			</dd>
		</dl>
		<p>Функцията
			<em>Symbol</em> приема незадължителен аргумент с описанието на <em>simbol</em>. Самото описание не може да се използва за достъп до
			свойството, но се използва с цел на отстраняване на грешки. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> firstName = Symbol("first name");
<span class="code">let</span> person = {};

person[firstName] = "Nicholas";

console.log("first name" <span class="code">in</span> person);    // false
console.log(person[firstName]);         // "Nicholas"
console.log(firstName);                 // "Symbol(first name)"
	 		</pre>
			</dd>
		</dl>
		<p>Описанието на <em>simbol</em> се съхранява във вътрешно свойство, наречено [[Description]]. Това свойство се чете, когато метода
			<em>toString()</em> за <em>simbols</em> се извика пряко или косвено. В този пример,
			<em>console.log</em> извиква косвено <em>simbol</em> метод
			<em>toString</em> върху
			<em>firstName</em>, така че описанието да бъде отпечатано на козолата. Няма друг възможен начин за достъп до [[Description]]
			директно с код. Затова е препоръчително винаги да се предостави описание за четене на <em>simbol</em>, така грешките се отстраняват
			по лесно.</p>
		<div class="aside">
			<h3>Идентифициране на <em>simbols</em></h3>
			<p>Тъй като, <em>simbols</em>те са примитивни стойности, можете да използвате оператора
				<em>typeof</em>, за да определите дали дадена променлива съдържа <em>simbol</em>. ECMAScript 6 разширява
				<em>typeof</em> да връща "symbol", когато се използва за <em>simbol</em>. Например:</p>
			<pre class="highlight">
<span class="code">let</span> symbol = Symbol("test symbol");
console.log(<span class="code">typeof</span> symbol);    // "symbol"
	 		</pre>
			<p>Докато има и други косвени начини за определяне дали дадена променлива е <em>simbol</em>,
				<em>typeof</em> е най-точен и предпочитан начин затова.</p>
		</div>
		<h3>Използване на <em>simbols</em></h3>
		<p>Можете да използвате <em>simbols</em> навсякъде, където трябва да изчислявате име на свойство. Вече виждяхте използването на скоби
			нотация със <em>simbols</em> в тази глава, но можете да използвате <em>simbols</em> за изчисляване на имена на свойства за обекти, както
			с
			<em>Object.defineProperty()</em> така и с
			<em>Object.defineProperties()</em>, като това:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> firstName = Symbol("first name");
<span class="comment">// използва изчисляване на свойство за обект литерал </span>
<span class="code">let</span> person = {
    [firstName]: "Nicholas"
};

<span class="comment">// прави свойството само за четене</span>
<span class="code">Object</span>.defineProperty(person, firstName, { writable: <span class="code">false</span>  });

<span class="code">let</span> lastName = Symbol("last name");

<span class="code">Object</span>.defineProperties(person, {
    [lastName]: {
        value: "Zakas",
        writable: <span class="code">false</span> 
    }
});

console.log(person[firstName]);     // "Nicholas"
console.log(person[lastName]);      // "Zakas"
	 		</pre>
			</dd>
		</dl>
		<p>Този пример първо използва изчисляване на свойство за обект, за създаване на
			<em>firstName</em> <em>simbol</em> свойството. Свойството е създадено не номерирано, за разлика от изчислените свойства създадени с
			помощта на
			<em>nonsymbol</em> имена. Следващия ред, прави свойството само за четене. По-късно, свойството на <em>simbol</em> само за четене
			<em>lastName</em> е създадено с помощта на
			<em>Object.defineProperties()</em> метода. Изчисляването на свойство за обект се използва отново, само че този път е част
			от втория аргумент на
			<em>Object.defineProperties()</em>.</p>
		<p>Докато <em>simbols</em> могат да бъдат използвани на всяко място, където е позволено изчисляване на имена за свойства, трябва
			да има система за споделяне на тези <em>simbols</em> между различните части от код, за да ги използваме ефективно.</p>
		<h3>Споделяне на <em>simbols</em></h3>
		<p>Може да откриете, че искате различни части от вашия код да използват едни и същи <em>simbols</em>. Да предположим, че имате два
			различни типа обекти във вашето приложение, които трябва да използват едно и също <em>simbol</em> свойство, да представлява уникален
			идентификатор. Следенето на <em>simbols</em> във файлове или големи база код данни, може да бъде трудно и податливо на грешки.
			Ето защо ECMAScript 6 осигурява глобален регистър на <em>simbols</em>, до който може да получите достъп по всяко време.</p>
		<p>Когато искате да създадете <em>simbol</em>, който да бъде споделен, трябва да използвате
			<em>Symbol.for()</em> вместо
			<em>Symbol()</em>. Метода
			<em>Symbol.for()</em> приема един единствен параметър, който е
			<em>string</em> идентификатор за <em>simbol</em>, който искате да създадете. Този параметър се използва, и като описание на <em>simbol</em>.
			Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> uid = Symbol.<span class="code">for</span>("uid");
<span class="code">let</span> object = {};

object[uid] = "12345";

console.log(object[uid]);       // "12345"
console.log(uid);               // "Symbol(uid)"
	    	</pre>
			</dd>
		</dl>
		<p>Метода
			<em>Symbol.for()</em> първо търси в глобалния регистър за <em>simbols</em>, за да види дали <em>simbol</em> с ключ "uid" съществува. Ако е така,
			метода връща съществуващия <em>simbol</em>. Ако няма съществуващ такъв <em>simbol</em>, тогава създава нов <em>simbol</em> и го регистрира в глобалния
			регистър за <em>simbols</em>, използвайки указания ключ. След това връща новия <em>simbol</em>. Това означава, че следващите извиквания
			на
			<em>Symbol.for()</em> ще използват един и същи ключ за връщане на същия <em>simbol</em>:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> uid = Symbol.<span class="code">for</span>("uid");
<span class="code">let</span> object = {
    [uid]: "12345"
};

console.log(object[uid]);       // "12345"
console.log(uid);               // "Symbol(uid)"

<span class="code">let</span> uid2 = Symbol.<span class="code">for</span>("uid");

console.log(uid === uid2);      // true
console.log(object[uid2]);      // "12345"
console.log(uid2);              // "Symbol(uid)"
	    		</pre>
			</dd>
		</dl>
		<p>В този пример,
			<em>uid</em> и
			<em>uid2</em> съдържат един и същи <em>simbol</em>, така че могат да се използват, като взаимозаменяеми. Първото извикване на
			<em>Symbol.for()</em> създава <em>simbol</em>, а второто извлича <em>simbol</em> от регистъра за глобални <em>simbols</em>.</p>
		<p>Друг уникален аспект на споделените <em>simbols</em> е, че можете да извлечете ключа, свързан със <em>simbol</em> в регистъра за глобални
			<em>simbols</em> с помощта на
			<em>Symbol.keyFor()</em>, например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> uid = Symbol.<span class="code">for</span>("uid");
console.log(Symbol.keyFor(uid));    // "uid"

<span class="code">let</span> uid2 = Symbol.<span class="code">for</span>("uid");
console.log(Symbol.keyFor(uid2));   // "uid"

<span class="code">let</span> uid3 = Symbol("uid");
console.log(Symbol.keyFor(uid3));   // undefined
	    	</pre>
			</dd>
		</dl>
		<p>Забележете, че и двете
			<em>uid</em> и
			<em>uid2</em> връщат ключ "uid". <em>Simbol</em>
			<em>uid3</em> не съществува в регистъра за глобални <em>simbols</em>, така че няма ключ свързан с него и
			<em>Symbol.keyFor()</em> връща
			<em>undefined</em>.</p>
		<dl>
			<dd>
				<div class="worning">
					<img src="./img/worning.jpg" alt="worning">
				</div>
				<strong>Регистърът за глобални <em>simbols</em> е споделена среда, точно както глобалния обхват. Така че, не могат да се правят предположения,
					какво присъства или не в тази среда. Вие трябва да използвате пространството на имена за ключове на <em>simbols</em>, за да се
					намали вероятноста от съвпадения при използване на компонентите от трета страна. Например, jQuery кода може да използва
					"jquery.", за да сложи префикс на всички ключове, като "jquery.element" и други подобни.</strong>
			</dd>
		</dl>
		<h3><em>Simbol</em> коригиране на типа</h3>
		<p>Коригирането на типа е значителна част от JavaScript и има много гъвкаво отношение към способноста на езика да коригира
			един тип данни в друг. <em>Simbols</em>, обаче не са толкова гъвкави, когато става въпрос за коригиране, защото не съществува
			логическа еквивалентност на <em>simbol</em> в другите типове. По-конкретно, <em>simbols</em> не могат да бъдат коригирани в
			<em>strings</em> или
			<em>numbers</em>, така че не могат случайно да се използват, като свойства, които в противен случай биха се очаквали да се
			държат, като <em>simbols</em>.</p>
		<p>Примерите в тази глава използват
			<em>console.log()</em> за да покажат на изхода, че <em>simbol</em> работи, защото
			<em>console.log()</em> извиква
			<em>String()</em> върху <em>simbols</em>, за да създаде полезен резултат. Можете да използвате
			<em>String()</em> директно за да получите същия резултат. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> uid = Symbol.<span class="code">for</span>("uid"),
    desc = <span class="code">String</span>(uid);

console.log(desc);              // "Symbol(uid)"
	    	</pre>
			</dd>
		</dl>
		<p>Функцията
			<em>String()</em> извиква
			<em>uid.toString()</em> и връща описание на <em>simbol</em> в
			<em>string</em>. Ако се опитате да свържете директно <em>simbol</em> със
			<em>string</em>, ще бъде хвърлена грешка:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> uid = Symbol.<span class="code">for</span>("uid"),
    desc = uid + "";            // error!
	    	</pre>
			</dd>
		</dl>
		<p>Конкатенацията на
			<em>uid</em> с празен
			<em>string</em> изисква, първо
			<em>uid</em> да се коригира в
			<em>string</em>. Грешка се хвърля, когато е открито коригиране, предотвратявайки използването му по този начин.</p>
		<p>По същия начин, не може да се коригира <em>simbol</em> в номер. Всички математически оператори предизвикват грешка, когато се прилагат
			за <em>simbol</em>. Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> uid = Symbol.<span class="code">for</span>("uid"),
    sum = uid / 1;            // error!
	    	</pre>
			</dd>
		</dl>
		<p>Този пример се опитва да раздели <em>simbol</em> с 1, което води до грешка. Грешка се хвърля независимо от използвания математически
			оператор (логическите оператори не хвърлят грешка, защото всички <em>simbols</em> се считат за еквивалентни на
			<em>true</em>, точно както всяка друга не-празна стойност в JavaScript).</p>

		<h3>Извличане на <em>simbol</em> от обект</h3>
		<p>Методите
			<em>Object.keys()</em> и
			<em>Object.getOwnPropertyNames()</em> могат да извличат всички имена на свойства в даден обект. Първия метод връща всички
			номерирани имена на свойства, а втория връща всички свойства, независимо от номерирането. Нито един от тези методи, не
			връща свойства на <em>simbol</em>, за да се запази тяхната ECMAScript 5 функционалност. Вместо тях е добавен метода
			<em>Object.getOwnPropertySymbols()</em> в ECMAScript 6, който позволява извличане на свойства на <em>simbols</em> от даден обект.</p>
		<p>Върнатата стойност от
			<em>Object.getOwnPropertySymbols()</em> е масив от собствени <em>simbol</em> свойства, например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> uid = Symbol.<span class="code">for</span>("uid");
<span class="code">let</span> object = {
    [uid]: "12345"
};

<span class="code">let</span> symbols = Object.getOwnPropertySymbols(object);

console.log(symbols.length);        // 1
console.log(symbols[0]);            // "Symbol(uid)"
console.log(object[symbols[0]]);    // "12345"
	    	</pre>
			</dd>
		</dl>
		<p>В този код,
			<em>object</em> има едно единствено <em>simbol</em> свойство, наречено
			<em>uid</em>. Върнатия масив от
			<em>Object.getOwnPropertySymbols()</em> съдържа само този <em>simbol</em>.</p>
		<p>Всички обекти започват с нулеви <em>simbol</em> свойства, но обектите могат да наследяват <em>simbol</em> качества от своите прототипи.
			ECMAScript 6 предварително настройва няколко такива свойства, с помощта на
			<em>well-known</em> <em>simbols</em>.</p>
		<h3>Излагане на вътрешни операции с Well-Known simbols</h3>
		<p>Важна тема за ECMAScript 5 е да изложи и определи някои "магически" части на JavaScript - частите, които програмистите
			не могат да подражават в момента. ECMAScript 6 следва тази традиция чрез излагане на повече от преди на вътрешната логика
			на езика, главно чрез използване на прототипа на <em>simbol</em> свойства, за определяне на основното поведение на някои обекти.</p>
		<p>ECMAScript 6 включва предварително зададени <em>simbols</em>, наречени
			<em>well-known</em> <em>simbols</em>, които представляват общо поведение в JavaScript и които преди това са били обмисляни само за
			вътрешни операции. Всеки
			<em>well-known</em> <em>simbol</em> е представен от свойство на
			<em>Symbol</em> обекта, например като
			<em>Symbol.create</em>
		</p>
		<p>
			<em>Well-known</em> <em>simbols</em> са:</p>
		<dl>
			<dd>
				<ul>
					<li>
						<strong>Symbol.hasInstance</strong> - метод използван от
						<em>instanceof</em> да определи наследството на даден обект.</li>
					<li>
						<strong>Symbol.isConcatSpreadable</strong> - булева стойност, показваща дали употребата на
						<em>Array.prototype.concat()</em> ще изглади елементите на колекцията, ако колекцията се подаде, като параметър на
						<em>Array.prototype.concat()</em>.</li>
					<li>
						<strong>Symbol.iterator</strong> - метод, който връща iterator (итераторите са обхванати в
						<a href="08_iterators_and_generators.html">Глава 8</a> - Iterators и Generators).</li>
					<li>
						<strong>Symbol.match</strong> - метод използван от
						<em>String.prototype.match()</em> за сравняване на
						<em>strings</em>.</li>
					<li>
						<strong>Symbol.replace</strong> - метод използван от
						<em>String.prototype.replace()</em> за заместване на
						<em>substrings</em>.</li>
					<li>
						<strong>Symbol.search </strong> - метод използван от
						<em>String.prototype.search()</em> за намиране на
						<em>substrings</em>.</li>
					<li>
						<strong>Symbol.species </strong> - конструктор за правене на производни обекти (производни обекти са обхванати в
						<a href="09_classes.html">Глава 9</a> - Класове).</li>
					<li>
						<strong>Symbol.split </strong> - метод използван от
						<em>String.prototype.split()</em> за разделяне на
						<em>strings</em>.</li>
					<li>
						<strong>Symbol.toPrimitive </strong> - метод който връща представянето на примитивна стойност в обекта.</li>
					<li>
						<strong>Symbol.toStringTag</strong> -
						<em>string</em> използван от
						<em>Object.prototype.toString()</em> за създаване на описание на обект.</li>
					<li>
						<strong>Symbol.unscopables</strong> - обект, чиито свойства са имената на свойствата на обекта, които не трябва да бъдат включени
						в
						<em>with</em> изявление.</li>
				</ul>
			</dd>
		</dl>
		<p>Някои често използвани
			<em>well-known</em> <em>simbols</em> са обсъдени по-долу в раздела, а други са разгледани в останалата част от книгата, за да ги държи
			в правилния контекст.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Заменящия метод дефиниран с
					<em>well-known</em> <em>simbol</em>, променя обикновен обект в екзотичен, защото това променя някои вътрешни поведения по подразбиране.
					Това няма практическо отражение върху вашия код, като резултат, просто променя начина, по който спецификация описва
					обекта.</strong>
			</dd>
		</dl>
		<br>
		<h3>Symbol.hasInstance</h3>
		<p> Всяка функция има
			<em>Symbol.hasInstance</em> метод, които определя дали даден обект е инстанция на тази функция. Метода е дефиниран от
			<em>Function.prototype</em>, така че всички функции наследяват това поведение по подразбиране за
			<em>instanceof</em> свойството. В
			<em>Symbol.hasInstance</em>, самото свойство се определя, като
			<em>nonwritable</em> и
			<em>nonconfigurable</em>, като
			<em>nonenumerable</em> гарантира, че не се презаписва по погрешка.</p>
		<p>Метода
			<em>Symbol.hasInstance</em> приема един единствен аргумент: стойността за проверка. Той връща
			<em>true</em>, ако подадената стойност е инстанция на функцията. За да разберете, как
			<em>Symbol.hasInstance</em> работи, нека да разгледаме следния код:</p>
		<dl>
			<dd>
				<pre class="highlight">
obj <span class="code">instanceof Array</span>;
	    	</pre>
			</dd>
		</dl>
		<p>Този код е еквивалентен на:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">Array</span>[Symbol.hasInstance](obj);
	    	</pre>
			</dd>
		</dl>
		<p>По същество, ECMAScript 6 предефинира
			<em>instanceof</em> оператора, като кратък запис на синтаксиса за извикване на този метод. И сега, когато имате участващ извикан
			метод, всъщност можете да промените начина на работа на
			<em>instanceof</em>.</p>
		<p>Да предположим, че искате да дефинирате функция, която претендира, че няма обект, като инстанция. Можете да го направите
			<em>hardcoding</em> връщайки от
			<em>Symbol.hasInstance false</em>, като:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> MyObject() {
    // ...
}

<span class="code">Object</span>.defineProperty(MyObject, Symbol.hasInstance, {
    value: <span class="code">function</span>(v) {
        <span class="code">return false</span>;
    }
});

<span class="code">let</span> obj = <span class="code">new</span> MyObject();

console.log(obj <span class="code">instanceof</span> MyObject);       // false
	    	</pre>
			</dd>
		</dl>
		<p>Трябва да използвате
			<em>Object.defineProperty()</em> за презаписване на
			<em>nonwritable</em> свойство, така че, този пример да използва този метод, за да презапише
			<em>Symbol.hasInstance</em> с новата функция. Новата функцията винаги ще връща
			<em>false</em>, въпреки, че
			<em>obj</em> всъщност е инстанция на
			<em>MyObject</em>, защото оператора
			<em>instanceof</em> връща
			<em>false</em> след извикването на
			<em>Object.defineProperty()</em>.</p>
		<p>Разбира се, може също да инспектира стойността и да реши дали стойността трябва да се разглежда, като нейна инстанция въз
			основа на всяко произволно състояние. Например, може би числа със стойност между 1 и 100, трябва да се считат за инстанция
			на специален вид номер. За да се постигне това поведение, може да се напише код, подобен на този::</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> SpecialNumber() {
    // ...
}

<span class="code">Object</span>.defineProperty(SpecialNumber, Symbol.hasInstance, {
    value: <span class="code">function</span>(v) {
        <span class="code">return</span> (v <span class="code">instanceof Number</span>) && (v >= 1 && v <= 100);
    }
});

<span class="code">let</span> two = <span class="code">new Number</span>(2),
    zero = <span class="code">new Number</span>(0);

console.log(two <span class="code">instanceof</span> SpecialNumber);    // true
console.log(zero <span class="code">instanceof</span> SpecialNumber);   // false
	    	</pre>
			</dd>
		</dl>
		<p>Този код дефинира
			<em>Symbol.hasInstance</em> метод, който връща
			<em>true</em>, ако стойността е инстанция на
			<em>Number</em> и е в диапазона между 1 и 100. По този начин, позволява на
			<em>SpecialNumber</em> да претендира, че
			<em>two</em> е нейна инстанция въпреки, че няма пряка връзка между функцията
			<em>SpecialNumber</em> и
			<em>two</em> променливата. Имайте в предвид, че левият операнд на
			<em>instanceof</em> трябва да бъде обект, за да задейства извикването към
			<em>Symbol.hasInstance</em>, докато
			<em>nonobjects</em> причинява
			<em>instanceof</em> просто да връща
			<em>false</em> през цялото време.</p>
		<dl>
			<dd>
				<div class="worning">
					<img src="./img/worning.jpg" alt="worning">
				</div>
				<strong>Можете също така да замените по подразбиране
					<em>Symbol.hasInstance</em> свойството, на всички вградени функции, като
					<em>Date</em> и
					<em>Error</em>. Това не се препоръчва, тъй като ефектите върху вашия код може да бъдат неочаквани и объркващи. Добра идея
					е, да заменяте
					<em>Symbol.hasInstance</em> на вашите собствени функции само когато е необходимо.</strong>
			</dd>
		</dl>
		<h3>Symbol.isConcatSpreadable</h3>
		<p>JavaScript масивите имат
			<em>concat()</em> метод, който има за цел да залепи два масива заедно, например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> colors1 = [ "red", "green" ],
    colors2 = colors1.concat([ "blue", "black" ]);

console.log(colors2.length);    // 4
console.log(colors2);        // ["red","green","blue","black"]
	    	</pre>
			</dd>
		</dl>
		<p>Този код конкатенира нов масив от края на
			<em>colors1</em> и създава
			<em>colors2</em>, в единичен масив с всички елементи от двата масива. Обаче,
			<em>concat()</em> може да приема
			<em>nonarray</em> аргументи и в този случай тези аргументи просто се добавят към края на масива. Например:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">let</span> colors1 = [ "red", "green" ],
    colors2 = colors1.concat([ "blue", "black" ], "brown");

console.log(colors2.length);    // 5
console.log(colors2);           // ["red","green","blue","black","brown"]
	    	</pre>
			</dd>
		</dl>
		<p>Тука, допълнителния аргумент "brown" се подава на
			<em>concat()</em> и се превръща в петия елемент на
			<em>colors2</em>. Защо масив от аргументи се третира по различен начин от
			<em>string</em> аргументи? Спецификацията казва, че масивите автоматично се разделят на техните отделни елементи, а всички
			други типове не. Преди ECMAScript 6, нямаше начин да се коригира това поведение.</p>
		<p>Свойството
			<em>Symbol.isConcatSpreadable</em> е булева стойност, показваща дали даден обект има
			<em>lenght</em> свойство и цифрови ключове и дали тези номерирани стойности на свойства трябва да бъдат добавяни поотделно
			към резултата с
			<em>concat()</em>. За разлика от други
			<em>well-known</em> <em>simbols</em>, това <em>simbol</em> свойство не се дава на всички стандартни обекти по подразбиране. Вместо това, то
			е достъпно, като начин да се увеличи работата на
			<em>concat()</em> върху някои типове обекти, като поведение на късо съединение по подразбиране. Можте да определите всеки
			тип да се държи, както масиви в
			<em>concat()</em>, също като:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">let</span> collection = {
    0: "Hello",
    1: "world",
    length: 2,
    [Symbol.isConcatSpreadable]: <span class="code">true</span>
};

<span class="code">let</span> messages = [ "Hi" ].concat(collection);

console.log(messages.length);    // 3
console.log(messages);           // ["hi","Hello","world"]
	    	</pre>
			</dd>
		</dl>
		<p>Обекта
			<em>collection</em> в този пример, е настроен да изглежда, като масив: тoй има
			<em>length</em> свойство и два цифрови ключа. Свойството
			<em>Symbol.isConcatSpreadable</em> е определено на
			<em>true</em> за да покаже, че стойностите на свойствата трябва да се добавят, като отделни елементи към масива. Когато
			<em>collection</em> се подаде на
			<em>concat()</em> метода, резултата е масив, който съдържа "Hello" и "world", като отделни елементи след "hi" елемента.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Може също да настроите
					<em>Symbol.isConcatSpreadable</em> на
					<em>false</em> за масив от подкласове, за да се предотврати елементите да бъдат слепени посредством
					<em>concat()</em>. Под-класовете се обсъждат в
					<a href="09_classes.html">Глава 9</a>.</strong>
			</dd>
		</dl>
		<h3>Symbol.match, Symbol.replace, Symbol.search и Symbol.split </h3>
		<p>Винаги е имало тясна връзка между
			<em>strings</em> и регулярни изрази в JavaScript. Типа
			<em>string</em> по специално, има няколко метода, които приемат регулярни изрази, като аргументи.</p>
		<dl>
			<dd>
				<ul>
					<li>
						<strong>match(regex)</strong> - определя дали даден
						<em>string</em> съвпада с регулярен израз.</li>
					<li>
						<strong>replace(regex, replacement)</strong> - замества съвпадащия регулярен израз със заменящия</li>
					<li>
						<strong>search(regex)</strong> - открива съвпадение на регулярния израз вътре в
						<em>string</em>
					</li>
					<li>
						<strong>split(regex)</strong> - разделя
						<em>string</em> в масив по съвпаденията на регулярния израз</li>
				</ul>
			</dd>
		</dl>
		<p>Преди ECMAScript 6, начина по който тези методи са взаимодействали с регулярния израз е бил скрит от програмистите, не
			оставяйки никакъв начин да се имитира това, което регулярния израз прави с помощта на определени от програмиста обекти.
			ECMAScript 6 дефинира четири <em>simbol</em>, които отговарят на тези четири метода, ефективно отговарящи на поведението на вградения
			<em>RegExp</em> обект.</p>
		<p><em>simbols</em>
			<em>Symbol.match, Symbol.replace, Symbol.search</em> и
			<em>Symbol.split</em> представляват методи на аргумента на регулярния израз, който трябва да се извика, като първи аргумент
			на методите
			<em>match(), replace(), search()</em> и
			<em>split()</em>, съответно. Четирите <em>simbol</em> свойства са дефинирани в
			<em>RegExp.prototype</em> , като те трябва да се използват по подразбиране при изпълнение на методите.</p>
		<p>Знаейки това, можете да създадете обект за използване на методите на
			<em>string</em> по начин, който е подобен на регулярен израз. За да направите това, може да използвате следните <em>simbol</em> функции
			в кода:</p>
		<dl>
			<dd>
				<ul>
					<li>
						<strong>Symbol.match</strong> - функция, която приема за аргумент
						<em>string</em> и връща масив от съвпадения или
						<em>null</em>, ако не е намерила съвпадение.</li>
					<li>
						<strong>Symbol.replace</strong> - функция, която приема за аргумент
						<em>string</em> и
						<em>string</em> за замяна и връща
						<em>string</em>.</li>
					<li>
						<strong>Symbol.search</strong> - функция, която приема за аргумент
						<em>string</em> и връща номера с индекса на съвпадението или -1, ако не е намерила съвпадение.</li>
					<li>
						<strong>Symbol.split</strong>- функция, която приема за аргумент
						<em>string</em> и връща масив съдържащ парчета от
						<em>string</em>-а, разделени от съвпаденията</li>
				</ul>
			</dd>
		</dl>
		<p>Възможността да зададете тези свойства на даден обект ви позволява да създавате обекти, които прилагат модел за съвпадение
			без регулярни изрази и ги използват в методи, които очакват регулярни изрази. Ето един пример, който показва тези <em>simbols</em>
			в действие:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="comment">// ефективно еквивалентно на /^.{10}$/</span>
<span class="code">let</span> hasLengthOf10 = {
    [Symbol.match]: <span class="code">function</span>(value) {
        <span class="code">return</span> value.length === 10 ? [value.substring(0, 10)] : <span class="code">null</span>;
    },
    [Symbol.replace]: <span class="code">function</span>(value, replacement) {
        <span class="code">return</span> value.length === 10 ? replacement + value.substring(10) : value;
    },
    [Symbol.search]: <span class="code">function</span>(value) {
        <span class="code">return</span> value.length === 10 ? 0 : -1;
    },
    [Symbol.split]: <span class="code">function</span>(value) {
        <span class="code">return</span> value.length === 10 ? ["", ""] : [value];
    }
};

<span class="code">let</span> message1 = "Hello world",   // 11 characters
    message2 = "Hello John";    // 10 characters


<span class="code">let</span> match1 = message1.match(hasLengthOf10),
    match2 = message2.match(hasLengthOf10);

console.log(match1);            // null
console.log(match2);            // ["Hello John"]

<span class="code">let</span> replace1 = message1.replace(hasLengthOf10),
    replace2 = message2.replace(hasLengthOf10);

console.log(replace1);          // "Hello world"
console.log(replace2);          // "Hello John"

<span class="code">let</span> search1 = message1.search(hasLengthOf10),
    search2 = message2.search(hasLengthOf10);

console.log(search1);           // -1
console.log(search2);           // 0

<span class="code">let</span> split1 = message1.split(hasLengthOf10),
    split2 = message2.split(hasLengthOf10);

console.log(split1);            // ["Hello world"]
console.log(split2);            // ["", ""]
	   	</pre>
			</dd>
		</dl>
		<p>Тука,
			<em>hasLengthOf10</em> обекта е предназначен да работи подобно на регулярен израз, който съвпада, когато дължината (
			<em>length</em>) на
			<em>string</em> е точно 10. Всеки от четирите метода се осъществява чрез използване на съответните <em>simbols</em> и след това се
			извикват съответните методи на двата
			<em>strings</em>. Първия
			<em>string, message1</em>, има 11 знака и така няма да съвпадне; втория
			<em>string, message2</em>, има 10 знака и така ще съвпадне. Въпреки, че не е регулярен израз
			<em>hasLengthOf10</em> се подава на всеки
			<em>string</em> метод и се използва правилно поради допълнителните методи.</p>
		<p>Въпреки, че това е един прост пример, възможността да се извършват по-сложни съвпадения, от колкото е възможно в момента
			с регулярни изрази отваря много възможности.</p>
		<h3>Symbol.toPrimitive</h3>
		<p>JavaScript често се опитва да превърне обекти в примитивни стойности по подразбиране, когато се прилагат определени операции.
			Например, когато се сравнява
			<em>string</em> с даден обект с помощта на двойното равно (==), обекта се превръща в примитивна стойност преди това сравняване.
			Точно каква примитивна стойност трябва да се използва е вътрешна операция, която ECMAScript 6 излага чрез метода
			<em>Symbol.toPrimitive</em>.</p>
		<p>Метода
			<em>Symbol.toPrimitive</em> се определя за прототип на всеки стандартен тип и предписва точното поведение, когато обектът
			се превръща в примитивен тип. Когато е необходимо примитивно преобразуване, се извиква
			<em>Symbol.toPrimitive</em> с един аргумент, посочен като
			<em>hint</em> в спецификацията. Аргумента
			<em>hint</em> е един от следните три
			<em>string</em> стойности:</p>
		<dl>
			<dd>
				<ul>
					<li>
						<strong>Ако
							<em>hint</em> e "number"</strong> -
						<em>Symbol.toPrimitive</em> трябва да върнe номер</li>
					<li>
						<strong>Ако
							<em>hint</em> e "string" </strong> - трябва да върне
						<em>string</em>
					</li>
					<li>
						<strong>Ако
							<em>hint</em> е "default"</strong> - операцията няма предпочитания за вида</li>
				</ul>
			</dd>
		</dl>
		<p>За повечето стандартни обекти, поведението на
			<em>number</em> режим има следния приоритет:</p>
		<dl>
			<dd>
				<ol>
					<li>Извиква
						<em>valueOf()</em>, и ако резултата е примитивна стойност я връща.</li>
					<li>В противен случай, извиква
						<em>toString()</em> и ако резултата е примитивна стойност я връща.</li>
					<li>В противен случай хвърля грешка.</li>
				</ol>
			</dd>
		</dl>
		<p>По същия начин, за повечето стандартни обекти поведението на
			<em>string</em> режим има следния приоритет:</p>
		<dl>
			<dd>
				<ol>
					<li>Извиква
						<em>toString()</em> и ако резултата е примитивна стойност я връща.</li>
					<li>В противен случай, извиква
						<em>valueOf()</em> и ако резултата е примитивна стойност я връща.</li>
					<li>В противен случай хвърля грешка.</li>
				</ol>
			</dd>
		</dl>
		<p>В много случаи стандартните обекти третират режима по подразбиране, като равностоен на
			<em>number</em> режима (с изключение на
			<em>Date</em>, която се отнася към режима по подразбиране, като равностоен на
			<em>string</em> режима). Чрез дефиниране на
			<em>Symbol.toPrimitive</em>, можем да коригираме това поведение по подразбиране.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Режим по подразбиране се използва само за ==, + и при подаване на единичен аргумент към
					<em>Date</em> конструктора. Повечето операции използват
					<em>string</em> или
					<em>number</em> режим.</strong>
			</dd>
		</dl>
		<p>За да замените поведението по подразбиране, използвайте
			<em>Symbol.toPrimitive</em> и задайте функция, като негова стойност, Например:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> Temperature(degrees) {
    <span class="code">this</span>.degrees = degrees;
}

Temperature.prototype[Symbol.toPrimitive] = <span class="code">function</span>(hint) {

    <span class="code">switch</span> (hint) {
        <span class="code">case</span> "string":
            <span class="code">return this</span>.degrees + "\u00b0"; // degrees symbol

        <span class="code">case</span> "number":
            <span class="code">return this</span>.degrees;

        <span class="code">case</span> "default":
            <span class="code">return this</span>.degrees + " degrees";
    }
};

<span class="code">let</span> freezing = <span class="code">new</span> Temperature(32);

console.log(freezing + "!");            // "32 degrees!"
console.log(freezing / 2);              // 16
console.log(<span class="code">String</span>(freezing));          // "32째"
	   	</pre>
			</dd>
		</dl>
		<p>Този пример дефинира
			<em>Temperature</em> конструктор и заменя метода по подразбиране с
			<em>Symbol.toPrimitive</em> на прототипа. Различна стойност се връща в зависимост от това дали
			<em>hint</em> аргумента е
			<em>string</em>,
			<em>number</em> или
			<em>default</em> стойност. В
			<em>string</em> режима функцията
			<em>Temperature()</em> връща температурата с Unicode характера за градус. В
			<em>number</em> режима връща само цифрова стойност, а в режима по подразбиране добавя думата “degrees” след цифрите.</p>
		<p> Всяко от твърдения в
			<em>console.log</em> предизвиква различна
			<em>hint</em> аргумент стойност. Операторът + предизвиква
			<em>default</em> режим, чрез определяне на
			<em>hint</em> към "default", операторът / предизвиква
			<em>number</em> режим, чрез определяне
			<em>hint</em> към "number" и
			<em>String ()</em> функцията предизвиква
			<em>string</em> режим, чрез определяне
			<em>hint</em> към 'string'. Въпреки че е възможно да върне различни стойности за всичките три режима, много по-често използвано
			е да настроите
			<em>default</em> режима да е същия, като за
			<em>string</em> или
			<em>number</em> режим.</p>
		<h3>Symbol.toStringTag</h3>
		<p>Един от най-интересните проблеми на JavaScript е наличието на множество глобални среди на изпълнение. Това се случва в
			уеб-браузъри, когато една страница включва вградена рамка на друга страница, като всяка от тях има собствена среда на
			изпълнение. В повечето случаи това не е проблем, тъй като данните могат да се предават напред и назад между среди без
			да причиняват безпокойство. Проблемът възниква, когато се опитваме да се идентифицираме типа на обекта, с който имаме
			работа след като е бил прехвърлен между различните обекти.</p>
		<p>В каноничен пример, това е подаване на масив от вградената рамка в съдържащата страница или обратно. В ECMAScript 6 терминологията,
			вградена рамка и съдържаща страница, всяка представлява различна област, която е среда за изпълнение на JavaScript. Всяка
			област има свой собствен глобален обхват с негово собствено копие на глобални обекти. В зависимост от това в коя област
			се създава масива, се определя вида на масива. Когато това е в различна среда на изпълнение
			<em>instanceof Array</em> връща
			<em>false</em>, защото масива е създаден с конструктор от различни среди.</p>
		<h3>Временно решение за идентифициране на проблема</h3>
		<p>Сблъсквайки се с този проблем програмистите много скоро намериха добър начин за идентифициране на масиви. Те открили, че
			когато се извика стандартния метод
			<em>toString()</em> върху обект, се връща винаги предвидим
			<em>string</em>. По този начин , много JavaScript библиотеки, започнаха да включват функция, която работи подобно на това:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">function</span> isArray(value) {
    <span class="code">return Object</span>.prototype.toString.call(value) === "[object Array]";
}

console.log(isArray([]));   // true
	   	</pre>
			</dd>
		</dl>
		<p>Това може да изглежда малко, като кръгово движение, но в действителност е установено, че работи добре за идентифициране
			на масиви във всички браузъри. Метода
			<em>toString()</em> за масиви не е много полезен за идентифициране на обект, тъй като връща
			<em>string</em> представяне на елементите на обекта, които съдържа. Но методa
			<em>toString ()</em> на
			<em>Object.prototype</em> има тази идея: той включва вътрешно-дефинирано име, наречено [[class]] във върнатия резултат. Програмистите
			могат да използват този метод върху даден обект, за да извлекат, това което околната среда на JavaScript смята за тип
			на данните на обекта.</p>
		<p>Програмистите бързо осъзнаха, че тъй като няма начин да променят това поведение, е възможно да се използва същия подход,
			за да направи разлика между местни обекти и тези създадени от програмисти. Най-важния от тях е ECMAScript 5 JSON обекта.</p>
		<p>Преди ECMAScript 5, много употребяван е
			<em>Douglas Crockford’s json2.js</em>, който създава глобален JSON обект. Когато браузърите започнаха да прилагат глобалния
			JSON обект, се наложи да се каже дали глобалния JSON е предоставен от самата среда на JavaScript или чрез някоя друга
			библиотека. Използвайки същата техника, която показах с функцията
			<em>isArray()</em>, много програмисти създадоха функции, като тази:</p>
		<dl>
			<dd>
				<pre class="highlight">
<span class="code">function</span> supportsNativeJSON() {
    <span class="code">return typeof</span> JSON !== "undefined" &&
      <span class="code">Object</span>.prototype.toString.call(JSON) === "[object JSON]";
}
	   	</pre>
			</dd>
		</dl>
		<p>Това, е същата характеристика на
			<em>Object.prototype</em>, която позволява на програмистите да идентифицират масиви в границите на вградената рамка и също
			предоставя начин да се разбере дали JSON е местен обект или не. Не-местен JSON обект ще върне [object Object], докато
			местния обект ще върне [object JSON]. Този подход се превърна в стандарт за идентифициране на местни обекти.</p>
		<h3>Отговора на ECMAScript 6</h3>
		<p>ECMAScript 6 предефинира това поведение чрез
			<em>Symbol.toStringTag</em> <em>simbol</em>. Този <em>simbol</em> представлява свойство на всеки обект, което определя, каква стойност трябва
			да се произведе, когато
			<em>Object.prototype.toString.call()</em> се извика върху него. За масив, стойността която функцията връща се обяснява със
			съхранение на "Array" в
			<em>Symbol.toStringTag</em> свойството.</p>
		<p> По същия начин, можете да определите
			<em>Symbol.toStringTag</em> стойността на вашите собствени обекти.</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">function</span> Person(name) {
    <span class="code">this</span>.name = name;
}

Person.prototype[Symbol.toStringTag] = "Person";

<span class="code">let</span> me = <span class="code">new</span> Person("Nicholas");

console.log(me.toString());                         // "[object Person]"
console.log(<span class="code">Object</span>.prototype.toString.call(me));    // "[object Person]"
	   	</pre>
			</dd>
		</dl>
		<p>В този пример, свойството
			<em>Symbol.toStringTag</em> се дефинира в
			<em>Person.prototype</em>, за да осигури поведение по подразбиране за създаване на
			<em>string</em> представяне. Тъй като,
			<em>Person.prototype</em> наследява
			<em>Object.prototype.toString()</em> метода, стойността върната от
			<em>Symbol.toStringTag</em> се използва също, като извикване на
			<em>me.toString()</em> метода. Въпреки това, все още можете да определите свой
			<em>toString()</em> метод, който осигурява различно поведение, без да засяга използването на
			<em>Object.prototype.toString.call()</em> метода. Ето как може да изглежда това:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">function</span> Person(name) {
    <span class="code">this</span>.name = name;
}

Person.prototype[Symbol.toStringTag] = "Person";

Person.prototype.toString = <span class="code">function</span>() {
    <span class="code">return this</span>.name;
};

<span class="code">let</span> me = <span class="code">new</span> Person("Nicholas");

console.log(me.toString());                         // "Nicholas"
console.log(<span class="code">Object</span>.prototype.toString.call(me));    // "[object Person]"
	   	</pre>
			</dd>
		</dl>
		<p>Този контекст дефинира
			<em>Person.prototype.toString()</em> да връща стойността на
			<em>name</em> свойството. Тъй като
			<em>Person</em> инстанцията вече не се наследява от
			<em>Object.prototype.toString()</em> метода, извиквайки
			<em>me.toString()</em> проявява различно поведение.</p>
		<dl>
			<dd>
				<div class="info">
					<img src="./img/info.jpg" alt="info">
				</div>
				<strong>Всички обекти наследяват
					<em>Symbol.toStringTag</em> от
					<em>Object.prototype</em>, освен ако не е посочено нещо друго. Стойността на свойството по подразбиране е "Object".</strong>
			</dd>
		</dl>
		<p>Няма ограничения с кои стойности може да бъде използван
			<em>Symbol.toStringTag</em> върху определените от програмиста обекти. Например, нищо не пречи да използваме "Array", като
			стойност на
			<em>Symbol.toStringTag</em>, също като:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">function</span> Person(name) {
    <span class="code">this</span>.name = name;
}

Person.prototype[Symbol.toStringTag] = "Array";

Person.prototype.toString = <span class="code">function</span>() {
    <span class="code">return this</span>.name;
};

<span class="code">let</span> me = <span class="code">new</span> Person("Nicholas");

console.log(me.toString());                         // "Nicholas"
console.log(<span class="code">Object</span>.prototype.toString.call(me));    // "[object Array]"
	   	</pre>
			</dd>
		</dl>
		<p>В този код, резултата от извикването на
			<em>Object.prototype.toString()</em> е "[object Array]", което е същото, като което ще получим от действителен масив. Това
			подчертава факта, че
			<em>Object.prototype.toString()</em> вече не е напълно надежден начин за идентифициране на типа на даден обект.</p>
		<p>Възможно е да се промени
			<em>string</em> маркера на местния обект, чрез присвояване на
			<em>Symbol.toStringTag</em> на неговия прототип. Например:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">Array</span>.prototype[Symbol.toStringTag] = "Magic";

<span class="code">let</span> values = [];

console.log(<span class="code">Object</span>.prototype.toString.call(values));    // "[object Magic]"
	   	</pre>
			</dd>
		</dl>
		<p>Въпреки, че
			<em>Symbol.toStringTag</em> се презаписва за масива в този пример, извикването на
			<em>Object.prototype.toString()</em> води до "[object Magic]". Въпреки, че не се препоръчва да се променят вградени обекти
			по този начин, няма нищо в езика, което да го забранява.</p>
		<h3>Symbol.unscopables</h3>
		<p>The
			<em>with</em> изявлението е една от най-спорните части в JavaScript. Първоначално предназначено за избягване на повторно писане,
			<em>with</em> изявлението по-късно става открито критикувано за правенето на кода по-трудно разбираем и за отрицателните последици
			при изпълнение, както и това че е склонно към грешки.</p>
		<p>В резултат на това,
			<em>with</em> изявлението не е разширено в
			<em>strict mode</em>, което се отразява на класове и модули, които са под
			<em>strict mode</em> по подразбиране, без право на изключения.</p>
		<p> Въпреки, че няма бъдеще за
			<em>with</em> изявлението, ECMAScript 6 все още го поддържа в
			<em>nonstrict mode</em> за обратна съвместимост и като такова, трябва да намери начин да позволи на кода да продължи да работи
			правилно с използването на
			<em>with</em>.</p>
		<p>За да се разбере сложността на тази задача, да разгледаме следния код:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="code">let</span> values = [1, 2, 3],
    colors = ["red", "green", "blue"],
    color = "black";

<span class="code">with</span>(colors) {
    push(color);
    push(...values);
}

console.log(colors);    // ["red", "green", "blue", "black", 1, 2, 3]
	   	</pre>
			</dd>
		</dl>
		<p>В този пример, двете извиквания на
			<em>push()</em> вътре в
			<em>with</em> изявлението, са еквивалентни на
			<em>colors.push()</em>, защото
			<em>with</em> изявлението добавя
			<em>puhs</em> в локалното обвързване. Препратката към
			<em>color</em> се отнася до променлива, създадена извън
			<em>whit</em>, което прави
			<em>values</em> референтна.</p>
		<p>ECMAScript 6 добавя метода
			<em>values()</em> за масиви (Метода
			<em>values()</em> е разгледан по-подробно в
			<a href="08_iterators_and_generators.html">Глава 8</a> -
			<em>Iterators</em> и
			<em>Generators</em>). Това би означавало, че в ECMAScript 6 среда, препратката към
			<em>values</em> в рамките на
			<em>with</em> изявлението, трябва да се отнася не към локалната променлива
			<em>values</em>, а към стойностите на метода
			<em>values</em> на масива, което ще прекъсне кода. Ето, защо <em>simbol</em>
			<em>Symbol.unscopables</em> съществува.</p>
		<p><em>Simbol</em>
			<em>Symbol.unscopables</em> се използва за
			<em>Array.prototype</em> за да посочи, кои свойства не трябва да създават обвързвания във вътрешността на
			<em>with</em> изявление. Когато е налице,
			<em>Symbol.unscopables</em> е обект, чийто ключове са идентификатори за пропускане на
			<em>whit</em> обвързвания и чийто стойности са
			<em>true</em> за прилагане на блока. Тук е по подразбиране за масиви:</p>
		<dl>
			<dd>
				<pre class="highlight-overflow">
<span class="comment">// вградено в ECMAScript 6 по подразбиране</span>
<span class="code">Array</span>.prototype[Symbol.unscopables] = <span class="code">Object</span>.assign(<span class="code">Object</span>.create(<span class="code">null</span>), {
    copyWithin: <span class="code">true</span>,
    entries: <span class="code">true</span>,
    fill: <span class="code">true</span>,
    find, <span class="code">true</span>,
    findIndex: <span class="code">true</span>,
    keys: <span class="code">true</span>,
    values: <span class="code">true</span>
});
	   	</pre>
			</dd>
		</dl>
		<p>Обекта
			<em>Symbol.unscopables</em> има
			<em>null</em> прототип създаден от
			<em>Object.create(null)</em> и съдържа всички нови методи за масиви в ECMAScript 6 (тези методи са разгледани подробно в
			<a
			 href="08_iterators_and_generators.html">Глава 8</a> - Iterators и Generators и в
				<a href="10_array.html">Глава 10</a> - Arrays). Обвързванията за тези методи не са създадени вътре в
				<em>with</em> изявлението, което позволява на стария код да продължи да работи без никакъв проблем.</p>
		<p>По принцип, не трябва да се дефинира
			<em>Symbol.unscopables</em> за вашите обекти, освен ако не използвате
			<em>with</em> изявление или се правят промени в съществуващ обект във вашия база код.</p>
	</article>
	<footer>
		<h3>Обобщение</h3>
		<p><em>Simbols</em> са нов вид примитивни стойности в JavaScript и се използват за създаване на
			<em>nonenumerable</em> свойства, които не могат да бъдат достъпни без да използват <em>simbol</em> за достъп.</p>
		<p> Докато не са наистина частни, тези свойства е трудно да се променят или заменят и следователно са подходящи за функционалност,
			която се нуждае от ниво на защита от страна на програмистите.</p>
		<p>Може да предоставите описание за <em>simbols</em>, което дава възможност за по-лесно идентифициране на <em>simbol</em> стойности. Има глобален
			<em>simbol</em> регистър, който позволява използването на споделени <em>simbols</em> в различни части на кода с помощта на едно и също описание.
			По този начин един и същи <em>simbol</em> може да се използва за същата причина на няколко места.</p>
		<p>Методи, както
			<em>Object.keys()</em> или
			<em>Object.getOwnPropertyNames()</em> не връщат <em>simbols</em>, така че е добавен нов метод
			<em>Object.getOwnPropertySymbols()</em>, който дава възможност за извличане на <em>simbol</em> свойствата. Вие можете да направите
			промени в <em>simbol</em> свойствата, чрез използване на
			<em>Object.defineProperty()</em> и
			<em>Object.defineProperties()</em>.</p>
		<p>
			<em>Well-known</em> <em>simbols</em> са дефинирани преди това, само за вътрешна функционалност за стандартни обекти и използват глобално
			достъпни <em>simbol</em> константи, като
			<em>Symbol.hasInstance</em>. Тези <em>simbols</em> използват префикс
			<em>Symbol</em> в спецификацията и позволяват на програмистите да модифицират поведението на стандартен обект по най-различни
			начини.</p>
	</footer>
	<nav>
		<a href="./05_destructured.html" title="previous chapter">◀</a>
		<a href="./index.html" title="cover">◆</a>
		<a href="./07_set_and_map.html" title="next chapter">▶</a>
	</nav>
</body>

</html>